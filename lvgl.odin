/*
	THIS FILE WAS GENERATED BY gen_lvgl.odin. DO NOT MODIFY
	THIS FILE WAS GENERATED BY gen_lvgl.odin. DO NOT MODIFY
	THIS FILE WAS GENERATED BY gen_lvgl.odin. DO NOT MODIFY

	GENERATED FROM LVGL VERSION 9.5
*/
package lvgl

import "core:c"

when ODIN_OS == .Linux {
foreign import lvgl {
	"lib/liblvgl.a",
}
} else when ODIN_OS == .Windows {
foreign import lvgl {
	"lib/lvgl.lib",
}
} else when ODIN_OS == .Darwin {
	// TODO: implement me
}

/*
    ----------------
     ENUMS
    ----------------
*/

lv_result_t :: enum i32 {
	LV_RESULT_INVALID = 0x0,
	LV_RESULT_OK = 0x1,
}

lv_rb_color_t :: enum i32 {
	LV_RB_COLOR_RED = 0x0,
	LV_RB_COLOR_BLACK = 0x1,
}

lv_align_t :: enum i32 {
	LV_ALIGN_DEFAULT = 0x00,
	LV_ALIGN_TOP_LEFT = 0x01,
	LV_ALIGN_TOP_MID = 0x02,
	LV_ALIGN_TOP_RIGHT = 0x03,
	LV_ALIGN_BOTTOM_LEFT = 0x04,
	LV_ALIGN_BOTTOM_MID = 0x05,
	LV_ALIGN_BOTTOM_RIGHT = 0x06,
	LV_ALIGN_LEFT_MID = 0x07,
	LV_ALIGN_RIGHT_MID = 0x08,
	LV_ALIGN_CENTER = 0x09,
	LV_ALIGN_OUT_TOP_LEFT = 0x0A,
	LV_ALIGN_OUT_TOP_MID = 0x0B,
	LV_ALIGN_OUT_TOP_RIGHT = 0x0C,
	LV_ALIGN_OUT_BOTTOM_LEFT = 0x0D,
	LV_ALIGN_OUT_BOTTOM_MID = 0x0E,
	LV_ALIGN_OUT_BOTTOM_RIGHT = 0x0F,
	LV_ALIGN_OUT_LEFT_TOP = 0x10,
	LV_ALIGN_OUT_LEFT_MID = 0x11,
	LV_ALIGN_OUT_LEFT_BOTTOM = 0x12,
	LV_ALIGN_OUT_RIGHT_TOP = 0x13,
	LV_ALIGN_OUT_RIGHT_MID = 0x14,
	LV_ALIGN_OUT_RIGHT_BOTTOM = 0x15,
}

lv_dir_t :: enum i32 {
	LV_DIR_NONE = 0x00,
	LV_DIR_LEFT = 0x01,
	LV_DIR_RIGHT = 0x02,
	LV_DIR_TOP = 0x04,
	LV_DIR_BOTTOM = 0x08,
	LV_DIR_HOR = 0x03,
	LV_DIR_VER = 0x0C,
	LV_DIR_ALL = 0x0F,
}

/* Opacity percentages.  */
_lv_opacity_level_t :: enum i32 {
	LV_OPA_TRANSP = 0x000,
	LV_OPA_0 = 0x000,
	LV_OPA_10 = 0x019,
	LV_OPA_20 = 0x033,
	LV_OPA_30 = 0x04C,
	LV_OPA_40 = 0x066,
	LV_OPA_50 = 0x07F,
	LV_OPA_60 = 0x099,
	LV_OPA_70 = 0x0B2,
	LV_OPA_80 = 0x0CC,
	LV_OPA_90 = 0x0E5,
	LV_OPA_100 = 0x0FF,
	LV_OPA_COVER = 0x0FF,
}

lv_color_format_t :: enum i32 {
	LV_COLOR_FORMAT_UNKNOWN = 0x00,
	LV_COLOR_FORMAT_RAW = 0x01,
	LV_COLOR_FORMAT_RAW_ALPHA = 0x02,
	LV_COLOR_FORMAT_L8 = 0x06,
	LV_COLOR_FORMAT_I1 = 0x07,
	LV_COLOR_FORMAT_I2 = 0x08,
	LV_COLOR_FORMAT_I4 = 0x09,
	LV_COLOR_FORMAT_I8 = 0x0A,
	LV_COLOR_FORMAT_A8 = 0x0E,
	LV_COLOR_FORMAT_RGB565 = 0x12,
	/* Not supported by sw renderer yet.  */
	LV_COLOR_FORMAT_ARGB8565 = 0x13,
	/* Color array followed by Alpha array  */
	LV_COLOR_FORMAT_RGB565A8 = 0x14,
	/* L8 with alpha >  */
	LV_COLOR_FORMAT_AL88 = 0x15,
	LV_COLOR_FORMAT_RGB565_SWAPPED = 0x1B,
	LV_COLOR_FORMAT_RGB888 = 0x0F,
	LV_COLOR_FORMAT_ARGB8888 = 0x10,
	LV_COLOR_FORMAT_XRGB8888 = 0x11,
	LV_COLOR_FORMAT_ARGB8888_PREMULTIPLIED = 0x1A,
	LV_COLOR_FORMAT_A1 = 0x0B,
	LV_COLOR_FORMAT_A2 = 0x0C,
	LV_COLOR_FORMAT_A4 = 0x0D,
	LV_COLOR_FORMAT_ARGB1555 = 0x16,
	LV_COLOR_FORMAT_ARGB4444 = 0x17,
	LV_COLOR_FORMAT_ARGB2222 = 0x18,
	LV_COLOR_FORMAT_YUV_START = 0x20,
	LV_COLOR_FORMAT_I420 = 0x20,
	LV_COLOR_FORMAT_I422 = 0x21,
	LV_COLOR_FORMAT_I444 = 0x22,
	LV_COLOR_FORMAT_I400 = 0x23,
	LV_COLOR_FORMAT_NV21 = 0x24,
	LV_COLOR_FORMAT_NV12 = 0x25,
	LV_COLOR_FORMAT_YUY2 = 0x26,
	LV_COLOR_FORMAT_UYVY = 0x27,
	LV_COLOR_FORMAT_YUV_END = 0x27,
	LV_COLOR_FORMAT_PROPRIETARY_START = 0x30,
	LV_COLOR_FORMAT_NEMA_TSC_START = 0x30,
	LV_COLOR_FORMAT_NEMA_TSC4 = 0x30,
	LV_COLOR_FORMAT_NEMA_TSC6 = 0x31,
	LV_COLOR_FORMAT_NEMA_TSC6A = 0x32,
	LV_COLOR_FORMAT_NEMA_TSC6AP = 0x33,
	LV_COLOR_FORMAT_NEMA_TSC12 = 0x34,
	LV_COLOR_FORMAT_NEMA_TSC12A = 0x35,
	LV_COLOR_FORMAT_NEMA_TSC_END = 0x35,
	LV_COLOR_FORMAT_NATIVE = 0x12,
	LV_COLOR_FORMAT_NATIVE_WITH_ALPHA = 0x14,
}

lv_palette_t :: enum i32 {
	LV_PALETTE_RED = 0x000,
	LV_PALETTE_PINK = 0x001,
	LV_PALETTE_PURPLE = 0x002,
	LV_PALETTE_DEEP_PURPLE = 0x003,
	LV_PALETTE_INDIGO = 0x004,
	LV_PALETTE_BLUE = 0x005,
	LV_PALETTE_LIGHT_BLUE = 0x006,
	LV_PALETTE_CYAN = 0x007,
	LV_PALETTE_TEAL = 0x008,
	LV_PALETTE_GREEN = 0x009,
	LV_PALETTE_LIGHT_GREEN = 0x00A,
	LV_PALETTE_LIME = 0x00B,
	LV_PALETTE_YELLOW = 0x00C,
	LV_PALETTE_AMBER = 0x00D,
	LV_PALETTE_ORANGE = 0x00E,
	LV_PALETTE_DEEP_ORANGE = 0x00F,
	LV_PALETTE_BROWN = 0x010,
	LV_PALETTE_BLUE_GREY = 0x011,
	LV_PALETTE_GREY = 0x012,
	LV_PALETTE_LAST = 0x013,
	LV_PALETTE_NONE = 0x0FF,
}

lv_image_compress_t :: enum i32 {
	LV_IMAGE_COMPRESS_NONE = 0x0,
	/* LVGL custom RLE compression  */
	LV_IMAGE_COMPRESS_RLE = 0x1,
	LV_IMAGE_COMPRESS_LZ4 = 0x2,
}

_lv_tree_walk_mode_t :: enum i32 {
	LV_TREE_WALK_PRE_ORDER = 0x0,
	LV_TREE_WALK_POST_ORDER = 0x1,
}

_lv_str_symbol_id_t :: enum i32 {
	LV_STR_SYMBOL_BULLET = 0x00,
	LV_STR_SYMBOL_AUDIO = 0x01,
	LV_STR_SYMBOL_VIDEO = 0x02,
	LV_STR_SYMBOL_LIST = 0x03,
	LV_STR_SYMBOL_OK = 0x04,
	LV_STR_SYMBOL_CLOSE = 0x05,
	LV_STR_SYMBOL_POWER = 0x06,
	LV_STR_SYMBOL_SETTINGS = 0x07,
	LV_STR_SYMBOL_HOME = 0x08,
	LV_STR_SYMBOL_DOWNLOAD = 0x09,
	LV_STR_SYMBOL_DRIVE = 0x0A,
	LV_STR_SYMBOL_REFRESH = 0x0B,
	LV_STR_SYMBOL_MUTE = 0x0C,
	LV_STR_SYMBOL_VOLUME_MID = 0x0D,
	LV_STR_SYMBOL_VOLUME_MAX = 0x0E,
	LV_STR_SYMBOL_IMAGE = 0x0F,
	LV_STR_SYMBOL_TINT = 0x10,
	LV_STR_SYMBOL_PREV = 0x11,
	LV_STR_SYMBOL_PLAY = 0x12,
	LV_STR_SYMBOL_PAUSE = 0x13,
	LV_STR_SYMBOL_STOP = 0x14,
	LV_STR_SYMBOL_NEXT = 0x15,
	LV_STR_SYMBOL_EJECT = 0x16,
	LV_STR_SYMBOL_LEFT = 0x17,
	LV_STR_SYMBOL_RIGHT = 0x18,
	LV_STR_SYMBOL_PLUS = 0x19,
	LV_STR_SYMBOL_MINUS = 0x1A,
	LV_STR_SYMBOL_EYE_OPEN = 0x1B,
	LV_STR_SYMBOL_EYE_CLOSE = 0x1C,
	LV_STR_SYMBOL_WARNING = 0x1D,
	LV_STR_SYMBOL_SHUFFLE = 0x1E,
	LV_STR_SYMBOL_UP = 0x1F,
	LV_STR_SYMBOL_DOWN = 0x20,
	LV_STR_SYMBOL_LOOP = 0x21,
	LV_STR_SYMBOL_DIRECTORY = 0x22,
	LV_STR_SYMBOL_UPLOAD = 0x23,
	LV_STR_SYMBOL_CALL = 0x24,
	LV_STR_SYMBOL_CUT = 0x25,
	LV_STR_SYMBOL_COPY = 0x26,
	LV_STR_SYMBOL_SAVE = 0x27,
	LV_STR_SYMBOL_BARS = 0x28,
	LV_STR_SYMBOL_ENVELOPE = 0x29,
	LV_STR_SYMBOL_CHARGE = 0x2A,
	LV_STR_SYMBOL_PASTE = 0x2B,
	LV_STR_SYMBOL_BELL = 0x2C,
	LV_STR_SYMBOL_KEYBOARD = 0x2D,
	LV_STR_SYMBOL_GPS = 0x2E,
	LV_STR_SYMBOL_FILE = 0x2F,
	LV_STR_SYMBOL_WIFI = 0x30,
	LV_STR_SYMBOL_BATTERY_FULL = 0x31,
	LV_STR_SYMBOL_BATTERY_3 = 0x32,
	LV_STR_SYMBOL_BATTERY_2 = 0x33,
	LV_STR_SYMBOL_BATTERY_1 = 0x34,
	LV_STR_SYMBOL_BATTERY_EMPTY = 0x35,
	LV_STR_SYMBOL_USB = 0x36,
	LV_STR_SYMBOL_BLUETOOTH = 0x37,
	LV_STR_SYMBOL_TRASH = 0x38,
	LV_STR_SYMBOL_EDIT = 0x39,
	LV_STR_SYMBOL_BACKSPACE = 0x3A,
	LV_STR_SYMBOL_SD_CARD = 0x3B,
	LV_STR_SYMBOL_NEW_LINE = 0x3C,
	LV_STR_SYMBOL_DUMMY = 0x3D,
}

lv_font_glyph_format_t :: enum i32 {
	/* Maybe not visible Legacy simple formats  */
	LV_FONT_GLYPH_FORMAT_NONE = 0x000,
	/* 1 bit per pixel  */
	LV_FONT_GLYPH_FORMAT_A1 = 0x001,
	/* 2 bit per pixel  */
	LV_FONT_GLYPH_FORMAT_A2 = 0x002,
	/* 3 bit per pixel  */
	LV_FONT_GLYPH_FORMAT_A3 = 0x003,
	/* 4 bit per pixel  */
	LV_FONT_GLYPH_FORMAT_A4 = 0x004,
	/* 8 bit per pixel  */
	LV_FONT_GLYPH_FORMAT_A8 = 0x008,
	/* Image format Advanced formats  */
	LV_FONT_GLYPH_FORMAT_IMAGE = 0x019,
	/* Vectorial format  */
	LV_FONT_GLYPH_FORMAT_VECTOR = 0x01A,
	/* SVG format  */
	LV_FONT_GLYPH_FORMAT_SVG = 0x01B,
	/* Custom format  */
	LV_FONT_GLYPH_FORMAT_CUSTOM = 0x0FF,
}

lv_font_subpx_t :: enum i32 {
	LV_FONT_SUBPX_NONE = 0x0,
	LV_FONT_SUBPX_HOR = 0x1,
	LV_FONT_SUBPX_VER = 0x2,
	LV_FONT_SUBPX_BOTH = 0x3,
}

lv_font_kerning_t :: enum i32 {
	LV_FONT_KERNING_NORMAL = 0x0,
	LV_FONT_KERNING_NONE = 0x1,
}

lv_text_flag_t :: enum i32 {
	LV_TEXT_FLAG_NONE = 0x0,
	LV_TEXT_FLAG_EXPAND = 0x1,
	/* Max-width is already equal to the longest line. (Used to skip some calculation)  */
	LV_TEXT_FLAG_FIT = 0x2,
	/* To prevent overflow, insert breaks between any two characters. Otherwise breaks are inserted at word boundaries, as configured via LV_TXT_BREAK_CHARS or according to LV_TXT_LINE_BREAK_LONG_LEN, LV_TXT_LINE_BREAK_LONG_PRE_MIN_LEN, and LV_TXT_LINE_BREAK_LONG_POST_MIN_LEN.  */
	LV_TEXT_FLAG_BREAK_ALL = 0x4,
	/* Enable parsing of recolor command  */
	LV_TEXT_FLAG_RECOLOR = 0x8,
}

lv_text_align_t :: enum i32 {
	/* Align text auto  */
	LV_TEXT_ALIGN_AUTO = 0x0,
	/* Align text to left  */
	LV_TEXT_ALIGN_LEFT = 0x1,
	/* Align text to center  */
	LV_TEXT_ALIGN_CENTER = 0x2,
	/* Align text to right  */
	LV_TEXT_ALIGN_RIGHT = 0x3,
}

lv_base_dir_t :: enum i32 {
	LV_BASE_DIR_LTR = 0x00,
	LV_BASE_DIR_RTL = 0x01,
	LV_BASE_DIR_AUTO = 0x02,
	LV_BASE_DIR_NEUTRAL = 0x20,
	LV_BASE_DIR_WEAK = 0x21,
}

lv_grad_dir_t :: enum i32 {
	/* No gradient (the grad_color property is ignored)  */
	LV_GRAD_DIR_NONE = 0x0,
	/* Simple vertical (top to bottom) gradient  */
	LV_GRAD_DIR_VER = 0x1,
	/* Simple horizontal (left to right) gradient  */
	LV_GRAD_DIR_HOR = 0x2,
	/* Linear gradient defined by start and end points. Can be at any angle.  */
	LV_GRAD_DIR_LINEAR = 0x3,
	/* Radial gradient defined by start and end circles  */
	LV_GRAD_DIR_RADIAL = 0x4,
	/* Conical gradient defined by center point, start and end angles  */
	LV_GRAD_DIR_CONICAL = 0x5,
}

lv_grad_extend_t :: enum i32 {
	/* Repeat the same color  */
	LV_GRAD_EXTEND_PAD = 0x0,
	/* Repeat the pattern  */
	LV_GRAD_EXTEND_REPEAT = 0x1,
	/* Repeat the pattern mirrored  */
	LV_GRAD_EXTEND_REFLECT = 0x2,
}

lv_layout_t :: enum i32 {
	LV_LAYOUT_NONE = 0x0,
	LV_LAYOUT_FLEX = 0x1,
	LV_LAYOUT_GRID = 0x2,
	LV_LAYOUT_LAST = 0x3,
}

lv_flex_align_t :: enum i32 {
	LV_FLEX_ALIGN_START = 0x0,
	LV_FLEX_ALIGN_END = 0x1,
	LV_FLEX_ALIGN_CENTER = 0x2,
	LV_FLEX_ALIGN_SPACE_EVENLY = 0x3,
	LV_FLEX_ALIGN_SPACE_AROUND = 0x4,
	LV_FLEX_ALIGN_SPACE_BETWEEN = 0x5,
}

lv_flex_flow_t :: enum i32 {
	LV_FLEX_FLOW_ROW = 0x0,
	LV_FLEX_FLOW_COLUMN = 0x1,
	LV_FLEX_FLOW_ROW_WRAP = 0x4,
	LV_FLEX_FLOW_ROW_REVERSE = 0x8,
	LV_FLEX_FLOW_ROW_WRAP_REVERSE = 0xC,
	LV_FLEX_FLOW_COLUMN_WRAP = 0x5,
	LV_FLEX_FLOW_COLUMN_REVERSE = 0x9,
	LV_FLEX_FLOW_COLUMN_WRAP_REVERSE = 0xD,
}

lv_grid_align_t :: enum i32 {
	LV_GRID_ALIGN_START = 0x0,
	LV_GRID_ALIGN_CENTER = 0x1,
	LV_GRID_ALIGN_END = 0x2,
	LV_GRID_ALIGN_STRETCH = 0x3,
	LV_GRID_ALIGN_SPACE_EVENLY = 0x4,
	LV_GRID_ALIGN_SPACE_AROUND = 0x5,
	LV_GRID_ALIGN_SPACE_BETWEEN = 0x6,
}

lv_blend_mode_t :: enum i32 {
	/* Simply mix according to the opacity value  */
	LV_BLEND_MODE_NORMAL = 0x0,
	/* Add the respective color channels  */
	LV_BLEND_MODE_ADDITIVE = 0x1,
	/* Subtract the foreground from the background  */
	LV_BLEND_MODE_SUBTRACTIVE = 0x2,
	/* Multiply the foreground and background  */
	LV_BLEND_MODE_MULTIPLY = 0x3,
	/* Absolute difference between foreground and background  */
	LV_BLEND_MODE_DIFFERENCE = 0x4,
}

lv_text_decor_t :: enum i32 {
	LV_TEXT_DECOR_NONE = 0x0,
	LV_TEXT_DECOR_UNDERLINE = 0x1,
	LV_TEXT_DECOR_STRIKETHROUGH = 0x2,
}

lv_border_side_t :: enum i32 {
	LV_BORDER_SIDE_NONE = 0x00,
	LV_BORDER_SIDE_BOTTOM = 0x01,
	LV_BORDER_SIDE_TOP = 0x02,
	LV_BORDER_SIDE_LEFT = 0x04,
	LV_BORDER_SIDE_RIGHT = 0x08,
	LV_BORDER_SIDE_FULL = 0x0F,
	/* FOR matrix-like objects (e.g. Button matrix)  */
	LV_BORDER_SIDE_INTERNAL = 0x10,
}

lv_blur_quality_t :: enum i32 {
	/* Set the quality automatically  */
	LV_BLUR_QUALITY_AUTO = 0x0,
	/* Prefer speed over precision  */
	LV_BLUR_QUALITY_SPEED = 0x1,
	/* Prefer precision over speed  */
	LV_BLUR_QUALITY_PRECISION = 0x2,
}

/* Enumeration of all built in style properties 

Props are split into groups of 16. When adding a new prop to a group, ensure it does not overflow into the next one.   */
_lv_style_id_t :: enum i32 {
	LV_STYLE_PROP_INV = 0x000,
	LV_STYLE_WIDTH = 0x001,
	LV_STYLE_HEIGHT = 0x002,
	LV_STYLE_LENGTH = 0x003,
	LV_STYLE_MIN_WIDTH = 0x004,
	LV_STYLE_MAX_WIDTH = 0x005,
	LV_STYLE_MIN_HEIGHT = 0x006,
	LV_STYLE_MAX_HEIGHT = 0x007,
	LV_STYLE_X = 0x008,
	LV_STYLE_Y = 0x009,
	LV_STYLE_ALIGN = 0x00A,
	LV_STYLE_RADIUS = 0x00C,
	LV_STYLE_RADIAL_OFFSET = 0x00D,
	LV_STYLE_PAD_RADIAL = 0x00E,
	LV_STYLE_PAD_TOP = 0x010,
	LV_STYLE_PAD_BOTTOM = 0x011,
	LV_STYLE_PAD_LEFT = 0x012,
	LV_STYLE_PAD_RIGHT = 0x013,
	LV_STYLE_PAD_ROW = 0x014,
	LV_STYLE_PAD_COLUMN = 0x015,
	LV_STYLE_LAYOUT = 0x016,
	LV_STYLE_MARGIN_TOP = 0x018,
	LV_STYLE_MARGIN_BOTTOM = 0x019,
	LV_STYLE_MARGIN_LEFT = 0x01A,
	LV_STYLE_MARGIN_RIGHT = 0x01B,
	LV_STYLE_BG_COLOR = 0x01C,
	LV_STYLE_BG_OPA = 0x01D,
	LV_STYLE_BG_GRAD_DIR = 0x020,
	LV_STYLE_BG_MAIN_STOP = 0x021,
	LV_STYLE_BG_GRAD_STOP = 0x022,
	LV_STYLE_BG_GRAD_COLOR = 0x023,
	LV_STYLE_BG_MAIN_OPA = 0x024,
	LV_STYLE_BG_GRAD_OPA = 0x025,
	LV_STYLE_BG_GRAD = 0x026,
	LV_STYLE_BASE_DIR = 0x027,
	LV_STYLE_BG_IMAGE_SRC = 0x028,
	LV_STYLE_BG_IMAGE_OPA = 0x029,
	LV_STYLE_BG_IMAGE_RECOLOR = 0x02A,
	LV_STYLE_BG_IMAGE_RECOLOR_OPA = 0x02B,
	LV_STYLE_BG_IMAGE_TILED = 0x02C,
	LV_STYLE_CLIP_CORNER = 0x02D,
	LV_STYLE_BORDER_WIDTH = 0x030,
	LV_STYLE_BORDER_COLOR = 0x031,
	LV_STYLE_BORDER_OPA = 0x032,
	LV_STYLE_BORDER_SIDE = 0x034,
	LV_STYLE_BORDER_POST = 0x035,
	LV_STYLE_OUTLINE_WIDTH = 0x038,
	LV_STYLE_OUTLINE_COLOR = 0x039,
	LV_STYLE_OUTLINE_OPA = 0x03A,
	LV_STYLE_OUTLINE_PAD = 0x03B,
	LV_STYLE_SHADOW_WIDTH = 0x03C,
	LV_STYLE_SHADOW_COLOR = 0x03D,
	LV_STYLE_SHADOW_OPA = 0x03E,
	LV_STYLE_SHADOW_OFFSET_X = 0x040,
	LV_STYLE_SHADOW_OFFSET_Y = 0x041,
	LV_STYLE_SHADOW_SPREAD = 0x042,
	LV_STYLE_IMAGE_OPA = 0x044,
	LV_STYLE_IMAGE_RECOLOR = 0x045,
	LV_STYLE_IMAGE_RECOLOR_OPA = 0x046,
	LV_STYLE_LINE_WIDTH = 0x048,
	LV_STYLE_LINE_DASH_WIDTH = 0x049,
	LV_STYLE_LINE_DASH_GAP = 0x04A,
	LV_STYLE_LINE_ROUNDED = 0x04B,
	LV_STYLE_LINE_COLOR = 0x04C,
	LV_STYLE_LINE_OPA = 0x04D,
	LV_STYLE_ARC_WIDTH = 0x050,
	LV_STYLE_ARC_ROUNDED = 0x051,
	LV_STYLE_ARC_COLOR = 0x052,
	LV_STYLE_ARC_OPA = 0x053,
	LV_STYLE_ARC_IMAGE_SRC = 0x054,
	LV_STYLE_TEXT_COLOR = 0x058,
	LV_STYLE_TEXT_OPA = 0x059,
	LV_STYLE_TEXT_FONT = 0x05A,
	LV_STYLE_TEXT_LETTER_SPACE = 0x05B,
	LV_STYLE_TEXT_LINE_SPACE = 0x05C,
	LV_STYLE_TEXT_DECOR = 0x05D,
	LV_STYLE_TEXT_ALIGN = 0x05E,
	LV_STYLE_TEXT_OUTLINE_STROKE_WIDTH = 0x05F,
	LV_STYLE_TEXT_OUTLINE_STROKE_OPA = 0x060,
	LV_STYLE_TEXT_OUTLINE_STROKE_COLOR = 0x061,
	LV_STYLE_OPA = 0x062,
	LV_STYLE_OPA_LAYERED = 0x063,
	LV_STYLE_COLOR_FILTER_DSC = 0x064,
	LV_STYLE_COLOR_FILTER_OPA = 0x065,
	LV_STYLE_ANIM = 0x066,
	LV_STYLE_ANIM_DURATION = 0x067,
	LV_STYLE_TRANSITION = 0x068,
	LV_STYLE_BLEND_MODE = 0x069,
	LV_STYLE_TRANSFORM_WIDTH = 0x06A,
	LV_STYLE_TRANSFORM_HEIGHT = 0x06B,
	LV_STYLE_TRANSLATE_X = 0x06C,
	LV_STYLE_TRANSLATE_Y = 0x06D,
	LV_STYLE_TRANSFORM_SCALE_X = 0x06E,
	LV_STYLE_TRANSFORM_SCALE_Y = 0x06F,
	LV_STYLE_TRANSFORM_ROTATION = 0x070,
	LV_STYLE_TRANSFORM_PIVOT_X = 0x071,
	LV_STYLE_TRANSFORM_PIVOT_Y = 0x072,
	LV_STYLE_TRANSFORM_SKEW_X = 0x073,
	LV_STYLE_TRANSFORM_SKEW_Y = 0x074,
	LV_STYLE_BITMAP_MASK_SRC = 0x075,
	LV_STYLE_ROTARY_SENSITIVITY = 0x076,
	LV_STYLE_TRANSLATE_RADIAL = 0x077,
	LV_STYLE_RECOLOR = 0x078,
	LV_STYLE_RECOLOR_OPA = 0x079,
	LV_STYLE_FLEX_FLOW = 0x07A,
	LV_STYLE_FLEX_MAIN_PLACE = 0x07B,
	LV_STYLE_FLEX_CROSS_PLACE = 0x07C,
	LV_STYLE_FLEX_TRACK_PLACE = 0x07D,
	LV_STYLE_FLEX_GROW = 0x07E,
	LV_STYLE_GRID_COLUMN_ALIGN = 0x07F,
	LV_STYLE_GRID_ROW_ALIGN = 0x080,
	LV_STYLE_GRID_ROW_DSC_ARRAY = 0x081,
	LV_STYLE_GRID_COLUMN_DSC_ARRAY = 0x082,
	LV_STYLE_GRID_CELL_COLUMN_POS = 0x083,
	LV_STYLE_GRID_CELL_COLUMN_SPAN = 0x084,
	LV_STYLE_GRID_CELL_X_ALIGN = 0x085,
	LV_STYLE_GRID_CELL_ROW_POS = 0x086,
	LV_STYLE_GRID_CELL_ROW_SPAN = 0x087,
	LV_STYLE_GRID_CELL_Y_ALIGN = 0x088,
	LV_STYLE_IMAGE_COLORKEY = 0x089,
	LV_STYLE_BLUR_RADIUS = 0x08A,
	LV_STYLE_BLUR_BACKDROP = 0x08B,
	LV_STYLE_BLUR_QUALITY = 0x08C,
	LV_STYLE_LAST_BUILT_IN_PROP = 0x08D,
	LV_STYLE_NUM_BUILT_IN_PROPS = 0x08E,
	LV_STYLE_PROP_ANY = 0x0FF,
	LV_STYLE_PROP_CONST = 0x0FF,
}

lv_style_res_t :: enum i32 {
	LV_STYLE_RES_NOT_FOUND = 0x0,
	LV_STYLE_RES_FOUND = 0x1,
}

lv_event_code_t :: enum i32 {
	LV_EVENT_ALL = 0x00000,
	/* Input device events Widget has been pressed  */
	LV_EVENT_PRESSED = 0x00001,
	/* Widget is being pressed (sent continuously while pressing)  */
	LV_EVENT_PRESSING = 0x00002,
	/* Widget is still being pressed but slid cursor/finger off Widget  */
	LV_EVENT_PRESS_LOST = 0x00003,
	/* Widget was pressed for a short period of time, then released. Not sent if scrolled.  */
	LV_EVENT_SHORT_CLICKED = 0x00004,
	/* Sent for first short click within a small distance and short time  */
	LV_EVENT_SINGLE_CLICKED = 0x00005,
	/* Sent for second short click within small distance and short time  */
	LV_EVENT_DOUBLE_CLICKED = 0x00006,
	/* Sent for third short click within small distance and short time  */
	LV_EVENT_TRIPLE_CLICKED = 0x00007,
	/* Object has been pressed for at least long_press_time . Not sent if scrolled.  */
	LV_EVENT_LONG_PRESSED = 0x00008,
	/* Sent after long_press_time in every long_press_repeat_time ms. Not sent if scrolled.  */
	LV_EVENT_LONG_PRESSED_REPEAT = 0x00009,
	/* Sent on release if not scrolled (regardless to long press)  */
	LV_EVENT_CLICKED = 0x0000A,
	/* Sent in every cases when Widget has been released  */
	LV_EVENT_RELEASED = 0x0000B,
	/* Scrolling begins. The event parameter is a pointer to the animation of the scroll. Can be modified  */
	LV_EVENT_SCROLL_BEGIN = 0x0000C,
	LV_EVENT_SCROLL_THROW_BEGIN = 0x0000D,
	/* Scrolling ends  */
	LV_EVENT_SCROLL_END = 0x0000E,
	/* Scrolling  */
	LV_EVENT_SCROLL = 0x0000F,
	/* A gesture is detected. Get gesture with lv_indev_get_gesture_dir(lv_indev_active());  */
	LV_EVENT_GESTURE = 0x00010,
	/* A key is sent to Widget. Get key with lv_indev_get_key(lv_indev_active());  */
	LV_EVENT_KEY = 0x00011,
	/* An encoder or wheel was rotated. Get rotation count with lv_event_get_rotary_diff(e);  */
	LV_EVENT_ROTARY = 0x00012,
	/* Widget received focus  */
	LV_EVENT_FOCUSED = 0x00013,
	/* Widget's focus has been lost  */
	LV_EVENT_DEFOCUSED = 0x00014,
	/* Widget's focus has been lost but is still selected  */
	LV_EVENT_LEAVE = 0x00015,
	/* Perform advanced hit-testing  */
	LV_EVENT_HIT_TEST = 0x00016,
	/* Indev has been reset  */
	LV_EVENT_INDEV_RESET = 0x00017,
	/* Indev hover over object  */
	LV_EVENT_HOVER_OVER = 0x00018,
	/* Indev hover leave object  */
	LV_EVENT_HOVER_LEAVE = 0x00019,
	/* Drawing events Check if Widget fully covers an area. The event parameter is lv_cover_check_info_t * .  */
	LV_EVENT_COVER_CHECK = 0x0001A,
	/* Get required extra draw area around Widget (e.g. for shadow). The event parameter is int32_t * to store the size.  */
	LV_EVENT_REFR_EXT_DRAW_SIZE = 0x0001B,
	/* Starting the main drawing phase  */
	LV_EVENT_DRAW_MAIN_BEGIN = 0x0001C,
	/* Perform the main drawing  */
	LV_EVENT_DRAW_MAIN = 0x0001D,
	/* Finishing the main drawing phase  */
	LV_EVENT_DRAW_MAIN_END = 0x0001E,
	/* Starting the post draw phase (when all children are drawn)  */
	LV_EVENT_DRAW_POST_BEGIN = 0x0001F,
	/* Perform the post draw phase (when all children are drawn)  */
	LV_EVENT_DRAW_POST = 0x00020,
	/* Finishing the post draw phase (when all children are drawn)  */
	LV_EVENT_DRAW_POST_END = 0x00021,
	/* Adding a draw task. The LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS flag needs to be set  */
	LV_EVENT_DRAW_TASK_ADDED = 0x00022,
	/* Special events Widget's value has changed (i.e. slider moved)  */
	LV_EVENT_VALUE_CHANGED = 0x00023,
	/* Text has been inserted into Widget. The event data is char * being inserted.  */
	LV_EVENT_INSERT = 0x00024,
	/* Notify Widget to refresh something on it (for user)  */
	LV_EVENT_REFRESH = 0x00025,
	/* A process has finished  */
	LV_EVENT_READY = 0x00026,
	/* A process has been cancelled  */
	LV_EVENT_CANCEL = 0x00027,
	/* The state of the widget changed  */
	LV_EVENT_STATE_CHANGED = 0x00028,
	/* Other events Object is being created  */
	LV_EVENT_CREATE = 0x00029,
	/* Object is being deleted  */
	LV_EVENT_DELETE = 0x0002A,
	/* Child was removed, added, or its size, position were changed  */
	LV_EVENT_CHILD_CHANGED = 0x0002B,
	/* Child was created, always bubbles up to all parents  */
	LV_EVENT_CHILD_CREATED = 0x0002C,
	/* Child was deleted, always bubbles up to all parents  */
	LV_EVENT_CHILD_DELETED = 0x0002D,
	/* A screen unload started, fired immediately when scr_load is called  */
	LV_EVENT_SCREEN_UNLOAD_START = 0x0002E,
	/* A screen load started, fired when the screen change delay is expired  */
	LV_EVENT_SCREEN_LOAD_START = 0x0002F,
	/* A screen was loaded  */
	LV_EVENT_SCREEN_LOADED = 0x00030,
	/* A screen was unloaded  */
	LV_EVENT_SCREEN_UNLOADED = 0x00031,
	/* Object coordinates/size have changed  */
	LV_EVENT_SIZE_CHANGED = 0x00032,
	/* Object's style has changed  */
	LV_EVENT_STYLE_CHANGED = 0x00033,
	/* A child's position position has changed due to a layout recalculation  */
	LV_EVENT_LAYOUT_CHANGED = 0x00034,
	/* Get internal size of a widget  */
	LV_EVENT_GET_SELF_SIZE = 0x00035,
	/* Events of optional LVGL components An area is invalidated (marked for redraw). lv_event_get_param(e) returns a pointer to an :ref:`lv_area_t` object with the coordinates of the area to be invalidated. The area can be freely modified if needed to adapt it a special requirement of the display. Usually needed with monochrome displays to invalidate N x 8 rows or columns in one pass.  */
	LV_EVENT_INVALIDATE_AREA = 0x00036,
	/* Sent when the resolution changes due to :ref:`lv_display_set_resolution()` or :ref:`lv_display_set_rotation()` .  */
	LV_EVENT_RESOLUTION_CHANGED = 0x00037,
	/* Sent as a result of any call to :ref:`lv_display_set_color_format()` .  */
	LV_EVENT_COLOR_FORMAT_CHANGED = 0x00038,
	/* Sent when something happened that requires redraw.  */
	LV_EVENT_REFR_REQUEST = 0x00039,
	/* Sent before a refreshing cycle starts. Sent even if there is nothing to redraw.  */
	LV_EVENT_REFR_START = 0x0003A,
	/* Sent when refreshing has been completed (after rendering and calling flush callback). Sent even if no redraw happened.  */
	LV_EVENT_REFR_READY = 0x0003B,
	/* Sent just before rendering begins.  */
	LV_EVENT_RENDER_START = 0x0003C,
	/* Sent after rendering has been completed.  */
	LV_EVENT_RENDER_READY = 0x0003D,
	/* Sent before flush callback is called.  */
	LV_EVENT_FLUSH_START = 0x0003E,
	/* Sent after flush callback call has returned.  */
	LV_EVENT_FLUSH_FINISH = 0x0003F,
	/* Sent before flush wait callback is called.  */
	LV_EVENT_FLUSH_WAIT_START = 0x00040,
	/* Sent after flush wait callback call has returned.  */
	LV_EVENT_FLUSH_WAIT_FINISH = 0x00041,
	/* Sent after layout update completes  */
	LV_EVENT_UPDATE_LAYOUT_COMPLETED = 0x00042,
	LV_EVENT_VSYNC = 0x00043,
	LV_EVENT_VSYNC_REQUEST = 0x00044,
	LV_EVENT_LAST = 0x00045,
	/* Number of default events  */
	LV_EVENT_PREPROCESS = 0x08000,
	/* This is a flag that can be set with an event so it's processed before the class default event processing  */
	LV_EVENT_MARKED_DELETING = 0x10000,
}

lv_display_rotation_t :: enum i32 {
	LV_DISPLAY_ROTATION_0 = 0x0,
	LV_DISPLAY_ROTATION_90 = 0x1,
	LV_DISPLAY_ROTATION_180 = 0x2,
	LV_DISPLAY_ROTATION_270 = 0x3,
}

lv_display_render_mode_t :: enum i32 {
	/* Use the buffer(s) to render the screen is smaller parts. This way the buffers can be smaller then the display to save RAM. At least 1/10 screen size buffer(s) are recommended.  */
	LV_DISPLAY_RENDER_MODE_PARTIAL = 0x0,
	/* The buffer(s) has to be screen sized and LVGL will render into the correct location of the buffer. This way the buffer always contain the whole image. Only the changed ares will be updated. With 2 buffers the buffers' content are kept in sync automatically and in flush_cb only address change is required.  */
	LV_DISPLAY_RENDER_MODE_DIRECT = 0x1,
	/* Always redraw the whole screen even if only one pixel has been changed. With 2 buffers in flush_cb only an address change is required.  */
	LV_DISPLAY_RENDER_MODE_FULL = 0x2,
}

lv_screen_load_anim_t :: enum i32 {
	LV_SCREEN_LOAD_ANIM_NONE = 0x0,
	LV_SCREEN_LOAD_ANIM_OVER_LEFT = 0x1,
	LV_SCREEN_LOAD_ANIM_OVER_RIGHT = 0x2,
	LV_SCREEN_LOAD_ANIM_OVER_TOP = 0x3,
	LV_SCREEN_LOAD_ANIM_OVER_BOTTOM = 0x4,
	LV_SCREEN_LOAD_ANIM_MOVE_LEFT = 0x5,
	LV_SCREEN_LOAD_ANIM_MOVE_RIGHT = 0x6,
	LV_SCREEN_LOAD_ANIM_MOVE_TOP = 0x7,
	LV_SCREEN_LOAD_ANIM_MOVE_BOTTOM = 0x8,
	LV_SCREEN_LOAD_ANIM_FADE_IN = 0x9,
	LV_SCREEN_LOAD_ANIM_FADE_ON = 0x9,
	LV_SCREEN_LOAD_ANIM_FADE_OUT = 0xA,
	LV_SCREEN_LOAD_ANIM_OUT_LEFT = 0xB,
	LV_SCREEN_LOAD_ANIM_OUT_RIGHT = 0xC,
	LV_SCREEN_LOAD_ANIM_OUT_TOP = 0xD,
	LV_SCREEN_LOAD_ANIM_OUT_BOTTOM = 0xE,
}

lv_obj_tree_walk_res_t :: enum i32 {
	LV_OBJ_TREE_WALK_NEXT = 0x0,
	LV_OBJ_TREE_WALK_SKIP_CHILDREN = 0x1,
	LV_OBJ_TREE_WALK_END = 0x2,
}

lv_obj_point_transform_flag_t :: enum i32 {
	/* No flags  */
	LV_OBJ_POINT_TRANSFORM_FLAG_NONE = 0x0,
	/* Consider the transformation properties of the parents too  */
	LV_OBJ_POINT_TRANSFORM_FLAG_RECURSIVE = 0x1,
	/* Execute the inverse of the transformation (-angle and 1/zoom)  */
	LV_OBJ_POINT_TRANSFORM_FLAG_INVERSE = 0x2,
	/* Both inverse and recursive  */
	LV_OBJ_POINT_TRANSFORM_FLAG_INVERSE_RECURSIVE = 0x3,
}

lv_scrollbar_mode_t :: enum i32 {
	/* Never show scrollbars  */
	LV_SCROLLBAR_MODE_OFF = 0x0,
	/* Always show scrollbars  */
	LV_SCROLLBAR_MODE_ON = 0x1,
	/* Show scroll bars when Widget is being scrolled  */
	LV_SCROLLBAR_MODE_ACTIVE = 0x2,
	/* Show scroll bars when the content is large enough to be scrolled  */
	LV_SCROLLBAR_MODE_AUTO = 0x3,
}

lv_scroll_snap_t :: enum i32 {
	/* Do not align, leave where it is  */
	LV_SCROLL_SNAP_NONE = 0x0,
	/* Align to the left/top  */
	LV_SCROLL_SNAP_START = 0x1,
	/* Align to the right/bottom  */
	LV_SCROLL_SNAP_END = 0x2,
	/* Align to the center  */
	LV_SCROLL_SNAP_CENTER = 0x3,
}

lv_state_t :: enum i32 {
	LV_STATE_DEFAULT = 0x00000,
	LV_STATE_CHECKED = 0x00001,
	LV_STATE_FOCUSED = 0x00002,
	LV_STATE_FOCUS_KEY = 0x00004,
	LV_STATE_EDITED = 0x00008,
	LV_STATE_HOVERED = 0x00010,
	LV_STATE_PRESSED = 0x00020,
	LV_STATE_SCROLLED = 0x00040,
	LV_STATE_DISABLED = 0x00080,
	LV_STATE_USER_1 = 0x01000,
	LV_STATE_USER_2 = 0x02000,
	LV_STATE_USER_3 = 0x04000,
	LV_STATE_USER_4 = 0x08000,
	/* Special value can be used in some functions to target all states  */
	LV_STATE_ANY = 0x0FFFF,
}

lv_part_t :: enum i32 {
	/* A background like rectangle  */
	LV_PART_MAIN = 0x00000,
	/* The scrollbar(s)  */
	LV_PART_SCROLLBAR = 0x10000,
	/* Indicator, e.g. for slider, bar, switch, or the tick box of the checkbox  */
	LV_PART_INDICATOR = 0x20000,
	/* Like handle to grab to adjust the value  */
	LV_PART_KNOB = 0x30000,
	/* Indicate the currently selected option or section  */
	LV_PART_SELECTED = 0x40000,
	/* Used if the widget has multiple similar elements (e.g. table cells)  */
	LV_PART_ITEMS = 0x50000,
	/* Mark a specific place e.g. for text area's cursor or on a chart  */
	LV_PART_CURSOR = 0x60000,
	/* Extension point for custom widgets  */
	LV_PART_CUSTOM_FIRST = 0x80000,
	/* Special value can be used in some functions to target all parts  */
	LV_PART_ANY = 0xF0000,
}

lv_style_state_cmp_t :: enum i32 {
	/* The style properties in the 2 states are identical  */
	LV_STYLE_STATE_CMP_SAME = 0x0,
	/* The differences can be shown with a simple redraw  */
	LV_STYLE_STATE_CMP_DIFF_REDRAW = 0x1,
	/* The differences can be shown with a simple redraw  */
	LV_STYLE_STATE_CMP_DIFF_DRAW_PAD = 0x2,
	/* The differences can be shown with a simple redraw  */
	LV_STYLE_STATE_CMP_DIFF_LAYOUT = 0x3,
}

lv_fs_res_t :: enum i32 {
	LV_FS_RES_OK = 0x0,
	LV_FS_RES_HW_ERR = 0x1,
	LV_FS_RES_FS_ERR = 0x2,
	LV_FS_RES_NOT_EX = 0x3,
	LV_FS_RES_FULL = 0x4,
	LV_FS_RES_LOCKED = 0x5,
	LV_FS_RES_DENIED = 0x6,
	LV_FS_RES_BUSY = 0x7,
	LV_FS_RES_TOUT = 0x8,
	LV_FS_RES_NOT_IMP = 0x9,
	LV_FS_RES_OUT_OF_MEM = 0xA,
	LV_FS_RES_INV_PARAM = 0xB,
	LV_FS_RES_DRIVE_LETTER_ALREADY_USED = 0xC,
	LV_FS_RES_UNKNOWN = 0xD,
}

lv_fs_mode_t :: enum i32 {
	LV_FS_MODE_WR = 0x1,
	LV_FS_MODE_RD = 0x2,
}

lv_fs_whence_t :: enum i32 {
	/* Set the position from absolutely (from the start of file)  */
	LV_FS_SEEK_SET = 0x0,
	/* Set the position from the current position  */
	LV_FS_SEEK_CUR = 0x1,
	/* Set the position from the end of the file  */
	LV_FS_SEEK_END = 0x2,
}

lv_image_src_t :: enum i32 {
	LV_IMAGE_SRC_VARIABLE = 0x0,
	/* Binary/C variable  */
	LV_IMAGE_SRC_FILE = 0x1,
	/* File in filesystem  */
	LV_IMAGE_SRC_SYMBOL = 0x2,
	/* Symbol ( :ref:`lv_symbol_def.h` )  */
	LV_IMAGE_SRC_UNKNOWN = 0x3,
}

lv_draw_task_type_t :: enum i32 {
	LV_DRAW_TASK_TYPE_NONE = 0x0,
	LV_DRAW_TASK_TYPE_FILL = 0x1,
	LV_DRAW_TASK_TYPE_BORDER = 0x2,
	LV_DRAW_TASK_TYPE_BOX_SHADOW = 0x3,
	LV_DRAW_TASK_TYPE_LETTER = 0x4,
	LV_DRAW_TASK_TYPE_LABEL = 0x5,
	LV_DRAW_TASK_TYPE_IMAGE = 0x6,
	LV_DRAW_TASK_TYPE_LAYER = 0x7,
	LV_DRAW_TASK_TYPE_LINE = 0x8,
	LV_DRAW_TASK_TYPE_ARC = 0x9,
	LV_DRAW_TASK_TYPE_TRIANGLE = 0xA,
	LV_DRAW_TASK_TYPE_MASK_RECTANGLE = 0xB,
	LV_DRAW_TASK_TYPE_MASK_BITMAP = 0xC,
	LV_DRAW_TASK_TYPE_BLUR = 0xD,
}

lv_draw_task_state_t :: enum i32 {
	/* Waiting for an other task to be finished. For example in case of LV_DRAW_TASK_TYPE_LAYER (used to blend a layer) is blocked until all the draw tasks of the layer is rendered.  */
	LV_DRAW_TASK_STATE_BLOCKED = 0x0,
	/* The draw task is added to the layers list and waits to be rendered.  */
	LV_DRAW_TASK_STATE_WAITING = 0x1,
	/* The draw task is added to the command queue of the draw unit. As the queued task are executed in order it's possible to queue multiple draw task (for the same draw unit) even if they are depending on each other. Therefore lv_draw_get_available_task and lv_draw_get_next_available_task can return draw task for the same draw unit even if a dependent draw task is not finished ready yet.  */
	LV_DRAW_TASK_STATE_QUEUED = 0x2,
	/* The draw task is being rendered. This draw task needs to be finished before lv_draw_get_available_task and lv_draw_get_next_available_task would return any depending draw tasks.  */
	LV_DRAW_TASK_STATE_IN_PROGRESS = 0x3,
	/* The draw task is rendered. It will be removed from the draw task list of the layer and freed automatically.  */
	LV_DRAW_TASK_STATE_FINISHED = 0x4,
}

lv_layer_type_t :: enum i32 {
	/* No layer is needed.  */
	LV_LAYER_TYPE_NONE = 0x0,
	/* Simple layer means that the layer can be rendered in chunks. For example with opa_layered = 140 it's possible to render only 10 lines from the layer. When it's ready go to the next 10 lines. It avoids large memory allocations for the layer buffer. The buffer size for a chunk can be set by LV_DRAW_LAYER_SIMPLE_BUF_SIZE in lv_conf.h.  */
	LV_LAYER_TYPE_SIMPLE = 0x1,
	/* The widget is transformed and cannot be rendered in chunks. It's because - due to the transformations - pixel outside of a given area will also contribute to the final image. In this case there is no limitation on the buffer size. LVGL will allocate as large buffer as needed to render the transformed area.  */
	LV_LAYER_TYPE_TRANSFORM = 0x2,
}

lv_obj_class_editable_t :: enum i32 {
	/* Check the base class. Must have 0 value to let zero initialized class inherit  */
	LV_OBJ_CLASS_EDITABLE_INHERIT = 0x0,
	LV_OBJ_CLASS_EDITABLE_TRUE = 0x1,
	LV_OBJ_CLASS_EDITABLE_FALSE = 0x2,
}

lv_obj_class_group_def_t :: enum i32 {
	/* Check the base class. Must have 0 value to let zero initialized class inherit  */
	LV_OBJ_CLASS_GROUP_DEF_INHERIT = 0x0,
	LV_OBJ_CLASS_GROUP_DEF_TRUE = 0x1,
	LV_OBJ_CLASS_GROUP_DEF_FALSE = 0x2,
}

lv_obj_class_theme_inheritable_t :: enum i32 {
	/* Do not inherit theme from base class.  */
	LV_OBJ_CLASS_THEME_INHERITABLE_FALSE = 0x0,
	LV_OBJ_CLASS_THEME_INHERITABLE_TRUE = 0x1,
}

lv_key_t :: enum i32 {
	LV_KEY_UP = 0x11,
	LV_KEY_DOWN = 0x12,
	LV_KEY_RIGHT = 0x13,
	LV_KEY_LEFT = 0x14,
	LV_KEY_ESC = 0x1B,
	LV_KEY_DEL = 0x7F,
	LV_KEY_BACKSPACE = 0x8,
	LV_KEY_ENTER = 0xA,
	LV_KEY_NEXT = 0x9,
	LV_KEY_PREV = 0xB,
	LV_KEY_HOME = 0x2,
	LV_KEY_END = 0x3,
}

lv_group_refocus_policy_t :: enum i32 {
	LV_GROUP_REFOCUS_POLICY_NEXT = 0x0,
	LV_GROUP_REFOCUS_POLICY_PREV = 0x1,
}

lv_indev_type_t :: enum i32 {
	/* Uninitialized state  */
	LV_INDEV_TYPE_NONE = 0x0,
	/* Touch pad, mouse, external button  */
	LV_INDEV_TYPE_POINTER = 0x1,
	/* Keypad or keyboard  */
	LV_INDEV_TYPE_KEYPAD = 0x2,
	/* External (hardware button) which is assigned to a specific point of the screen  */
	LV_INDEV_TYPE_BUTTON = 0x3,
	/* Encoder with only Left, Right turn and a Button  */
	LV_INDEV_TYPE_ENCODER = 0x4,
}

lv_indev_state_t :: enum i32 {
	LV_INDEV_STATE_RELEASED = 0x0,
	LV_INDEV_STATE_PRESSED = 0x1,
}

lv_indev_mode_t :: enum i32 {
	LV_INDEV_MODE_NONE = 0x0,
	LV_INDEV_MODE_TIMER = 0x1,
	LV_INDEV_MODE_EVENT = 0x2,
}

lv_indev_gesture_type_t :: enum i32 {
	LV_INDEV_GESTURE_NONE = 0x0,
	LV_INDEV_GESTURE_PINCH = 0x1,
	LV_INDEV_GESTURE_SWIPE = 0x2,
	LV_INDEV_GESTURE_ROTATE = 0x3,
	LV_INDEV_GESTURE_TWO_FINGERS_SWIPE = 0x4,
	LV_INDEV_GESTURE_SCROLL = 0x5,
	LV_INDEV_GESTURE_CNT = 0x6,
}

lv_cover_res_t :: enum i32 {
	LV_COVER_RES_COVER = 0x0,
	LV_COVER_RES_NOT_COVER = 0x1,
	LV_COVER_RES_MASKED = 0x2,
}

lv_obj_flag_t :: enum i32 {
	/* Make the object hidden. (Like it wasn't there at all)  */
	LV_OBJ_FLAG_HIDDEN = 0x00,
	/* Make the object clickable by the input devices  */
	LV_OBJ_FLAG_CLICKABLE = 0x01,
	/* Add focused state to the object when clicked  */
	LV_OBJ_FLAG_CLICK_FOCUSABLE = 0x02,
	/* Toggle checked state when the object is clicked  */
	LV_OBJ_FLAG_CHECKABLE = 0x03,
	/* Make the object scrollable  */
	LV_OBJ_FLAG_SCROLLABLE = 0x04,
	/* Allow scrolling inside but with slower speed  */
	LV_OBJ_FLAG_SCROLL_ELASTIC = 0x05,
	/* Make the object scroll further when "thrown"  */
	LV_OBJ_FLAG_SCROLL_MOMENTUM = 0x06,
	/* Allow scrolling only one snappable children  */
	LV_OBJ_FLAG_SCROLL_ONE = 0x07,
	/* Allow propagating the horizontal scroll to a parent  */
	LV_OBJ_FLAG_SCROLL_CHAIN_HOR = 0x08,
	/* Allow propagating the vertical scroll to a parent  */
	LV_OBJ_FLAG_SCROLL_CHAIN_VER = 0x09,
	LV_OBJ_FLAG_SCROLL_CHAIN = 0x09,
	/* Automatically scroll object to make it visible when focused  */
	LV_OBJ_FLAG_SCROLL_ON_FOCUS = 0x0A,
	/* Allow scrolling the focused object with arrow keys  */
	LV_OBJ_FLAG_SCROLL_WITH_ARROW = 0x0B,
	/* If scroll snap is enabled on the parent it can snap to this object  */
	LV_OBJ_FLAG_SNAPPABLE = 0x0C,
	/* Keep the object pressed even if the press slid from the object  */
	LV_OBJ_FLAG_PRESS_LOCK = 0x0D,
	/* Propagate the events to the parent too  */
	LV_OBJ_FLAG_EVENT_BUBBLE = 0x0E,
	/* Propagate the gestures to the parent  */
	LV_OBJ_FLAG_GESTURE_BUBBLE = 0x0F,
	/* Allow performing more accurate hit (click) test. E.g. consider rounded corners.  */
	LV_OBJ_FLAG_ADV_HITTEST = 0x10,
	/* Make the object not positioned by the layouts  */
	LV_OBJ_FLAG_IGNORE_LAYOUT = 0x11,
	/* Do not scroll the object when the parent scrolls and ignore layout  */
	LV_OBJ_FLAG_FLOATING = 0x12,
	/* Send LV_EVENT_DRAW_TASK_ADDED events  */
	LV_OBJ_FLAG_SEND_DRAW_TASK_EVENTS = 0x13,
	/* Do not clip the children to the parent's ext draw size  */
	LV_OBJ_FLAG_OVERFLOW_VISIBLE = 0x14,
	/* Propagate the events to the children too  */
	LV_OBJ_FLAG_EVENT_TRICKLE = 0x15,
	/* Propagate the states to the children too  */
	LV_OBJ_FLAG_STATE_TRICKLE = 0x16,
	/* Allow only one RADIO_BUTTON sibling to be checked  */
	LV_OBJ_FLAG_RADIO_BUTTON = 0x17,
	/* Custom flag, free to use by layouts  */
	LV_OBJ_FLAG_LAYOUT_1 = 0x18,
	/* Custom flag, free to use by layouts  */
	LV_OBJ_FLAG_LAYOUT_2 = 0x19,
	/* Start a new flex track on this item  */
	LV_OBJ_FLAG_FLEX_IN_NEW_TRACK = 0x18,
	/* Custom flag, free to use by widget  */
	LV_OBJ_FLAG_WIDGET_1 = 0x19,
	/* Custom flag, free to use by widget  */
	LV_OBJ_FLAG_WIDGET_2 = 0x1A,
	/* Custom flag, free to use by user  */
	LV_OBJ_FLAG_USER_1 = 0x1B,
	/* Custom flag, free to use by user  */
	LV_OBJ_FLAG_USER_2 = 0x1C,
}

lv_subject_type_t :: enum i32 {
	/* indicates Subject not initialized yet  */
	LV_SUBJECT_TYPE_INVALID = 0x0,
	/* a null value like None or NILt  */
	LV_SUBJECT_TYPE_NONE = 0x1,
	/* an int32_t  */
	LV_SUBJECT_TYPE_INT = 0x2,
	/* a float, requires LV_USE_FLOAT 1  */
	LV_SUBJECT_TYPE_FLOAT = 0x3,
	/* a void pointer  */
	LV_SUBJECT_TYPE_POINTER = 0x4,
	/* an :ref:`lv_color_t`  */
	LV_SUBJECT_TYPE_COLOR = 0x5,
	/* an array of Subjects  */
	LV_SUBJECT_TYPE_GROUP = 0x6,
	/* a char pointer  */
	LV_SUBJECT_TYPE_STRING = 0x7,
}

lv_gridnav_ctrl_t :: enum i32 {
	LV_GRIDNAV_CTRL_NONE = 0x0,
	/* If there is no next/previous object in a direction, the focus goes to the object in the next/previous row (on left/right keys) or first/last row (on up/down keys)  */
	LV_GRIDNAV_CTRL_ROLLOVER = 0x1,
	/* If an arrow is pressed and the focused object can be scrolled in that direction then it will be scrolled instead of going to the next/previous object. If there is no more room for scrolling the next/previous object will be focused normally  */
	LV_GRIDNAV_CTRL_SCROLL_FIRST = 0x2,
	/* Only use left/right keys for grid navigation. Up/down key events will be sent to the focused object.  */
	LV_GRIDNAV_CTRL_HORIZONTAL_MOVE_ONLY = 0x4,
	/* Only use up/down keys for grid navigation. Left/right key events will be sent to the focused object.  */
	LV_GRIDNAV_CTRL_VERTICAL_MOVE_ONLY = 0x8,
}

lv_font_fmt_txt_cmap_type_t :: enum i32 {
	LV_FONT_FMT_TXT_CMAP_FORMAT0_FULL = 0x0,
	LV_FONT_FMT_TXT_CMAP_SPARSE_FULL = 0x1,
	LV_FONT_FMT_TXT_CMAP_FORMAT0_TINY = 0x2,
	LV_FONT_FMT_TXT_CMAP_SPARSE_TINY = 0x3,
}

lv_font_fmt_txt_bitmap_format_t :: enum i32 {
	LV_FONT_FMT_TXT_PLAIN = 0x0,
	LV_FONT_FMT_TXT_COMPRESSED = 0x1,
	LV_FONT_FMT_TXT_COMPRESSED_NO_PREFILTER = 0x2,
}

lv_image_align_t :: enum i32 {
	LV_IMAGE_ALIGN_DEFAULT = 0x0,
	LV_IMAGE_ALIGN_TOP_LEFT = 0x1,
	LV_IMAGE_ALIGN_TOP_MID = 0x2,
	LV_IMAGE_ALIGN_TOP_RIGHT = 0x3,
	LV_IMAGE_ALIGN_BOTTOM_LEFT = 0x4,
	LV_IMAGE_ALIGN_BOTTOM_MID = 0x5,
	LV_IMAGE_ALIGN_BOTTOM_RIGHT = 0x6,
	LV_IMAGE_ALIGN_LEFT_MID = 0x7,
	LV_IMAGE_ALIGN_RIGHT_MID = 0x8,
	LV_IMAGE_ALIGN_CENTER = 0x9,
	/* Marks the start of modes that transform the image  */
	_LV_IMAGE_ALIGN_AUTO_TRANSFORM = 0xA,
	/* Set X and Y scale to fill the Widget's area.  */
	LV_IMAGE_ALIGN_STRETCH = 0xB,
	/* Tile image to fill Widget's area. Offset is applied to shift the tiling.  */
	LV_IMAGE_ALIGN_TILE = 0xC,
	/* The image keeps its aspect ratio, but is resized to the maximum size that fits within the Widget's area.  */
	LV_IMAGE_ALIGN_CONTAIN = 0xD,
	/* The image keeps its aspect ratio and fills the Widget's area.  */
	LV_IMAGE_ALIGN_COVER = 0xE,
}

lv_animimg_part_t :: enum i32 {
	LV_ANIM_IMAGE_PART_MAIN = 0x0,
}

lv_arc_mode_t :: enum i32 {
	/* Clock-wise  */
	LV_ARC_MODE_NORMAL = 0x0,
	/* Left/right from the midpoint  */
	LV_ARC_MODE_SYMMETRICAL = 0x1,
	/* Counterclock-wise  */
	LV_ARC_MODE_REVERSE = 0x2,
}

lv_arclabel_dir_t :: enum i32 {
	LV_ARCLABEL_DIR_CLOCKWISE = 0x0,
	LV_ARCLABEL_DIR_COUNTER_CLOCKWISE = 0x1,
}

lv_arclabel_text_align_t :: enum i32 {
	LV_ARCLABEL_TEXT_ALIGN_DEFAULT = 0x0,
	LV_ARCLABEL_TEXT_ALIGN_LEADING = 0x1,
	LV_ARCLABEL_TEXT_ALIGN_CENTER = 0x2,
	LV_ARCLABEL_TEXT_ALIGN_TRAILING = 0x3,
}

lv_label_long_mode_t :: enum i32 {
	/* Keep the object width, wrap lines longer than object width and expand the object height  */
	LV_LABEL_LONG_MODE_WRAP = 0x0,
	/* Keep the size and write dots at the end if the text is too long  */
	LV_LABEL_LONG_MODE_DOTS = 0x1,
	/* Keep the size and roll the text back and forth  */
	LV_LABEL_LONG_MODE_SCROLL = 0x2,
	/* Keep the size and roll the text circularly  */
	LV_LABEL_LONG_MODE_SCROLL_CIRCULAR = 0x3,
	/* Keep the size and clip the text out of it  */
	LV_LABEL_LONG_MODE_CLIP = 0x4,
}

lv_bar_mode_t :: enum i32 {
	LV_BAR_MODE_NORMAL = 0x0,
	LV_BAR_MODE_SYMMETRICAL = 0x1,
	LV_BAR_MODE_RANGE = 0x2,
}

lv_bar_orientation_t :: enum i32 {
	LV_BAR_ORIENTATION_AUTO = 0x0,
	LV_BAR_ORIENTATION_HORIZONTAL = 0x1,
	LV_BAR_ORIENTATION_VERTICAL = 0x2,
}

lv_buttonmatrix_ctrl_t :: enum i32 {
	/* No extra control, use the default settings  */
	LV_BUTTONMATRIX_CTRL_NONE = 0x0000,
	/* Set the width to 1 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_1 = 0x0001,
	/* Set the width to 2 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_2 = 0x0002,
	/* Set the width to 3 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_3 = 0x0003,
	/* Set the width to 4 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_4 = 0x0004,
	/* Set the width to 5 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_5 = 0x0005,
	/* Set the width to 6 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_6 = 0x0006,
	/* Set the width to 7 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_7 = 0x0007,
	/* Set the width to 8 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_8 = 0x0008,
	/* Set the width to 9 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_9 = 0x0009,
	/* Set the width to 10 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_10 = 0x000A,
	/* Set the width to 11 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_11 = 0x000B,
	/* Set the width to 12 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_12 = 0x000C,
	/* Set the width to 13 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_13 = 0x000D,
	/* Set the width to 14 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_14 = 0x000E,
	/* Set the width to 15 relative to the other buttons in the same row  */
	LV_BUTTONMATRIX_CTRL_WIDTH_15 = 0x000F,
	/* Hides button; it continues to hold its space in layout.  */
	LV_BUTTONMATRIX_CTRL_HIDDEN = 0x0010,
	/* Do not emit LV_EVENT_LONG_PRESSED_REPEAT events while button is long-pressed.  */
	LV_BUTTONMATRIX_CTRL_NO_REPEAT = 0x0020,
	/* Disables button like LV_STATE_DISABLED on normal Widgets.  */
	LV_BUTTONMATRIX_CTRL_DISABLED = 0x0040,
	/* Enable toggling of LV_STATE_CHECKED when clicked.  */
	LV_BUTTONMATRIX_CTRL_CHECKABLE = 0x0080,
	/* Make the button checked. It will use the :cpp:enumerator: LV_STATE_CHECHKED styles.  */
	LV_BUTTONMATRIX_CTRL_CHECKED = 0x0100,
	/* 1: Enables sending LV_EVENT_VALUE_CHANGE on CLICK, 0: sends LV_EVENT_VALUE_CHANGE on PRESS.  */
	LV_BUTTONMATRIX_CTRL_CLICK_TRIG = 0x0200,
	/* Show button text in a pop-over while being pressed.  */
	LV_BUTTONMATRIX_CTRL_POPOVER = 0x0400,
	/* Enable text recoloring with #color  */
	LV_BUTTONMATRIX_CTRL_RECOLOR = 0x0800,
	/* Reserved for later use  */
	LV_BUTTONMATRIX_CTRL_RESERVED_1 = 0x1000,
	/* Reserved for later use  */
	LV_BUTTONMATRIX_CTRL_RESERVED_2 = 0x2000,
	/* Custom free-to-use flag  */
	LV_BUTTONMATRIX_CTRL_CUSTOM_1 = 0x4000,
	/* Custom free-to-use flag  */
	LV_BUTTONMATRIX_CTRL_CUSTOM_2 = 0x8000,
}

lv_chart_type_t :: enum i32 {
	/* Don't draw the series  */
	LV_CHART_TYPE_NONE = 0x0,
	/* Connect the points with lines  */
	LV_CHART_TYPE_LINE = 0x1,
	/* Draw bars for each series  */
	LV_CHART_TYPE_BAR = 0x2,
	/* Draw a single stacked bar for each data point. Supports only positive values  */
	LV_CHART_TYPE_STACKED = 0x3,
	/* Draw points and lines in 2D (x,y coordinates)  */
	LV_CHART_TYPE_SCATTER = 0x4,
}

lv_chart_update_mode_t :: enum i32 {
	/* Shift old data to the left and add the new one the right  */
	LV_CHART_UPDATE_MODE_SHIFT = 0x0,
	/* Add the new data in a circular way  */
	LV_CHART_UPDATE_MODE_CIRCULAR = 0x1,
}

lv_chart_axis_t :: enum i32 {
	LV_CHART_AXIS_PRIMARY_Y = 0x0,
	LV_CHART_AXIS_SECONDARY_Y = 0x1,
	LV_CHART_AXIS_PRIMARY_X = 0x2,
	LV_CHART_AXIS_SECONDARY_X = 0x4,
	LV_CHART_AXIS_LAST = 0x5,
}

lv_imagebutton_state_t :: enum i32 {
	LV_IMAGEBUTTON_STATE_RELEASED = 0x0,
	LV_IMAGEBUTTON_STATE_PRESSED = 0x1,
	LV_IMAGEBUTTON_STATE_DISABLED = 0x2,
	LV_IMAGEBUTTON_STATE_CHECKED_RELEASED = 0x3,
	LV_IMAGEBUTTON_STATE_CHECKED_PRESSED = 0x4,
	LV_IMAGEBUTTON_STATE_CHECKED_DISABLED = 0x5,
	LV_IMAGEBUTTON_STATE_NUM = 0x6,
}

lv_keyboard_mode_t :: enum i32 {
	LV_KEYBOARD_MODE_TEXT_LOWER = 0x0,
	LV_KEYBOARD_MODE_TEXT_UPPER = 0x1,
	LV_KEYBOARD_MODE_SPECIAL = 0x2,
	LV_KEYBOARD_MODE_NUMBER = 0x3,
	LV_KEYBOARD_MODE_USER_1 = 0x4,
	LV_KEYBOARD_MODE_USER_2 = 0x5,
	LV_KEYBOARD_MODE_USER_3 = 0x6,
	LV_KEYBOARD_MODE_USER_4 = 0x7,
}

lv_menu_mode_header_t :: enum i32 {
	/* Header is positioned at the top  */
	LV_MENU_HEADER_TOP_FIXED = 0x0,
	/* Header is positioned at the top and can be scrolled out of view  */
	LV_MENU_HEADER_TOP_UNFIXED = 0x1,
	/* Header is positioned at the bottom  */
	LV_MENU_HEADER_BOTTOM_FIXED = 0x2,
}

lv_menu_mode_root_back_button_t :: enum i32 {
	LV_MENU_ROOT_BACK_BUTTON_DISABLED = 0x0,
	LV_MENU_ROOT_BACK_BUTTON_ENABLED = 0x1,
}

lv_roller_mode_t :: enum i32 {
	/* Normal mode (roller ends at the end of the options).  */
	LV_ROLLER_MODE_NORMAL = 0x0,
	/* Infinite mode (roller can be scrolled forever).  */
	LV_ROLLER_MODE_INFINITE = 0x1,
}

lv_scale_mode_t :: enum i32 {
	LV_SCALE_MODE_HORIZONTAL_TOP = 0x0,
	LV_SCALE_MODE_HORIZONTAL_BOTTOM = 0x1,
	LV_SCALE_MODE_VERTICAL_LEFT = 0x2,
	LV_SCALE_MODE_VERTICAL_RIGHT = 0x3,
	LV_SCALE_MODE_ROUND_INNER = 0x4,
	LV_SCALE_MODE_ROUND_OUTER = 0x5,
	LV_SCALE_MODE_LAST = 0x6,
}

lv_slider_mode_t :: enum i32 {
	LV_SLIDER_MODE_NORMAL = 0x0,
	LV_SLIDER_MODE_SYMMETRICAL = 0x1,
	LV_SLIDER_MODE_RANGE = 0x2,
}

lv_slider_orientation_t :: enum i32 {
	LV_SLIDER_ORIENTATION_AUTO = 0x0,
	LV_SLIDER_ORIENTATION_HORIZONTAL = 0x1,
	LV_SLIDER_ORIENTATION_VERTICAL = 0x2,
}

lv_span_overflow_t :: enum i32 {
	LV_SPAN_OVERFLOW_CLIP = 0x0,
	LV_SPAN_OVERFLOW_ELLIPSIS = 0x1,
	/* Fence member  */
	LV_SPAN_OVERFLOW_LAST = 0x2,
}

lv_span_mode_t :: enum i32 {
	/* fixed the obj size  */
	LV_SPAN_MODE_FIXED = 0x0,
	/* Expand the object size to the text size  */
	LV_SPAN_MODE_EXPAND = 0x1,
	/* Keep width, break the too long lines and expand height  */
	LV_SPAN_MODE_BREAK = 0x2,
	/* Fence member  */
	LV_SPAN_MODE_LAST = 0x3,
}

lv_switch_orientation_t :: enum i32 {
	LV_SWITCH_ORIENTATION_AUTO = 0x0,
	LV_SWITCH_ORIENTATION_HORIZONTAL = 0x1,
	LV_SWITCH_ORIENTATION_VERTICAL = 0x2,
}

lv_table_cell_ctrl_t :: enum i32 {
	LV_TABLE_CELL_CTRL_NONE = 0x00,
	LV_TABLE_CELL_CTRL_MERGE_RIGHT = 0x01,
	LV_TABLE_CELL_CTRL_TEXT_CROP = 0x02,
	LV_TABLE_CELL_CTRL_CUSTOM_1 = 0x10,
	LV_TABLE_CELL_CTRL_CUSTOM_2 = 0x20,
	LV_TABLE_CELL_CTRL_CUSTOM_3 = 0x40,
	LV_TABLE_CELL_CTRL_CUSTOM_4 = 0x80,
}

lv_barcode_encoding_t :: enum i32 {
	/* Code 128 with GS1 encoding. Strips [FCN1] and spaces.  */
	LV_BARCODE_ENCODING_CODE128_GS1 = 0x0,
	/* Code 128 with raw encoding.  */
	LV_BARCODE_ENCODING_CODE128_RAW = 0x1,
}

lv_freetype_font_style_t :: enum i32 {
	LV_FREETYPE_FONT_STYLE_NORMAL = 0x0,
	LV_FREETYPE_FONT_STYLE_ITALIC = 0x1,
	LV_FREETYPE_FONT_STYLE_BOLD = 0x2,
}

lv_freetype_font_render_mode_t :: enum i32 {
	LV_FREETYPE_FONT_RENDER_MODE_BITMAP = 0x0,
	LV_FREETYPE_FONT_RENDER_MODE_OUTLINE = 0x1,
}

lv_freetype_outline_type_t :: enum i32 {
	LV_FREETYPE_OUTLINE_END = 0x0,
	LV_FREETYPE_OUTLINE_MOVE_TO = 0x1,
	LV_FREETYPE_OUTLINE_LINE_TO = 0x2,
	LV_FREETYPE_OUTLINE_CUBIC_TO = 0x3,
	LV_FREETYPE_OUTLINE_CONIC_TO = 0x4,
	LV_FREETYPE_OUTLINE_BORDER_START = 0x5,
}

_lvimage_flags_t :: enum i32 {
	/* For RGB map of the image data, mark if it's pre-multiplied with alpha. For indexed image, this bit indicated palette data is pre-multiplied with alpha.  */
	LV_IMAGE_FLAGS_PREMULTIPLIED = 0x0001,
	/* The image data is compressed, so decoder needs to decode image firstly. If this flag is set, the whole image will be decompressed upon decode, and get_area_cb won't be necessary.  */
	LV_IMAGE_FLAGS_COMPRESSED = 0x0008,
	/* The image is allocated from heap, thus should be freed after use.  */
	LV_IMAGE_FLAGS_ALLOCATED = 0x0010,
	/* If the image data is malloced and can be processed in place. In image decoder post processing, this flag means we modify it in-place.  */
	LV_IMAGE_FLAGS_MODIFIABLE = 0x0020,
	/* The image has custom drawing methods.  */
	LV_IMAGE_FLAGS_CUSTOM_DRAW = 0x0040,
	/* Flags reserved for user, lvgl won't use these bits.  */
	LV_IMAGE_FLAGS_USER1 = 0x0100,
	LV_IMAGE_FLAGS_USER2 = 0x0200,
	LV_IMAGE_FLAGS_USER3 = 0x0400,
	LV_IMAGE_FLAGS_USER4 = 0x0800,
	LV_IMAGE_FLAGS_USER5 = 0x1000,
	LV_IMAGE_FLAGS_USER6 = 0x2000,
	LV_IMAGE_FLAGS_USER7 = 0x4000,
	LV_IMAGE_FLAGS_USER8 = 0x8000,
}


/*
	---------------------
	 PROCEDURE POINTERS
	---------------------
*/

lv_screen_create_cb_t :: #type proc "c" () -> ^lv_obj_t
/* Log print function. Receives a string buffer to print".  */
lv_log_print_g_cb_t :: #type proc "c" (level: lv_log_level_t, buf: ^u8)
lv_tick_get_cb_t :: #type proc "c" () -> u32
lv_delay_cb_t :: #type proc "c" (ms: u32)
/* Timers execute this type of functions.  */
lv_timer_cb_t :: #type proc "c" (arg0: ^lv_timer_t)
/* Timer handler resume this type of function.  */
lv_timer_handler_resume_cb_t :: #type proc "c" (data: rawptr)
/* Type for async callback.  */
lv_async_cb_t :: #type proc "c" (arg0: rawptr)
/* Get the current value during an animation  */
lv_anim_path_cb_t :: #type proc "c" (arg0: ^lv_anim_t) -> i32
/* Generic prototype of "animator" functions. First parameter is the variable to animate. Second parameter is the value to set. Compatible with lv_xxx_set_yyy(obj, value) functions The x in _xcb_t means it's not a fully generic prototype because it doesn't receive lv_anim_t * as its first argument  */
lv_anim_exec_xcb_t :: #type proc "c" (arg0: rawptr, arg1: i32)
/* Same as lv_anim_exec_xcb_t but receives lv_anim_t * as the first parameter. It's more consistent but less convenient. Might be used by binding generator functions.  */
lv_anim_custom_exec_cb_t :: #type proc "c" (arg0: ^lv_anim_t, arg1: i32)
/* Callback to call when the animation is ready  */
lv_anim_completed_cb_t :: #type proc "c" (arg0: ^lv_anim_t)
/* Callback to call when the animation really stars (considering delay )  */
lv_anim_start_cb_t :: #type proc "c" (arg0: ^lv_anim_t)
/* Callback used when the animation values are relative to get the current value  */
lv_anim_get_value_cb_t :: #type proc "c" (arg0: ^lv_anim_t) -> i32
/* Callback used when the animation is deleted  */
lv_anim_deleted_cb_t :: #type proc "c" (arg0: ^lv_anim_t)
lv_rb_compare_t :: #type proc "c" (a: rawptr, b: rawptr) -> lv_rb_compare_res_t
lv_color_filter_cb_t :: #type proc "c" (arg0: ^_lv_color_filter_dsc_t , arg1: lv_color_t, arg2: lv_opa_t) -> lv_color_t
lv_draw_buf_malloc_cb_t :: #type proc "c" (size: uint, color_format: lv_color_format_t) -> rawptr
lv_draw_buf_free_cb_t :: #type proc "c" (draw_buf: rawptr)
lv_draw_buf_copy_cb_t :: #type proc "c" (dest: ^lv_draw_buf_t, dest_area: ^lv_area_t, src: ^lv_draw_buf_t, src_area: ^lv_area_t)
lv_draw_buf_align_cb_t :: #type proc "c" (buf: rawptr, color_format: lv_color_format_t) -> rawptr
lv_draw_buf_cache_operation_cb_t :: #type proc "c" (draw_buf: ^lv_draw_buf_t, area: ^lv_area_t)
lv_draw_buf_width_to_stride_cb_t :: #type proc "c" (w: u32, color_format: lv_color_format_t) -> u32
lv_iter_next_cb :: #type proc "c" (instance: rawptr, ctx: rawptr, elem: rawptr) -> lv_result_t
lv_iter_inspect_cb :: #type proc "c" (elem: rawptr)
lv_circle_buf_fill_cb_t :: #type proc "c" (buf: rawptr, buff_len: u32, index: i32, user_data: rawptr) -> bool
lv_tree_constructor_cb_t :: #type proc "c" (class_p: ^lv_tree_class_t, node: ^lv_tree_node_t)
lv_tree_destructor_cb_t :: #type proc "c" (class_p: ^lv_tree_class_t, node: ^lv_tree_node_t)
lv_tree_traverse_cb_t :: #type proc "c" (node: ^lv_tree_node_t, user_data: rawptr) -> bool
lv_tree_before_cb_t :: #type proc "c" (node: ^lv_tree_node_t, user_data: rawptr) -> bool
lv_tree_after_cb_t :: #type proc "c" (node: ^lv_tree_node_t, user_data: rawptr)
lv_layout_update_cb_t :: #type proc "c" (arg0: ^lv_obj_t, user_data: rawptr)
lv_event_cb_t :: #type proc "c" (e: ^lv_event_t)
lv_display_flush_cb_t :: #type proc "c" (disp: ^lv_display_t, area: ^lv_area_t, px_map: ^u8)
lv_display_flush_wait_cb_t :: #type proc "c" (disp: ^lv_display_t)
lv_obj_tree_walk_cb_t :: #type proc "c" (arg0: ^lv_obj_t, arg1: rawptr) -> lv_obj_tree_walk_res_t
/* Get info from an image and store in the header  LV_RESULT_OK: info written correctly; LV_RESULT_INVALID: failed  */
lv_image_decoder_info_f_t :: #type proc "c" (decoder: ^lv_image_decoder_t, dsc: ^lv_image_decoder_dsc_t, header: ^lv_image_header_t) -> lv_result_t
/* Open an image for decoding. Prepare it as it is required to read it later  */
lv_image_decoder_open_f_t :: #type proc "c" (decoder: ^lv_image_decoder_t, dsc: ^lv_image_decoder_dsc_t) -> lv_result_t
/* Decode full_area pixels incrementally by calling in a loop. Set decoded_area values to LV_COORD_MIN on first call. Required only if the "open" function can't return with the whole decoded pixel array. LV_RESULT_OK: ok; LV_RESULT_INVALID: failed or there is nothing left to decode  */
lv_image_decoder_get_area_cb_t :: #type proc "c" (decoder: ^lv_image_decoder_t, dsc: ^lv_image_decoder_dsc_t, full_area: ^lv_area_t, decoded_area: ^lv_area_t) -> lv_result_t
/* Close the pending decoding. Free resources etc.  */
lv_image_decoder_close_f_t :: #type proc "c" (decoder: ^lv_image_decoder_t, dsc: ^lv_image_decoder_dsc_t)
/* Custom drawing functions for special image formats.  */
lv_image_decoder_custom_draw_t :: #type proc "c" (layer: ^lv_layer_t, dsc: ^lv_image_decoder_dsc_t, coords: ^lv_area_t, draw_dsc: ^lv_draw_image_dsc_t, clip_area: ^lv_area_t)
/* Passed as a parameter to lv_draw_label_iterate_characters to draw the characters one by one  */
lv_draw_glyph_cb_t :: #type proc "c" (t: ^lv_draw_task_t, dsc: ^lv_draw_glyph_dsc_t, fill_dsc: ^lv_draw_fill_dsc_t, fill_area: ^lv_area_t)
/* PErform the actual rendering of a decoded image  */
lv_draw_image_core_cb :: #type proc "c" (t: ^lv_draw_task_t, draw_dsc: ^lv_draw_image_dsc_t, decoder_dsc: ^lv_image_decoder_dsc_t, sup: ^lv_draw_image_sup_t, img_coords: ^lv_area_t, clipped_img_area: ^lv_area_t)
lv_obj_class_event_cb_t :: #type proc "c" (class_p: ^lv_obj_class_t, e: ^lv_event_t)
lv_group_focus_cb_t :: #type proc "c" (arg0: ^lv_group_t)
lv_group_edge_cb_t :: #type proc "c" (arg0: ^lv_group_t, arg1: bool)
lv_indev_read_cb_t :: #type proc "c" (indev: ^lv_indev_t, data: ^lv_indev_data_t)
/* Indev key remapping callback  */
lv_indev_key_remap_cb_t :: #type proc "c" (indev: ^lv_indev_t, key: lv_key_t) -> lv_key_t
/* Callback called to notify Observer that Subject's value has changed  */
lv_observer_cb_t :: #type proc "c" (observer: ^lv_observer_t, subject: ^lv_subject_t)
lv_imgfont_get_path_cb_t :: #type proc "c" (font: ^lv_font_t, unicode: u32, unicode_next: u32, offset_y: ^i32, user_data: rawptr) -> rawptr
lv_buttonmatrix_button_draw_cb_t :: #type proc "c" (btnm: ^lv_obj_t, btn_id: u32, draw_area: ^lv_area_t, clip_area: ^lv_area_t) -> bool
lv_theme_apply_cb_t :: #type proc "c" (arg0: ^lv_theme_t, arg1: ^lv_obj_t)

/*
	---------------------
	 FORWARD DECLERATIONS
	---------------------
*/

lv_obj_t :: struct {}
/* Describe the common methods of every object. Similar to a C++ class.  */
lv_obj_class_t :: struct {}
/* Groups can be used to logically hold objects so that they can be individually focused. They are NOT for laying out objects on a screen (try layouts for that).  */
lv_group_t :: struct {}
lv_display_t :: struct {}
lv_layer_t :: struct {}
lv_draw_unit_t :: struct {}
/* Modified by NXP in 2024  */
lv_draw_task_t :: struct {}
lv_indev_t :: struct {}
lv_event_t :: struct {}
/* Descriptor of a lv_timer  */
lv_timer_t :: struct {}
lv_theme_t :: struct {}
/* Describes an animation  */
lv_anim_t :: struct {}
lv_anim_timeline_t :: struct {}
/* Describe the properties of a font  */
lv_font_t :: struct {}
lv_font_class_t :: struct {}
lv_font_info_t :: struct {}
lv_font_manager_t :: struct {}
lv_image_decoder_t :: struct {}
/* Describe an image decoding session. Stores data about the decoding  */
lv_image_decoder_dsc_t :: struct {}
lv_draw_image_dsc_t :: struct {}
lv_fragment_t :: struct {}
lv_fragment_class_t :: struct {}
/* Fragment states  */
lv_fragment_managed_states_t :: struct {}
lv_profiler_builtin_config_t :: struct {}
lv_rb_node_t :: struct {}
lv_rb_t :: struct {}
lv_color_filter_dsc_t :: struct {}
lv_event_dsc_t :: struct {}
/* The cache entry struct  */
lv_cache_t :: struct {}
lv_cache_entry_t :: struct {}
lv_fs_file_cache_t :: struct {}
/* Image decoder args. It determines how to decoder an image, e.g. whether to premultiply the alpha or not. It should be passed to lv_img_decoder_open() function. If NULL is provided, default args are used. 

Default args: all field are zero or false.   */
lv_image_decoder_args_t :: struct {}
lv_image_cache_data_t :: struct {}
lv_image_header_cache_data_t :: struct {}
lv_draw_mask_t :: struct {}
/* Store some info to speed up drawing of very large texts It takes a lot of time to get the first visible character because all the previous characters needs to be checked to calculate the positions. This structure stores an earlier (e.g. at -1000 px) coordinate and the index of that line. Therefore the calculations can start from here.  */
lv_draw_label_hint_t :: struct {}
lv_draw_glyph_dsc_t :: struct {}
lv_draw_image_sup_t :: struct {}
lv_draw_mask_rect_dsc_t :: struct {}
lv_obj_style_t :: struct {}
lv_obj_style_transition_dsc_t :: struct {}
/* Used as the event parameter of :ref:`LV_EVENT_HIT_TEST` to check if an point can click the object or not. res should be set like this: If already set to false another event wants that point non clickable. If you want to respect it leave it as false or set true to overwrite it. If already set true and point shouldn't be clickable set to false If already set to true you agree that point can click the object leave it as true  */
lv_hit_test_info_t :: struct {}
/* Used as the event parameter of :ref:`LV_EVENT_COVER_CHECK` to check if an area is covered by the object or not. In the event use const :ref:`lv_area_t` * area = lv_event_get_cover_area(e) to get the area to check and lv_event_set_cover_res(e, res) to set the result.  */
lv_cover_check_info_t :: struct {}
/* Special, rarely used attributes. They are allocated automatically if any elements is set.  */
lv_obj_spec_attr_t :: struct {}
/* Data of image  */
lv_image_t :: struct {}
/* Data of the animimage  */
lv_animimg_t :: struct {}
lv_arc_t :: struct {}
lv_arclabel_t :: struct {}
lv_label_t :: struct {}
lv_bar_anim_t :: struct {}
lv_bar_t :: struct {}
lv_button_t :: struct {}
/* Data of button matrix  */
lv_buttonmatrix_t :: struct {}
/* Data of calendar  */
lv_calendar_t :: struct {}
/* Canvas data  */
lv_canvas_t :: struct {}
/* Descriptor a chart series  */
lv_chart_series_t :: struct {}
lv_chart_cursor_t :: struct {}
lv_chart_t :: struct {}
lv_checkbox_t :: struct {}
lv_dropdown_t :: struct {}
lv_dropdown_list_t :: struct {}
lv_imagebutton_src_info_t :: struct {}
/* Data of image button  */
lv_imagebutton_t :: struct {}
/* Data of keyboard  */
lv_keyboard_t :: struct {}
/* Data of led  */
lv_led_t :: struct {}
/* Data of line  */
lv_line_t :: struct {}
lv_menu_load_page_event_data_t :: struct {}
lv_menu_history_t :: struct {}
lv_menu_t :: struct {}
lv_menu_page_t :: struct {}
lv_msgbox_t :: struct {}
lv_roller_t :: struct {}
lv_scale_section_t :: struct {}
lv_scale_t :: struct {}
lv_slider_t :: struct {}
lv_span_t :: struct {}
/* Data of label  */
lv_spangroup_t :: struct {}
/* Data of text area  */
lv_textarea_t :: struct {}
/* Data of spinbox  */
lv_spinbox_t :: struct {}
lv_switch_t :: struct {}
/* Cell data  */
lv_table_cell_t :: struct {}
/* Table data  */
lv_table_t :: struct {}
lv_tabview_t :: struct {}
lv_tileview_t :: struct {}
lv_tileview_tile_t :: struct {}
lv_win_t :: struct {}
lv_spinner_t :: struct {}
lv_3dtexture_t :: struct {}
lv_gltf_t :: struct {}
lv_gltf_model_t :: struct {}
lv_gltf_model_node_t :: struct {}
/* The Subject (an observable value)  */
lv_subject_t :: struct {}
/* The observer object: a descriptor returned when subscribing LVGL widgets to subjects  */
lv_observer_t :: struct {}
/* Descriptor created by :ref:`lv_obj_add_subject_increment_event()`  */
lv_subject_increment_dsc_t :: struct {}
lv_monkey_config_t :: struct {}
lv_ime_pinyin_t :: struct {}
lv_file_explorer_t :: struct {}
lv_barcode_t :: struct {}
lv_qrcode_t :: struct {}
lv_freetype_outline_vector_t :: struct {}
lv_freetype_outline_event_param_t :: struct {}
lv_fpoint_t :: struct {}
lv_matrix_t :: struct {}
lv_vector_path_t :: struct {}
lv_vector_gradient_t :: struct {}
lv_vector_fill_dsc_t :: struct {}
lv_vector_stroke_dsc_t :: struct {}
lv_vector_path_ctx_t :: struct {}
lv_draw_vector_dsc_t :: struct {}
lv_xkb_t :: struct {}
lv_libinput_event_t :: struct {}
lv_libinput_t :: struct {}
lv_draw_sw_unit_t :: struct {}
lv_draw_sw_mask_common_dsc_t :: struct {}
lv_draw_sw_mask_line_param_t :: struct {}
lv_draw_sw_mask_angle_param_t :: struct {}
lv_draw_sw_mask_radius_param_t :: struct {}
lv_draw_sw_mask_fade_param_t :: struct {}
lv_draw_sw_mask_map_param_t :: struct {}
lv_draw_sw_blend_dsc_t :: struct {}
lv_draw_sw_blend_fill_dsc_t :: struct {}
lv_draw_sw_blend_image_dsc_t :: struct {}
lv_draw_buf_handlers_t :: struct {}
lv_rlottie_t :: struct {}
lv_ffmpeg_player_t :: struct {}
lv_opengles_window_t :: struct {}
lv_opengles_window_texture_t :: struct {}
/* Description of a array  */
lv_array_t :: struct {}
lv_iter_t :: struct {}
lv_circle_buf_t :: struct {}
lv_draw_buf_t :: struct {}
lv_xml_component_scope_t :: struct {}
lv_xml_parser_state_t :: struct {}
lv_xml_load_t :: struct {}
/* Describe the common methods of every object. Similar to a C++ class.  */
lv_tree_class_t :: struct {}
/* Description of a tree node  */
lv_tree_node_t :: struct {}
lv_fragment_manager_t :: struct {}

/*
	-------------------
	 TYPEDEFS
	-------------------
*/

lv_uintptr_t :: distinct uintptr
lv_intptr_t :: distinct int
lv_value_precise_t :: distinct f32
lv_opa_t :: distinct u8
lv_style_prop_t :: distinct u8
// lv_gltf_environment_t :: distinct _lv_gltf_environment
// lv_gltf_ibl_sampler_t :: distinct _lv_gltf_ibl_sampler
lv_prop_id_t :: distinct u32
lv_mem_pool_t :: distinct rawptr
lv_log_level_t :: distinct i8
/* Dummy type to make handling easier  */
lv_ll_node_t :: distinct u8
lv_anim_enable_t :: distinct bool
lv_rb_compare_res_t :: distinct i32
lv_image_flags_t :: distinct _lvimage_flags_t
lv_tree_walk_mode_t :: distinct u8
/* A joint type for lv_part_t and lv_state_t . Example values 0 : means LV_PART_MAIN | LV_STATE_DEFAULT LV_STATE_PRSSED LV_PART_KNOB LV_PART_KNOB | LV_STATE_PRESSED | LV_STATE_CHECKED  */
lv_style_selector_t :: distinct u32
LV_FT_FONT_STYLE :: distinct lv_freetype_font_style_t
lv_freetype_outline_t :: distinct rawptr
lv_freetype_font_src_t :: distinct u8
lv_coord_t :: distinct i32
lv_res_t :: distinct lv_result_t
lv_disp_t :: distinct lv_display_t
lv_disp_rotation_t :: distinct lv_display_rotation_t
lv_disp_render_t :: distinct lv_display_render_mode_t
lv_anim_ready_cb_t :: distinct lv_anim_completed_cb_t
lv_scr_load_anim_t :: distinct lv_screen_load_anim_t
lv_btnmatrix_ctrl_t :: distinct lv_buttonmatrix_ctrl_t

/*
	-----------------
	 STRUCTURES
	-----------------
*/

/* Heap information structure.  */
lv_mem_monitor_t :: struct {
	/* Total heap size  */
	total_size: uint,
	free_cnt: uint,
	/* Size of available memory  */
	free_size: uint,
	free_biggest_size: uint,
	used_cnt: uint,
	/* Max size of Heap memory used  */
	max_used: uint,
	/* Percentage used  */
	used_pct: u8,
	/* Amount of fragmentation  */
	frag_pct: u8,
}

/* Description of a linked list  */
lv_ll_t :: struct {
	n_size: u32,
	head: ^lv_ll_node_t,
	tail: ^lv_ll_node_t,
}

lv_sqrt_res_t :: struct {
	i: u16,
	f: u16,
}

/* Description of a array  */
_lv_array_t :: struct {
	data: ^u8,
	size: u32,
	capacity: u32,
	element_size: u32,
	inner_alloc: bool,
}

/* Parameter used when path is custom_bezier  */
lv_anim_bezier3_para_t :: struct {
	x1: i16,
	y1: i16,
	x2: i16,
	y2: i16,
}

/* Describes an animation  */
_lv_anim_t :: struct {
	/* Variable (Widget or other user-provided object) to animate  */
	var: rawptr,
	/* Function to execute to animate  */
	exec_cb: lv_anim_exec_xcb_t,
	/* Function to execute to animate, same purpose as exec_cb but different parameters  */
	custom_exec_cb: lv_anim_custom_exec_cb_t,
	/* Call it when animation is starts (considering delay )  */
	start_cb: lv_anim_start_cb_t,
	/* Call it when animation is fully completed  */
	completed_cb: lv_anim_completed_cb_t,
	/* Call it when animation is deleted  */
	deleted_cb: lv_anim_deleted_cb_t,
	/* Get current value in relative mode  */
	get_value_cb: lv_anim_get_value_cb_t,
	/* Custom user data  */
	user_data: rawptr,
	/* Provides path (curve) of animation  */
	path_cb: lv_anim_path_cb_t,
	/* Start value  */
	start_value: i32,
	/* Current value  */
	current_value: i32,
	/* End value  */
	end_value: i32,
	/* Animation duration in ms  */
	duration: i32,
	/* Ms elapsed since animation started. Set to negative to make delay.  */
	act_time: i32,
	/* Wait (in ms) after forward play ends and before reverse play begins.  */
	reverse_delay: u32,
	/* Reverse animation duration in ms  */
	reverse_duration: u32,
	/* Wait before repeating  */
	repeat_delay: u32,
	/* Repeat count for animation  */
	repeat_cnt: u32,
	parameter: struct #raw_union {
		bezier3: lv_anim_bezier3_para_t,
	},
	last_timer_run: u32,
	/* The time when the animation was paused  */
	pause_time: u32,
	/* The amount of the time the animation must stay paused for  */
	pause_duration: u32,
	/* Indicates that the animation is paused  */
	is_paused: u8,
	/* Reverse play is in progress  */
	reverse_play_in_progress: u8,
	/* When not equal to global.anim_state.anim_run_round (which toggles each time animation timer executes), indicates this animation needs to be updated.  */
	run_round: u8,
	/* Indicates that start_cb was already called  */
	start_cb_called: u8,
	/* 1: Apply start value immediately even is there is a delay  */
	early_apply: u8,
}

lv_anim_timeline_dsc_t :: struct {
	anim: lv_anim_t,
	start_time: u32,
	is_started: u8,
	is_completed: u8,
}

/* Represents a point on the screen.  */
lv_point_t :: struct {
	x: i32,
	y: i32,
}

lv_point_precise_t :: struct {
	x: lv_value_precise_t,
	y: lv_value_precise_t,
}

/* Represents an area of the screen.  */
lv_area_t :: struct {
	x1: i32,
	y1: i32,
	x2: i32,
	y2: i32,
}

lv_color_t :: struct {
	blue: u8,
	green: u8,
	red: u8,
}

lv_color16_t :: struct {
	blue: u16,
	green: u16,
	red: u16,
}

lv_color32_t :: struct {
	blue: u8,
	green: u8,
	red: u8,
	alpha: u8,
}

lv_color_hsv_t :: struct {
	h: u16,
	s: u8,
	v: u8,
}

lv_color16a_t :: struct {
	lumi: u8,
	alpha: u8,
}

_lv_color_filter_dsc_t :: struct {
	filter_cb: lv_color_filter_cb_t,
	user_data: rawptr,
}

lv_image_header_t :: struct {
	/* Magic number. Must be LV_IMAGE_HEADER_MAGIC  */
	magic: u32,
	/* Color format: See lv_color_format_t  */
	cf: u32,
	/* Image flags, see lv_image_flags_t  */
	flags: u32,
	w: u32,
	h: u32,
	/* Number of bytes in a row  */
	stride: u32,
	/* Reserved to be used later  */
	reserved_2: u32,
}

lv_yuv_plane_t :: struct {
	buf: rawptr,
	/* Number of bytes in a row  */
	stride: u32,
}

/* Struct to describe a constant image resource. It's similar to lv_draw_buf_t, but the data is constant.  */
lv_img_dsc_t :: struct {
	/* A header describing the basics of the image  */
	header: lv_image_header_t,
	/* Size of the image in bytes  */
	data_size: u32,
	/* Pointer to the data of the image  */
	data: ^u8,
	/* A reserved field to make it has same size as lv_draw_buf_t  */
	reserved: rawptr,
	/* A reserved field to make it has same size as lv_draw_buf_t  */
	reserved_2: rawptr,
}

_lv_draw_buf_t :: struct {
	header: lv_image_header_t,
	/* Total buf size in bytes  */
	data_size: u32,
	data: ^u8,
	/* Unaligned address of data , used internally by lvgl  */
	unaligned_data: rawptr,
	/* draw buffer alloc/free ops.  */
	handlers: ^lv_draw_buf_handlers_t,
}

/* Describe the common methods of every object. Similar to a C++ class.  */
_lv_tree_class_t :: struct {
	base_class: ^lv_tree_class_t,
	instance_size: u32,
	constructor_cb: lv_tree_constructor_cb_t,
	destructor_cb: lv_tree_destructor_cb_t,
}

/* Description of a tree node  */
_lv_tree_node_t :: struct {
	parent: ^lv_tree_node_t,
	children: ^^lv_tree_node_t,
	child_cnt: u32,
	child_cap: u32,
	class_p: ^lv_tree_class_t,
}

/* Describes the properties of a glyph.  */
lv_font_glyph_dsc_t :: struct {
	/* Pointer to a font where the glyph was actually found after handling fallbacks  */
	resolved_font: ^lv_font_t,
	/* The glyph needs this space. Draw the next glyph after this width.  */
	adv_w: u16,
	/* Width of the glyph's bounding box  */
	box_w: u16,
	/* Height of the glyph's bounding box  */
	box_h: u16,
	/* x offset of the bounding box  */
	ofs_x: i16,
	/* y offset of the bounding box  */
	ofs_y: i16,
	/* Bytes in each line. If 0 than there is no padding at the end of the line.  */
	stride: u16,
	/* Font format of the glyph see lv_font_glyph_format_t  */
	format: lv_font_glyph_format_t,
	/* Glyph is missing. But placeholder will still be displayed  */
	is_placeholder: u8,
	/* 0: Get bitmap should return an A8 or ARGB8888 image. 1: return the bitmap as it is (Maybe A1/2/4 or any proprietary formats).  */
	req_raw_bitmap: u8,
	/* used with freetype vector fonts - width of the letter border  */
	outline_stroke_width: i32,
	/* The index of the glyph in the font file. Used by the font cache  */
	gid: struct #raw_union {
		index: u32,
		src: rawptr,
	},
	/* The cache entry of the glyph draw data. Used by the font cache  */
	entry: ^lv_cache_entry_t,
}

/* Describe the properties of a font  */
_lv_font_t :: struct {
	/* Get a glyph's descriptor from a font  */
	get_glyph_dsc: #type proc "c" (arg0: ^lv_font_t, arg1: ^lv_font_glyph_dsc_t, letter: u32, letter_next: u32) -> bool,
	/* Get a glyph's bitmap from a font  */
	get_glyph_bitmap: #type proc "c" (arg0: ^lv_font_glyph_dsc_t, arg1: ^lv_draw_buf_t) -> rawptr,
	/* Release a glyph  */
	release_glyph: #type proc "c" (arg0: ^lv_font_t, arg1: ^lv_font_glyph_dsc_t),
	/* The real line height where any text fits  */
	line_height: i32,
	/* Base line measured from the bottom of the line_height  */
	base_line: i32,
	/* An element of lv_font_subpx_t  */
	subpx: u8,
	/* An element of lv_font_kerning_t  */
	kerning: u8,
	/* The font will be used as static bitmap  */
	static_bitmap: u8,
	/* Distance between the top of the underline and base line (< 0 means below the base line)  */
	underline_position: i8,
	/* Thickness of the underline  */
	underline_thickness: i8,
	/* Store implementation specific or run_time data or caching here  */
	dsc: rawptr,
	/* Fallback font for missing glyph. Resolved recursively  */
	fallback: ^lv_font_t,
	/* Custom user data for font.  */
	user_data: rawptr,
}

_lv_font_class_t :: struct {
	/* Font creation callback function  */
	create_cb: #type proc "c" (info: ^lv_font_info_t, src: rawptr) -> ^lv_font_t,
	/* Font deletion callback function  */
	delete_cb: #type proc "c" (font: ^lv_font_t),
	/* Font source duplication callback function  */
	dup_src_cb: #type proc "c" (src: rawptr) -> rawptr,
	/* Font source free callback function  */
	free_src_cb: #type proc "c" (src: rawptr),
}

_lv_font_info_t :: struct {
	/* Font name, used to distinguish different font resources  */
	name: ^u8,
	/* Font backend implementation  */
	class_p: ^lv_font_class_t,
	/* Font size in pixel  */
	size: u32,
	/* Font rendering mode, see lv_freetype_font_render_mode_t  */
	render_mode: u32,
	/* Font style, see lv_freetype_font_style_t  */
	style: u32,
	/* Font kerning, see lv_font_kerning_t  */
	kerning: lv_font_kerning_t,
}

/* A gradient stop definition. This matches a color and a position in a virtual 0-255 scale.  */
lv_grad_stop_t :: struct {
	/* The stop color  */
	color: lv_color_t,
	/* The opacity of the color  */
	opa: lv_opa_t,
	/* The stop position in 1/255 unit  */
	frac: u8,
}

/* A descriptor of a gradient.  */
lv_grad_dsc_t :: struct {
	/* A gradient stop array  */
	stops: [2]lv_grad_stop_t,
	/* The number of used stops in the array  */
	stops_count: u8,
	/* The gradient direction. Any of LV_GRAD_DIR_NONE, LV_GRAD_DIR_VER, LV_GRAD_DIR_HOR, LV_GRAD_TYPE_LINEAR, LV_GRAD_TYPE_RADIAL, LV_GRAD_TYPE_CONICAL  */
	dir: lv_grad_dir_t,
	/* Behaviour outside the defined range. LV_GRAD_EXTEND_NONE, LV_GRAD_EXTEND_PAD, LV_GRAD_EXTEND_REPEAT, LV_GRAD_EXTEND_REFLECT  */
	extend: lv_grad_extend_t,
	params: struct #raw_union {
		linear: struct {
				start: lv_point_t,
				end: lv_point_t,
			},
		radial: struct {
				focal: lv_point_t,
				focal_extent: lv_point_t,
				end: lv_point_t,
				end_extent: lv_point_t,
			},
		conical: struct {
				center: lv_point_t,
				start_angle: i16,
				end_angle: i16,
			},
	},
	state: rawptr,
}

/* A image colorkey definition. The transparency within the color range of [low, high] will be set to LV_OPA_TRANSP If the "enable" flag is set to true.  */
lv_image_colorkey_t :: struct {
	low: lv_color_t,
	high: lv_color_t,
}

/* Descriptor for style transitions  */
lv_style_transition_dsc_t :: struct {
	/* An array with the properties to animate.  */
	props: ^lv_style_prop_t,
	/* A custom user data that will be passed to the animation's user_data  */
	user_data: rawptr,
	/* A path for the animation.  */
	path_xcb: lv_anim_path_cb_t,
	/* Duration of the transition in [ms]  */
	time: u32,
	/* Delay before the transition in [ms]  */
	delay: u32,
}

/* Descriptor of a constant style property.  */
lv_style_const_prop_t :: struct {
	prop: lv_style_prop_t,
	value: lv_style_value_t,
}

/* Descriptor of a style (a collection of properties and values).  */
lv_style_t :: struct {
	values_and_props: rawptr,
	has_group: u32,
	/* 255 means it's a constant style  */
	prop_cnt: u8,
}

lv_event_list_t :: struct {
	array: lv_array_t,
	/* True: the list is being nested traversed  */
	is_traversing: u8,
	/* True: the list has marked deleting objects when some of events are marked as deleting  */
	has_marked_deleting: u8,
}

lv_fs_drv_t :: struct {
	letter: u8,
	cache_size: u32,
	ready_cb: #type proc "c" (drv: ^lv_fs_drv_t) -> bool,
	remove_cb: #type proc "c" (drv: ^lv_fs_drv_t),
	open_cb: #type proc "c" (drv: ^lv_fs_drv_t, path: ^u8, mode: lv_fs_mode_t) -> rawptr,
	close_cb: #type proc "c" (drv: ^lv_fs_drv_t, file_p: rawptr) -> lv_fs_res_t,
	read_cb: #type proc "c" (drv: ^lv_fs_drv_t, file_p: rawptr, buf: rawptr, btr: u32, br: ^u32) -> lv_fs_res_t,
	write_cb: #type proc "c" (drv: ^lv_fs_drv_t, file_p: rawptr, buf: rawptr, btw: u32, bw: ^u32) -> lv_fs_res_t,
	seek_cb: #type proc "c" (drv: ^lv_fs_drv_t, file_p: rawptr, pos: u32, whence: lv_fs_whence_t) -> lv_fs_res_t,
	tell_cb: #type proc "c" (drv: ^lv_fs_drv_t, file_p: rawptr, pos_p: ^u32) -> lv_fs_res_t,
	dir_open_cb: #type proc "c" (drv: ^lv_fs_drv_t, path: ^u8) -> rawptr,
	dir_read_cb: #type proc "c" (drv: ^lv_fs_drv_t, rddir_p: rawptr, fn: ^u8, fn_len: u32) -> lv_fs_res_t,
	dir_close_cb: #type proc "c" (drv: ^lv_fs_drv_t, rddir_p: rawptr) -> lv_fs_res_t,
	/* Custom file user data  */
	user_data: rawptr,
}

lv_fs_file_t :: struct {
	file_d: rawptr,
	drv: ^lv_fs_drv_t,
	cache: ^lv_fs_file_cache_t,
}

lv_fs_dir_t :: struct {
	dir_d: rawptr,
	drv: ^lv_fs_drv_t,
}

/* Extended path object to specify buffer for memory-mapped files  */
lv_fs_path_ex_t :: struct {
	/* Store the driver letter address and size  */
	path: [64]u8,
}

_lv_layer_t :: struct {
	/* Target draw buffer of the layer  */
	draw_buf: ^lv_draw_buf_t,
	/* Linked list of draw tasks  */
	draw_task_head: ^lv_draw_task_t,
	/* Parent layer  */
	parent: ^lv_layer_t,
	/* Next layer  */
	next: ^lv_layer_t,
	/* User data  */
	user_data: rawptr,
	/* The absolute coordinates of the buffer  */
	buf_area: lv_area_t,
	/* The physical clipping area relative to the display  */
	phy_clip_area: lv_area_t,
	/* NEVER USE IT DRAW UNITS. USED INTERNALLY DURING DRAW TASK CREATION. The current clip area with absolute coordinates, always the same or smaller than buf_area Can be set before new draw tasks are added to indicate the clip area of the draw tasks. Therefore :ref:`lv_draw_add_task()` always saves it in the new draw task to know the clip area when the draw task was added. During drawing the draw units also sees the saved clip_area and should use it during drawing. During drawing the layer's clip area shouldn't be used as it might be already changed for other draw tasks.  */
	_clip_area: lv_area_t,
	/* Partial y offset  */
	partial_y_offset: i32,
	/* Recolor of the layer  */
	recolor: lv_color32_t,
	/* The color format of the layer. LV_COLOR_FORMAT_...  */
	color_format: lv_color_format_t,
	/* Flag indicating all tasks are added  */
	all_tasks_added: bool,
	/* Opacity of the layer  */
	opa: lv_opa_t,
}

lv_draw_dsc_base_t :: struct {
	/* The widget for which draw descriptor was created  */
	obj: ^lv_obj_t,
	/* The widget part for which draw descriptor was created  */
	part: u32,
	/* A widget type specific ID (e.g. table row index). See the docs of the given widget.  */
	id1: u32,
	/* A widget type specific ID (e.g. table column index). See the docs of the given widget.  */
	id2: u32,
	/* The target layer  */
	layer: ^lv_layer_t,
	/* Size of the specific draw descriptor into which this base descriptor is embedded  */
	dsc_size: uint,
	/* Any custom user data  */
	user_data: rawptr,
}

lv_draw_rect_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	radius: i32,
	bg_image_src: rawptr,
	bg_image_symbol_font: rawptr,
	bg_image_recolor: lv_color_t,
	bg_image_opa: lv_opa_t,
	bg_image_recolor_opa: lv_opa_t,
	bg_image_tiled: u8,
	bg_opa: lv_opa_t,
	border_opa: lv_opa_t,
	outline_opa: lv_opa_t,
	shadow_opa: lv_opa_t,
	/* First element of a gradient is a color, so it maps well here  */
	bg_color: lv_color_t,
	bg_grad: lv_grad_dsc_t,
	bg_image_colorkey: ^lv_image_colorkey_t,
	border_color: lv_color_t,
	border_width: i32,
	border_side: lv_border_side_t,
	border_post: u8,
	outline_color: lv_color_t,
	outline_width: i32,
	outline_pad: i32,
	shadow_color: lv_color_t,
	shadow_width: i32,
	shadow_offset_x: i32,
	shadow_offset_y: i32,
	shadow_spread: i32,
}

lv_draw_fill_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* Radius, LV_RADIUS_CIRCLE for max. radius  */
	radius: i32,
	/* Opacity in 0...255 range. LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20, .. LV_OPA_COVER can be used as well  */
	opa: lv_opa_t,
	/* The color of the rectangle. If the gradient is set (grad.dir!=LV_GRAD_DIR_NONE) it's ignored.  */
	color: lv_color_t,
	/* Describe a gradient. If grad.dir is not LV_GRAD_DIR_NONE  color will be ignored  */
	grad: lv_grad_dsc_t,
}

lv_draw_border_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* Radius, LV_RADIUS_CIRCLE for max. radius  */
	radius: i32,
	/* The color of the border.  */
	color: lv_color_t,
	/* The width of the border in pixels  */
	width: i32,
	/* Opacity in 0...255 range. LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20, .. LV_OPA_COVER can be used as well  */
	opa: lv_opa_t,
	/* LV_BORDER_SIDE_NONE/LEFT/RIGHT/TOP/BOTTOM/FULL. LV_BORDER_SIDE_INTERNAL is an information for upper layers and shouldn't be used here.  */
	side: lv_border_side_t,
}

lv_draw_box_shadow_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* Radius, LV_RADIUS_CIRCLE for max. radius  */
	radius: i32,
	/* Color of shadow  */
	color: lv_color_t,
	/* Width of the shadow. (radius of the blur)  */
	width: i32,
	/* Make the rectangle larger with this value in all directions. Can be negative too.  */
	spread: i32,
	/* Offset the rectangle horizontally.  */
	ofs_x: i32,
	/* Offset the rectangle vertically.  */
	ofs_y: i32,
	/* Opacity in 0...255 range. LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20, .. LV_OPA_COVER can be used as well  */
	opa: lv_opa_t,
	/* Set bg_cover to 1 if the background will cover the shadow. It's a hint to the renderer about it might skip some masking.  */
	bg_cover: u8,
}

lv_draw_label_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* The text to draw  */
	text: ^u8,
	/* The size of the text  */
	text_size: lv_point_t,
	/* The font to use. Fallback fonts are also handled.  */
	font: ^lv_font_t,
	/* Color of the text  */
	color: lv_color_t,
	/* Extra space between the lines  */
	line_space: i32,
	/* Extra space between the characters  */
	letter_space: i32,
	/* Offset the text with this value horizontally  */
	ofs_x: i32,
	/* Offset the text with this value vertically  */
	ofs_y: i32,
	/* Rotation of the letters in 0.1 degree unit  */
	rotation: i32,
	/* The first characters index for selection (not byte index). LV_DRAW_LABEL_NO_TXT_SEL for no selection  */
	sel_start: u32,
	/* The last characters's index for selection (not byte index). LV_DRAW_LABEL_NO_TXT_SEL for no selection  */
	sel_end: u32,
	/* Color of the selected characters  */
	sel_color: lv_color_t,
	/* Background color of the selected characters  */
	sel_bg_color: lv_color_t,
	/* The number of characters to render. 0: means render until reaching the \0 termination.  */
	text_length: u32,
	/* The alignment of the text LV_TEXT_ALIGN_LEFT/RIGHT/CENTER  */
	align: lv_text_align_t,
	/* The base direction. Used when type setting Right-to-left (e.g. Arabic) texts  */
	bidi_dir: lv_base_dir_t,
	/* Opacity of the text in 0...255 range. LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20, .. LV_OPA_COVER can be used as well  */
	opa: lv_opa_t,
	/* Letter outline stroke opacity  */
	outline_stroke_opa: lv_opa_t,
	/* Text decoration, e.g. underline  */
	decor: lv_text_decor_t,
	/* Some flags to control type setting  */
	flag: lv_text_flag_t,
	/* 1: malloc a buffer and copy text there. 0: text will be valid during rendering.  */
	text_local: u8,
	/* Indicate that the text is constant and its pointer can be safely saved e.g. in a cache.  */
	text_static: u8,
	/* 1: already executed lv_bidi_process_paragraph. 0: has not been executed lv_bidi_process_paragraph.  */
	has_bided: u8,
	/* Pointer to an externally stored struct where some data can be cached to speed up rendering  */
	hint: ^lv_draw_label_hint_t,
	outline_stroke_color: lv_color_t,
	outline_stroke_width: i32,
}

lv_draw_letter_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	unicode: u32,
	font: ^lv_font_t,
	color: lv_color_t,
	rotation: i32,
	scale_x: i32,
	scale_y: i32,
	skew_x: i32,
	skew_y: i32,
	pivot: lv_point_t,
	opa: lv_opa_t,
	decor: lv_text_decor_t,
	blend_mode: lv_blend_mode_t,
	outline_stroke_opa: lv_opa_t,
	outline_stroke_width: i32,
	outline_stroke_color: lv_color_t,
}

_lv_draw_image_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* The image source: pointer to :ref:`lv_img_dsc_t` or a path to a file  */
	src: rawptr,
	/* The header of the image. Initialized internally in lv_draw_image  */
	header: lv_image_header_t,
	/* Clip the corner of the image with this radius. Use LV_RADIUS_CIRCLE for max. radius  */
	clip_radius: i32,
	/* The rotation of the image in 0.1 degree unit. E.g. 234 means 23.4  */
	rotation: i32,
	/* Horizontal scale (zoom) of the image. 256 (LV_SCALE_NONE): means no zoom, 512 double size, 128 half size.  */
	scale_x: i32,
	/* Same as scale_y but vertically  */
	scale_y: i32,
	/* Parallelogram like transformation of the image horizontally in 0.1 degree unit. E.g. 456 means 45.6.  */
	skew_x: i32,
	/* Same as skew_x but vertically  */
	skew_y: i32,
	/* The pivot point of transformation (scale and rotation). 0;0 is the top left corner of the image. Can be outside of the image too.  */
	pivot: lv_point_t,
	/* Mix this color to the images. In case of LV_COLOR_FORMAT_A8 it will be the color of the visible pixels  */
	recolor: lv_color_t,
	/* The intensity of recoloring. 0 means, no recolor, 255 means full cover (transparent pixels remain transparent)  */
	recolor_opa: lv_opa_t,
	/* Opacity in 0...255 range. LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20, .. LV_OPA_COVER can be used as well  */
	opa: lv_opa_t,
	/* Describes how to blend the pixels of the image to the background. See lv_blend_mode_t for more details.  */
	blend_mode: lv_blend_mode_t,
	/* 1: perform the transformation with anti-aliasing  */
	antialias: u16,
	/* If the image is smaller than the image_area field of lv_draw_image_dsc_t tile the image (repeat is both horizontally and vertically) to fill the image_area area  */
	tile: u16,
	colorkey: ^lv_image_colorkey_t,
	/* Used internally to store some information about the palette or the color of A8 images  */
	sup: ^lv_draw_image_sup_t,
	/* Used to indicate the entire original, non-clipped area where the image is to be drawn. This is important for: Layer rendering, where it might happen that only a smaller area of the layer is rendered and e.g. clip_radius needs to know what the original image was. Tiled images, where the target draw area is larger than the image to be tiled.  */
	image_area: lv_area_t,
	/* Pointer to an A8 or L8 image descriptor to mask the image with. The mask is always center aligned.  */
	bitmap_mask_src: ^lv_img_dsc_t,
}

lv_draw_line_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* The first point of the line. If LV_USE_FLOAT is enabled float number can be also used  */
	p1: lv_point_precise_t,
	/* The second point of the line. If LV_USE_FLOAT is enabled float number can be also used  */
	p2: lv_point_precise_t,
	/* The color of the line  */
	color: lv_color_t,
	/* The width (thickness) of the line  */
	width: i32,
	/* The length of a dash (0: don't dash)  */
	dash_width: i32,
	/* The length of the gaps between dashes (0: don't dash)  */
	dash_gap: i32,
	/* Opacity of the line in 0...255 range. LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20, .. LV_OPA_COVER can be used as well  */
	opa: lv_opa_t,
	/* Make the line start rounded  */
	round_start: u8,
	/* Make the line end rounded  */
	round_end: u8,
	/* 1: Do not bother with line ending (if it's not visible for any reason)  */
	raw_end: u8,
}

lv_draw_arc_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* The color of the arc  */
	color: lv_color_t,
	/* The width (thickness) of the arc  */
	width: i32,
	/* The start angle in 1 degree units (if LV_USE_FLOAT is enabled a float number can be also used) 0 is the 3 o'clock position, 90 is the 6 o'clock, etc.  */
	start_angle: lv_value_precise_t,
	/* The end angle, similarly to start_angle.  */
	end_angle: lv_value_precise_t,
	/* The center point of the arc.  */
	center: lv_point_t,
	/* An image source to be used instead of color . NULL if unused  */
	img_src: rawptr,
	/* The outer radius of the arc  */
	radius: u16,
	/* Opacity of the arc in 0...255 range. LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20, .. LV_OPA_COVER can be used as well  */
	opa: lv_opa_t,
	/* 1: Make the arc ends rounded  */
	rounded: u8,
}

lv_draw_triangle_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* Points of the triangle. If LV_USE_FLOAT is enabled floats can be used here  */
	p: [3]lv_point_precise_t,
	/* Color of the triangle  */
	color: lv_color_t,
	/* Opacity of the arc in 0...255 range. LV_OPA_TRANSP, LV_OPA_10, LV_OPA_20, .. LV_OPA_COVER can be used as well  */
	opa: lv_opa_t,
	/* Describe a gradient. If grad.dir is not LV_GRAD_DIR_NONE  color will be ignored  */
	grad: lv_grad_dsc_t,
}

lv_draw_blur_dsc_t :: struct {
	base: lv_draw_dsc_base_t,
	/* The intensity of blur.  */
	blur_radius: i32,
	/* The corner radius of the blurred area  */
	corner_radius: i32,
	/* Sets whether to prefer speed or precision  */
	quality: lv_blur_quality_t,
}

/* Data structure passed to an input driver to fill  */
lv_indev_data_t :: struct {
	gesture_type: [lv_indev_gesture_type_t.LV_INDEV_GESTURE_CNT]lv_indev_gesture_type_t,
	gesture_data: [lv_indev_gesture_type_t.LV_INDEV_GESTURE_CNT]rawptr,
	/* LV_INDEV_STATE_RELEASED or LV_INDEV_STATE_PRESSED  */
	state: lv_indev_state_t,
	/* For LV_INDEV_TYPE_POINTER the currently pressed point  */
	point: lv_point_t,
	/* For LV_INDEV_TYPE_KEYPAD the currently pressed key  */
	key: u32,
	/* For LV_INDEV_TYPE_BUTTON the currently pressed button  */
	btn_id: u32,
	/* For LV_INDEV_TYPE_ENCODER number of steps since the previous read  */
	enc_diff: i16,
	/* Initialized to :ref:`lv_tick_get()` . Driver may provide more accurate timestamp for buffered events  */
	timestamp: u32,
	/* If set to true, the read callback is invoked again, unless the device is in event-driven mode  */
	continue_reading: bool,
}

/* The Subject (an observable value)  */
_lv_subject_t :: struct {
	/* Subscribers  */
	subs_ll: lv_ll_t,
	/* Current value  */
	value: lv_subject_value_t,
	/* Previous value  */
	prev_value: lv_subject_value_t,
	/* Minimum value for min. int or float  */
	min_value: lv_subject_value_t,
	/* Maximum value for max. int or float  */
	max_value: lv_subject_value_t,
	/* Additional parameter, can be used freely by user  */
	user_data: rawptr,
	/* One of the LV_SUBJECT_TYPE_... values  */
	type: u32,
	/* String buffer size or group length  */
	size: u32,
	/* If an Observer was deleted during notification, start notifying from the beginning.  */
	notify_restart_query: u32,
}

lv_binfont_font_src_t :: struct {
	/* Size of the font in pixels  */
	font_size: u32,
	/* Path to font file  */
	path: ^u8,
	/* Address of the font file in the memory  */
	buffer: rawptr,
	/* Size of the font file buffer  */
	buffer_size: u32,
}

/* This describes a glyph.  */
lv_font_fmt_txt_glyph_dsc_t :: struct {
	/* Start index of the bitmap. A font can be max 1 MB.  */
	bitmap_index: u32,
	/* Draw the next glyph after this width. 8.4 format (real_value * 16 is stored).  */
	adv_w: u32,
	/* Width of the glyph's bounding box  */
	box_w: u8,
	/* Height of the glyph's bounding box  */
	box_h: u8,
	/* x offset of the bounding box  */
	ofs_x: i8,
	/* y offset of the bounding box. Measured from the top of the line  */
	ofs_y: i8,
}

/* Map codepoints to a glyph_dsc s Several formats are supported to optimize memory usage See https://github.com/lvgl/lv_font_conv/blob/master/doc/font_spec.md  */
lv_font_fmt_txt_cmap_t :: struct {
	/* First Unicode character for this range  */
	range_start: u32,
	/* Number of Unicode characters related to this range. Last Unicode character = range_start + range_length - 1  */
	range_length: u16,
	/* First glyph ID (array index of glyph_dsc ) for this range  */
	glyph_id_start: u16,
	unicode_list: ^u16,
	/* if(type == LV_FONT_FMT_TXT_CMAP_FORMAT0_...) it's uint8_t * if(type == LV_FONT_FMT_TXT_CMAP_SPARSE_...) it's uint16_t *  */
	glyph_id_ofs_list: rawptr,
	/* Length of unicode_list and/or glyph_id_ofs_list  */
	list_length: u16,
	/* Type of this character map  */
	type: lv_font_fmt_txt_cmap_type_t,
}

/* A simple mapping of kern values from pairs  */
lv_font_fmt_txt_kern_pair_t :: struct {
	glyph_ids: rawptr,
	values: ^i8,
	pair_cnt: u32,
	/* 0: glyph_ids is stored as uint8_t ; 1: as uint16_t  */
	glyph_ids_size: u32,
}

/* More complex but more optimal class based kern value storage  */
lv_font_fmt_txt_kern_classes_t :: struct {
	/* left_class_cnt * right_class_cnt value  */
	class_pair_values: ^i8,
	/* Map the glyph_ids to classes: index -> glyph_id -> class_id  */
	left_class_mapping: ^u8,
	/* Map the glyph_ids to classes: index -> glyph_id -> class_id  */
	right_class_mapping: ^u8,
	left_class_cnt: u8,
	right_class_cnt: u8,
}

/* Describe store for additional data for fonts  */
lv_font_fmt_txt_dsc_t :: struct {
	/* The bitmaps of all glyphs  */
	glyph_bitmap: ^u8,
	/* Describe the glyphs  */
	glyph_dsc: ^lv_font_fmt_txt_glyph_dsc_t,
	/* Map the glyphs to Unicode characters. Array of lv_font_cmap_fmt_txt_t variables  */
	cmaps: ^lv_font_fmt_txt_cmap_t,
	/* Store kerning values. Can be :ref:`lv_font_fmt_txt_kern_pair_t` * or lv_font_kern_classes_fmt_txt_t * depending on kern_classes`  */
	kern_dsc: rawptr,
	/* Scale kern values in 12.4 format  */
	kern_scale: u16,
	/* Number of cmap tables  */
	cmap_num: u16,
	/* Bit per pixel: 1, 2, 3, 4, 8  */
	bpp: u16,
	/* Type of kern_dsc  */
	kern_classes: u16,
	/* storage format of the bitmap from lv_font_fmt_txt_bitmap_format_t  */
	bitmap_format: u16,
	/* Bytes to which each line is padded. 0: means no align and padding 1: e.g. with bpp=4 lines are aligned to 1 byte, so there can be a 4 bits of padding 4, 8, 16, 32, 64: each line is padded to the given byte boundaries  */
	stride: u8,
}

lv_builtin_font_src_t :: struct {
	/* Pointer to built-in font  */
	font_p: ^lv_font_t,
	size: u32,
}

/* Represents a date on the calendar object (platform-agnostic).  */
lv_calendar_date_t :: struct {
	year: u16,
	/* 1..12  */
	month: u8,
	/* 1..31  */
	day: u8,
}

/* Coords of a span  */
lv_span_coords_t :: struct {
	heading: lv_area_t,
	middle: lv_area_t,
	trailing: lv_area_t,
}

_lv_fragment_t :: struct {
	/* Class of this fragment  */
	cls: ^lv_fragment_class_t,
	/* Managed fragment states. If not null, then this fragment is managed. 

Don't modify values inside this struct!   */
	managed: ^lv_fragment_managed_states_t,
	/* Child fragment manager  */
	child_manager: ^lv_fragment_manager_t,
	/* lv_obj returned by create_obj_cb  */
	obj: ^lv_obj_t,
}

_lv_fragment_class_t :: struct {
	/* Constructor function for fragment class  */
	constructor_cb: #type proc "c" (self: ^lv_fragment_t, args: rawptr),
	/* Destructor function for fragment class  */
	destructor_cb: #type proc "c" (self: ^lv_fragment_t),
	/* Fragment attached to manager  */
	attached_cb: #type proc "c" (self: ^lv_fragment_t),
	/* Fragment detached from manager  */
	detached_cb: #type proc "c" (self: ^lv_fragment_t),
	/* Create objects Created object, NULL if multiple objects has been created  */
	create_obj_cb: #type proc "c" (self: ^lv_fragment_t, container: ^lv_obj_t) -> ^lv_obj_t,
	obj_created_cb: #type proc "c" (self: ^lv_fragment_t, obj: ^lv_obj_t),
	/* Called before objects in the fragment will be deleted.  */
	obj_will_delete_cb: #type proc "c" (self: ^lv_fragment_t, obj: ^lv_obj_t),
	/* Called when the object created by fragment received LV_EVENT_DELETE event  */
	obj_deleted_cb: #type proc "c" (self: ^lv_fragment_t, obj: ^lv_obj_t),
	/* Handle event  */
	event_cb: #type proc "c" (self: ^lv_fragment_t, code: i32, userdata: rawptr) -> bool,
	/* REQUIRED : Allocation size of fragment  */
	instance_size: uint,
}

lv_tiny_ttf_font_src_t :: struct {
	/* Path to the font file  */
	path: ^u8,
	/* Pointer to the font data  */
	data: rawptr,
	/* Size of the font data  */
	data_size: uint,
	/* Size of the font cache  */
	cache_size: uint,
}


/*
	----------------
	 UNIONS
	----------------
*/

lv_yuv_buf_t :: struct #raw_union {
	yuv: lv_yuv_plane_t,
	planar: struct {
		y: lv_yuv_plane_t,
		u: lv_yuv_plane_t,
		v: lv_yuv_plane_t,
	},
	semi_planar: struct {
		y: lv_yuv_plane_t,
		uv: lv_yuv_plane_t,
	},
}

/* A common type to handle all the property types in the same way.  */
lv_style_value_t :: struct #raw_union {
	num: i32,
	ptr: rawptr,
	color: lv_color_t,
}

/* A common type to handle all the various observable types in the same way  */
lv_subject_value_t :: struct #raw_union {
	num: i32,
	pointer: rawptr,
	color: lv_color_t,
	float_v: f32,
}


/*
	--------------------
	 PROCEDURES
	--------------------
*/

foreign lvgl {
	/* Initialize LVGL library. Should be called before any other LVGL related function.  */
	lv_init :: proc() ---
	/* Deinit the 'lv' library  */
	lv_deinit :: proc() ---
	/* Returns whether the 'lv' library is currently initialized  */
	lv_is_initialized :: proc() -> bool ---
	/* Pointer to the destination array. The function does not check for any overlapping of the source and destination memory blocks.  */
	lv_memcpy :: proc(/* Pointer to the destination array where the content is to be copied.  */dst: rawptr, /* Pointer to the source of data to be copied.  */src: rawptr, /* Number of bytes to copy.  */len: uint) -> rawptr ---
	lv_memset :: proc(/* Pointer to the destination array to fill with the specified value.  */dst: rawptr, /* Value to be set. The value is passed as an int, but the function fills the block of memory using the unsigned char conversion of this value.  */v: u8, /* Number of bytes to be set to the value.  */len: uint) ---
	/* Pointer to the destination array.  */
	lv_memmove :: proc(/* Pointer to the destination array where the content is to be copied.  */dst: rawptr, /* Pointer to the source of data to be copied.  */src: rawptr, /* Number of bytes to copy  */len: uint) -> rawptr ---
	/* The difference between the value of the first unmatching byte.  */
	lv_memcmp :: proc(/* Pointer to the first memory block  */p1: rawptr, /* Pointer to the second memory block  */p2: rawptr, /* Number of bytes to compare  */len: uint) -> i32 ---
	/* Same as memset(dst, 0x00, len) .  */
	lv_memzero :: proc(/* pointer to the destination buffer  */dst: rawptr, /* number of byte to set  */len: uint) ---
	/* The length of the string in bytes.  */
	lv_strlen :: proc(/* Pointer to the null-terminated byte string to be examined.  */str: ^u8) -> uint ---
	/* The length of the string in bytes.  */
	lv_strnlen :: proc(/* Pointer to byte string that is null-terminated or at least max_len bytes long.  */str: ^u8, /* Maximum number of characters to examine.  */max_len: uint) -> uint ---
	/* The length of src. The return value is equivalent to the value returned by lv_strlen(src)  */
	lv_strlcpy :: proc(/* Pointer to the destination array where the content is to be copied.  */dst: ^u8, /* Pointer to the source of data to be copied.  */src: ^u8, /* Maximum number of characters to be copied to dst, including the null character.  */dst_size: uint) -> uint ---
	/* A pointer to the destination array, which is dst. dst will not be null terminated if dest_size bytes were copied from src before the end of src was reached.  */
	lv_strncpy :: proc(/* Pointer to the destination array where the content is to be copied.  */dst: ^u8, /* Pointer to the source of data to be copied.  */src: ^u8, /* Maximum number of characters to be copied to dst.  */dest_size: uint) -> ^u8 ---
	/* A pointer to the destination array, which is dst.  */
	lv_strcpy :: proc(/* Pointer to the destination array where the content is to be copied.  */dst: ^u8, /* Pointer to the source of data to be copied.  */src: ^u8) -> ^u8 ---
	/* the difference between the value of the first unmatching character.  */
	lv_strcmp :: proc(/* pointer to the first string  */s1: ^u8, /* pointer to the second string  */s2: ^u8) -> i32 ---
	/* the difference between the value of the first unmatching character.  */
	lv_strncmp :: proc(/* pointer to the first string  */s1: ^u8, /* pointer to the second string  */s2: ^u8, /* the maximum amount of characters to compare  */len: uint) -> i32 ---
	/* Returns true if the two strings are equal. Just a wrapper around strcmp for convenience. true: the strings are equal; false: otherwise  */
	lv_streq :: proc(/* pointer to the first string  */s1: ^u8, /* pointer to the second string  */s2: ^u8) -> bool ---
	/* A pointer to the new allocated string. NULL if failed.  */
	lv_strdup :: proc(/* Pointer to the source of data to be copied.  */src: ^u8) -> ^u8 ---
	/* Pointer to a newly allocated null-terminated string. NULL if failed.  */
	lv_strndup :: proc(/* Pointer to the source of data to be copied.  */src: ^u8, /* Maximum number of characters to be copied.  */max_len: uint) -> ^u8 ---
	/* A pointer to the destination string, which is dst.  */
	lv_strcat :: proc(/* Pointer to the destination string where the content is to be appended.  */dst: ^u8, /* Pointer to the source of data to be copied.  */src: ^u8) -> ^u8 ---
	/* A pointer to the destination string, which is dst.  */
	lv_strncat :: proc(/* Pointer to the destination string where the content is to be appended.  */dst: ^u8, /* Pointer to the source of data to be copied.  */src: ^u8, /* Maximum number of characters from src to be copied to the end of dst.  */src_len: uint) -> ^u8 ---
	/* A pointer to the first occurrence of character c in the string str, or a null pointer if c is not found.  */
	lv_strchr :: proc(/* Pointer to the null-terminated byte string to be searched.  */str: ^u8, /* The character to be searched for.  */c: i32) -> ^u8 ---
	/* Initialize to use malloc/free/realloc etc  */
	lv_mem_init :: proc() ---
	/* Drop all dynamically allocated memory and reset the memory pools' state  */
	lv_mem_deinit :: proc() ---
	lv_mem_add_pool :: proc(mem: rawptr, bytes: uint) -> lv_mem_pool_t ---
	lv_mem_remove_pool :: proc(pool: lv_mem_pool_t) ---
	/* Allocate memory dynamically pointer to allocated uninitialized memory, or NULL on failure  */
	lv_malloc :: proc(/* requested size in bytes  */size: uint) -> rawptr ---
	/* Allocate a block of zeroed memory dynamically pointer to allocated zeroed memory, or NULL on failure  */
	lv_calloc :: proc(/* requested number of element to be allocated.  */num: uint, /* requested size of each element in bytes.  */size: uint) -> rawptr ---
	/* Allocate zeroed memory dynamically pointer to allocated zeroed memory, or NULL on failure  */
	lv_zalloc :: proc(/* requested size in bytes  */size: uint) -> rawptr ---
	/* Allocate zeroed memory dynamically pointer to allocated zeroed memory, or NULL on failure  */
	lv_malloc_zeroed :: proc(/* requested size in bytes  */size: uint) -> rawptr ---
	/* Free an allocated data  */
	lv_free :: proc(/* pointer to an allocated memory  */data: rawptr) ---
	/* Reallocate a memory with a new size. The old content will be kept. pointer to the new memory, NULL on failure  */
	lv_realloc :: proc(/* pointer to an allocated memory. Its content will be copied to the new memory block and freed  */data_p: rawptr, /* the desired new size in byte  */new_size: uint) -> rawptr ---
	/* Reallocate a memory with a new size. The old content will be kept. In case of failure, the old pointer is free'd. pointer to the new memory, NULL on failure  */
	lv_reallocf :: proc(/* pointer to an allocated memory. Its content will be copied to the new memory block and freed  */data_p: rawptr, /* the desired new size in byte  */new_size: uint) -> rawptr ---
	/* Used internally to execute a plain malloc operation  */
	lv_malloc_core :: proc(/* size in bytes to malloc  */size: uint) -> rawptr ---
	/* Used internally to execute a plain free operation  */
	lv_free_core :: proc(/* memory address to free  */p: rawptr) ---
	/* Used internally to execute a plain realloc operation  */
	lv_realloc_core :: proc(/* memory address to realloc  */p: rawptr, /* size in bytes to realloc  */new_size: uint) -> rawptr ---
	/* Used internally by :ref:`lv_mem_monitor()` to gather LVGL heap state information.  */
	lv_mem_monitor_core :: proc(/* pointer to :ref:`lv_mem_monitor_t` object to be populated.  */mon_p: ^lv_mem_monitor_t) ---
	lv_mem_test_core :: proc() -> lv_result_t ---
	/* LV_RESULT_OK if the memory allocation system is working properly, or LV_RESULT_INVALID if there is an error.  */
	lv_mem_test :: proc() -> lv_result_t ---
	/* Give information about the work memory of dynamic allocation  */
	lv_mem_monitor :: proc(/* pointer to a :ref:`lv_mem_monitor_t` variable, the result of the analysis will be stored here  */mon_p: ^lv_mem_monitor_t) ---
	lv_snprintf :: proc(buffer: ^u8, count: uint, format: ^u8, #c_vararg args: ..any) -> i32 ---
	lv_vsnprintf :: proc(buffer: ^u8, count: uint, format: ^u8, va: c.va_list) -> i32 ---
	/* Register custom print/write function to call when a log is added. It can format its "File path", "Line number" and "Description" as required and send the formatted log message to a console or serial port.  */
	lv_log_register_print_cb :: proc(/* a function pointer to print a log  */print_cb: lv_log_print_g_cb_t) ---
	/* Print a log message via printf if enabled with LV_LOG_PRINTF in lv_conf.h and/or a print callback if registered with lv_log_register_print_cb  */
	lv_log :: proc(/* printf-like format string  */format: ^u8, #c_vararg args: ..any) ---
	/* Add a log  */
	lv_log_add :: proc(/* the level of log. (From lv_log_level_t enum)  */level: lv_log_level_t, /* name of the file when the log added  */file: ^u8, /* line number in the source code where the log added  */line: i32, /* name of the function when the log added  */func: ^u8, /* printf-like format string  */format: ^u8, #c_vararg args: ..any) ---
	/* You have to call this function periodically. It is typically safe to call from an interrupt handler or a different thread.  */
	lv_tick_inc :: proc(/* the call period of this function in milliseconds  */tick_period: u32) ---
	/* Get the elapsed milliseconds since start up the elapsed milliseconds  */
	lv_tick_get :: proc() -> u32 ---
	/* Get the elapsed milliseconds since a previous time stamp the elapsed milliseconds since 'prev_tick'  */
	lv_tick_elaps :: proc(/* a previous time stamp (return value of :ref:`lv_tick_get()` )  */prev_tick: u32) -> u32 ---
	/* Get the elapsed milliseconds between two time stamps the elapsed milliseconds between prev_tick and tick  */
	lv_tick_diff :: proc(/* a time stamp  */tick: u32, /* a time stamp before tick  */prev_tick: u32) -> u32 ---
	/* Delay for the given milliseconds. By default it's a blocking delay, but with :ref:`lv_delay_set_cb()` a custom delay function can be set too  */
	lv_delay_ms :: proc(/* the number of milliseconds to delay  */ms: u32) ---
	/* Set a callback for a blocking delay  */
	lv_delay_set_cb :: proc(/* pointer to a callback  */cb: lv_delay_cb_t) ---
	/* Set the custom callback for 'lv_tick_get'  */
	lv_tick_set_cb :: proc(/* call this callback on 'lv_tick_get'  */cb: lv_tick_get_cb_t) ---
	/* Get the custom callback for 'lv_tick_get' call this callback on 'lv_tick_get'  */
	lv_tick_get_cb :: proc() -> lv_tick_get_cb_t ---
	/* Initialize linked list  */
	lv_ll_init :: proc(/* pointer to :ref:`lv_ll_t` variable  */ll_p: ^lv_ll_t, /* the size of 1 node in bytes  */node_size: u32) ---
	/* Add a new head to a linked list pointer to the new head  */
	lv_ll_ins_head :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t) -> rawptr ---
	/* Insert a new node in front of the n_act node pointer to the new node  */
	lv_ll_ins_prev :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t, /* pointer a node  */n_act: rawptr) -> rawptr ---
	/* Add a new tail to a linked list pointer to the new tail  */
	lv_ll_ins_tail :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t) -> rawptr ---
	/* Remove the node 'node_p' from 'll_p' linked list. It does not free the memory of node.  */
	lv_ll_remove :: proc(/* pointer to the linked list of 'node_p'  */ll_p: ^lv_ll_t, /* pointer to node in 'll_p' linked list  */node_p: rawptr) ---
	lv_ll_clear_custom :: proc(ll_p: ^lv_ll_t, cleanup: #type proc "c" (arg0: rawptr)) ---
	/* Remove and free all elements from a linked list. The list remain valid but become empty.  */
	lv_ll_clear :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t) ---
	/* Move a node to a new linked list  */
	lv_ll_chg_list :: proc(/* pointer to the original (old) linked list  */ll_ori_p: ^lv_ll_t, /* pointer to the new linked list  */ll_new_p: ^lv_ll_t, /* pointer to a node  */node: rawptr, /* true: be the head in the new list false be the tail in the new list  */head: bool) ---
	/* Return with head node of the linked list pointer to the head of 'll_p'  */
	lv_ll_get_head :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t) -> rawptr ---
	/* Return with tail node of the linked list pointer to the tail of 'll_p'  */
	lv_ll_get_tail :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t) -> rawptr ---
	/* Return with the pointer of the next node after 'n_act' pointer to the next node  */
	lv_ll_get_next :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t, /* pointer a node  */n_act: rawptr) -> rawptr ---
	/* Return with the pointer of the previous node after 'n_act' pointer to the previous node  */
	lv_ll_get_prev :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t, /* pointer a node  */n_act: rawptr) -> rawptr ---
	/* Return the length of the linked list. length of the linked list  */
	lv_ll_get_len :: proc(/* pointer to linked list  */ll_p: ^lv_ll_t) -> u32 ---
	/* Move a node before another node in the same linked list  */
	lv_ll_move_before :: proc(/* pointer to a linked list  */ll_p: ^lv_ll_t, /* pointer to node to move  */n_act: rawptr, /* pointer to a node which should be after n_act  */n_after: rawptr) ---
	/* Check if a linked list is empty true: the linked list is empty; false: not empty  */
	lv_ll_is_empty :: proc(/* pointer to a linked list  */ll_p: ^lv_ll_t) -> bool ---
	/* Call it periodically to handle lv_timers. time till it needs to be run next (in ms)  */
	lv_timer_handler :: proc() -> u32 ---
	/* Call it in the super-loop of main() or threads. It will run :ref:`lv_timer_handler()` with a given period in ms. You can use it with sleep or delay in OS environment. This function is used to simplify the porting. the time after which it must be called again  */
	lv_timer_handler_run_in_period :: proc(/* the period for running :ref:`lv_timer_handler()`  */period: u32) -> u32 ---
	/* Call it in the super-loop of main() or threads. It will automatically call :ref:`lv_timer_handler()` at the right time. This function is used to simplify the porting.  */
	lv_timer_periodic_handler :: proc() ---
	/* Set the resume callback to the timer handler  */
	lv_timer_handler_set_resume_cb :: proc(/* the function to call when timer handler is resumed  */cb: lv_timer_handler_resume_cb_t, /* pointer to a resume data  */data: rawptr) ---
	/* Create an "empty" timer. It needs to be initialized with at least lv_timer_set_cb and lv_timer_set_period  pointer to the created timer  */
	lv_timer_create_basic :: proc() -> ^lv_timer_t ---
	/* Create a new lv_timer pointer to the new timer  */
	lv_timer_create :: proc(/* a callback to call periodically. (the 'x' in the argument name indicates that it's not a fully generic function because it not follows the func_name(object, callback, ...) convention)  */timer_xcb: lv_timer_cb_t, /* call period in ms unit  */period: u32, /* custom parameter  */user_data: rawptr) -> ^lv_timer_t ---
	/* Delete a lv_timer  */
	lv_timer_delete :: proc(/* pointer to an lv_timer  */timer: ^lv_timer_t) ---
	/* Pause a timer. It is typically safe to call from an interrupt handler or a different thread.  */
	lv_timer_pause :: proc(/* pointer to an lv_timer  */timer: ^lv_timer_t) ---
	/* Resume a timer.  */
	lv_timer_resume :: proc(/* pointer to an lv_timer  */timer: ^lv_timer_t) ---
	/* Set the callback to the timer (the function to call periodically)  */
	lv_timer_set_cb :: proc(/* pointer to a timer  */timer: ^lv_timer_t, /* the function to call periodically  */timer_cb: lv_timer_cb_t) ---
	/* Set new period for a lv_timer  */
	lv_timer_set_period :: proc(/* pointer to a lv_timer  */timer: ^lv_timer_t, /* the new period  */period: u32) ---
	/* Make a lv_timer ready. It will not wait its period.  */
	lv_timer_ready :: proc(/* pointer to a lv_timer.  */timer: ^lv_timer_t) ---
	/* Set the number of times a timer will repeat.  */
	lv_timer_set_repeat_count :: proc(/* pointer to a lv_timer.  */timer: ^lv_timer_t, /* -1 : infinity; 0 : stop ; n>0: residual times  */repeat_count: i32) ---
	/* Set whether a lv_timer will be deleted automatically when it is called repeat_count times.  */
	lv_timer_set_auto_delete :: proc(/* pointer to a lv_timer.  */timer: ^lv_timer_t, /* true: auto delete; false: timer will be paused when it is called repeat_count times.  */auto_delete: bool) ---
	/* Set custom parameter to the lv_timer.  */
	lv_timer_set_user_data :: proc(/* pointer to a lv_timer.  */timer: ^lv_timer_t, /* custom parameter  */user_data: rawptr) ---
	/* Reset a lv_timer. It will be called the previously set period milliseconds later.  */
	lv_timer_reset :: proc(/* pointer to a lv_timer.  */timer: ^lv_timer_t) ---
	/* Enable or disable the whole lv_timer handling  */
	lv_timer_enable :: proc(/* true: lv_timer handling is running, false: lv_timer handling is suspended  */en: bool) ---
	/* Get idle percentage the lv_timer idle in percentage  */
	lv_timer_get_idle :: proc() -> u32 ---
	/* Get the time remaining until the next timer will run the time remaining in ms  */
	lv_timer_get_time_until_next :: proc() -> u32 ---
	/* Iterate through the timers the next timer or NULL if there is no more timer  */
	lv_timer_get_next :: proc(/* NULL to start iteration or the previous return value to get the next timer  */timer: ^lv_timer_t) -> ^lv_timer_t ---
	/* Get the user_data passed when the timer was created pointer to the user_data  */
	lv_timer_get_user_data :: proc(/* pointer to the lv_timer  */timer: ^lv_timer_t) -> rawptr ---
	/* Get the pause state of a timer true: timer is paused; false: timer is running  */
	lv_timer_get_paused :: proc(/* pointer to a lv_timer  */timer: ^lv_timer_t) -> bool ---
	/* Return with sinus of an angle sinus of 'angle'. sin(-90) = -32767, sin(90) = 32767  */
	lv_trigo_sin :: proc(angle: i16) -> i32 ---
	lv_trigo_cos :: proc(angle: i16) -> i32 ---
	/* Calculate the y value of cubic-bezier(x1, y1, x2, y2) function as specified x. the value calculated  */
	lv_cubic_bezier :: proc(/* time in range of [0..LV_BEZIER_VAL_MAX]  */x: i32, /* x of control point 1 in range of [0..LV_BEZIER_VAL_MAX]  */x1: i32, /* y of control point 1 in range of [0..LV_BEZIER_VAL_MAX]  */y1: i32, /* x of control point 2 in range of [0..LV_BEZIER_VAL_MAX]  */x2: i32, /* y of control point 2 in range of [0..LV_BEZIER_VAL_MAX]  */y2: i32) -> i32 ---
	/* Calculate a value of a Cubic Bezier function. the value calculated from the given parameters in range of [0..LV_BEZIER_VAL_MAX]  */
	lv_bezier3 :: proc(/* time in range of [0..LV_BEZIER_VAL_MAX]  */t: i32, /* must be 0  */u0: i32, /* control value 1 values in range of [0..LV_BEZIER_VAL_MAX]  */u1: u32, /* control value 2 in range of [0..LV_BEZIER_VAL_MAX]  */u2: i32, /* must be LV_BEZIER_VAL_MAX  */u3: i32) -> i32 ---
	/* Calculate the atan2 of a vector. the angle in degree calculated from the given parameters in range of [0..360]  */
	lv_atan2 :: proc(x: i32, y: i32) -> u16 ---
	/* Get the square root of a number  */
	lv_sqrt :: proc(/* integer which square root should be calculated  */x: u32, /* store the result here. q->i: integer part, q->f: fractional part in 1/256 unit  */q: ^lv_sqrt_res_t, /* optional to skip some iterations if the magnitude of the root is known. Set to 0x8000 by default. If root < 16: mask = 0x80 If root < 256: mask = 0x800 Else: mask = 0x8000  */mask: u32) ---
	/* Alternative (fast, approximate) implementation for getting the square root of an integer.  */
	lv_sqrt32 :: proc(/* integer which square root should be calculated  */x: u32) -> i32 ---
	/* Calculate the square of an integer (input range is 0..32767). square  */
	lv_sqr :: proc(/* input  */x: i32) -> i32 ---
	/* Calculate the integer exponents. base raised to the power exponent  */
	lv_pow :: proc(base: i64, exp: i8) -> i64 ---
	/* Get the mapped of a number given an input and output range the mapped number  */
	lv_map :: proc(/* integer which mapped value should be calculated  */x: i32, /* min input range  */min_in: i32, /* max input range  */max_in: i32, /* max output range  */min_out: i32, /* max output range  */max_out: i32) -> i32 ---
	/* Set the seed of the pseudo random number generator  */
	lv_rand_set_seed :: proc(/* a number to initialize the random generator  */seed: u32) ---
	/* Get a pseudo random number in the given range return the random number. min <= return_value <= max  */
	lv_rand :: proc(/* the minimum value  */min: u32, /* the maximum value  */max: u32) -> u32 ---
	/* Init an array.  */
	lv_array_init :: proc(/* pointer to an lv_array_t variable to initialize  */array: ^lv_array_t, /* the initial capacity of the array  */capacity: u32, /* the size of an element in bytes  */element_size: u32) ---
	/* Init an array from a buffer. The buffer must be large enough to store capacity elements. The array will not release the buffer and reallocate it. The user must ensure that the buffer is valid during the lifetime of the array. And release the buffer when the array is no longer needed.  */
	lv_array_init_from_buf :: proc(/* pointer to an lv_array_t variable to initialize  */array: ^lv_array_t, /* pointer to a buffer to use as the array's data  */buf: rawptr, /* the initial capacity of the array  */capacity: u32, /* the size of an element in bytes  */element_size: u32) ---
	/* Resize the array to the given capacity. if the new capacity is smaller than the current size, the array will be truncated.  */
	lv_array_resize :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t, /* the new capacity of the array  */new_capacity: u32) -> bool ---
	/* Deinit the array, and free the allocated memory  */
	lv_array_deinit :: proc(/* pointer to an lv_array_t variable to deinitialize  */array: ^lv_array_t) ---
	/* Return how many elements are stored in the array. the number of elements stored in the array  */
	lv_array_size :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t) -> u32 ---
	/* Return the capacity of the array, i.e. how many elements can be stored. the capacity of the array  */
	lv_array_capacity :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t) -> u32 ---
	/* Return if the array is empty true: array is empty; false: array is not empty  */
	lv_array_is_empty :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t) -> bool ---
	/* Return if the array is full true: array is full; false: array is not full  */
	lv_array_is_full :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t) -> bool ---
	/* Copy an array to another. this will create a new array with the same capacity and size as the source array.  */
	lv_array_copy :: proc(/* pointer to an lv_array_t variable to copy to  */target: ^lv_array_t, /* pointer to an lv_array_t variable to copy from  */source: ^lv_array_t) ---
	/* Remove all elements in array.  */
	lv_array_clear :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t) ---
	/* Shrink the memory capacity of array if necessary.  */
	lv_array_shrink :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t) ---
	/* Remove the element at the specified position in the array. 

This function keeps the array order. Complexity is O(n)  

LV_RESULT_OK: success, otherwise: error   */
	lv_array_remove :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t, /* the index of the element to remove  */index: u32) -> lv_result_t ---
	/* Remove the element at the specified position in the array. 

This function does not guarantee the array order. Complexity is O(1)  

LV_RESULT_OK: success, otherwise: error   */
	lv_array_remove_unordered :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t, /* the index of the element to remove  */index: u32) -> lv_result_t ---
	/* Remove from the array either a single element or a range of elements ([start, end)). This effectively reduces the container size by the number of elements removed.  When start equals to end, the function has no effect.  LV_RESULT_OK: success, otherwise: error  */
	lv_array_erase :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t, /* the index of the first element to be removed  */start: u32, /* the index of the first element that is not to be removed  */end: u32) -> lv_result_t ---
	/* Concatenate two arrays. Adds new elements to the end of the array. The destination array is automatically expanded as necessary.  LV_RESULT_OK: success, otherwise: error  */
	lv_array_concat :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t, /* pointer to the array to concatenate  */other: ^lv_array_t) -> lv_result_t ---
	/* Push back element. Adds a new element to the end of the array. If the array capacity is not enough for the new element, the array will be resized automatically. If the element is NULL, it will be added as an empty element.  LV_RESULT_OK: success, otherwise: error  */
	lv_array_push_back :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t, /* pointer to the element to add. NULL to push an empty element.  */element: rawptr) -> lv_result_t ---
	/* Assigns one content to the array, replacing its current content. true: success; false: error  */
	lv_array_assign :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t, /* the index of the element to replace  */index: u32, /* pointer to the elements to add  */value: rawptr) -> lv_result_t ---
	/* Returns a pointer to the element at position n in the array. a pointer to the requested element, NULL if index is out of range  */
	lv_array_at :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t, /* the index of the element to return  */index: u32) -> rawptr ---
	/* Returns a pointer to the first element in the array. a pointer to the first element in the array  */
	lv_array_front :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t) -> rawptr ---
	/* Returns a pointer to the last element in the array.  */
	lv_array_back :: proc(/* pointer to an lv_array_t variable  */array: ^lv_array_t) -> rawptr ---
	/* Call an asynchronous function the next time :ref:`lv_timer_handler()` is run. This function is likely to return before the call actually happens!  */
	lv_async_call :: proc(/* a callback which is the task itself. (the 'x' in the argument name indicates that it's not a fully generic function because it not follows the func_name(object, callback, ...) convention)  */async_xcb: lv_async_cb_t, /* custom parameter  */user_data: rawptr) -> lv_result_t ---
	/* Cancel an asynchronous function call  */
	lv_async_call_cancel :: proc(/* a callback which is the task itself.  */async_xcb: lv_async_cb_t, /* custom parameter  */user_data: rawptr) -> lv_result_t ---
	/* Initialize an animation variable. E.g.: lv_anim_t a; lv_anim_init(&a); lv_anim_set_...(&a); lv_anim_start(&a);  */
	lv_anim_init :: proc(/* pointer to an lv_anim_t variable to initialize  */a: ^lv_anim_t) ---
	/* Set a variable to animate  */
	lv_anim_set_var :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* pointer to a variable to animate  */var: rawptr) ---
	/* Set a function to animate var  */
	lv_anim_set_exec_cb :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* a function to execute during animation LVGL's built-in functions can be used. E.g. lv_obj_set_x  */exec_cb: lv_anim_exec_xcb_t) ---
	/* Set the duration of an animation  */
	lv_anim_set_duration :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* duration of the animation in milliseconds  */duration: u32) ---
	/* Set a delay before starting the animation  */
	lv_anim_set_delay :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* delay before the animation in milliseconds  */delay: u32) ---
	/* Resumes a paused animation  */
	lv_anim_resume :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t) ---
	/* Pauses the animation  */
	lv_anim_pause :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t) ---
	/* Pauses the animation for ms milliseconds  */
	lv_anim_pause_for :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* the pause time in milliseconds  */ms: u32) ---
	/* Check if the animation is paused true if the animation is paused else false  */
	lv_anim_is_paused :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t) -> bool ---
	/* Set the start and end values of an animation  */
	lv_anim_set_values :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* the start value  */start: i32, /* the end value  */end: i32) ---
	/* Similar to lv_anim_set_exec_cb but lv_anim_custom_exec_cb_t receives lv_anim_t * as its first parameter instead of void * . This function might be used when LVGL is bound to other languages because it's more consistent to have lv_anim_t * as first parameter.  */
	lv_anim_set_custom_exec_cb :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* a function to execute.  */exec_cb: lv_anim_custom_exec_cb_t) ---
	/* Set the path (curve) of the animation.  */
	lv_anim_set_path_cb :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* a function to set the current value of the animation.  */path_cb: lv_anim_path_cb_t) ---
	/* Set a function call when the animation really starts (considering delay )  */
	lv_anim_set_start_cb :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* a function call when the animation starts  */start_cb: lv_anim_start_cb_t) ---
	/* Set a function to use the current value of the variable and make start and end value relative to the returned current value.  */
	lv_anim_set_get_value_cb :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* a function call when the animation starts  */get_value_cb: lv_anim_get_value_cb_t) ---
	/* Set a function call when the animation is completed  */
	lv_anim_set_completed_cb :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* a function call when the animation is fully completed  */completed_cb: lv_anim_completed_cb_t) ---
	/* Set a function call when the animation is deleted.  */
	lv_anim_set_deleted_cb :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* a function call when the animation is deleted  */deleted_cb: lv_anim_deleted_cb_t) ---
	/* Make the animation to play back to when the forward direction is ready  */
	lv_anim_set_reverse_duration :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* duration of playback animation in milliseconds. 0: disable playback  */duration: u32) ---
	/* Legacy lv_anim_set_reverse_time API will be removed soon, use lv_anim_set_reverse_duration instead.  */
	lv_anim_set_reverse_time :: proc(a: ^lv_anim_t, duration: u32) ---
	/* Make the animation to play back to when the forward direction is ready  */
	lv_anim_set_reverse_delay :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* delay in milliseconds before starting the playback animation.  */delay: u32) ---
	/* Make the animation repeat itself.  */
	lv_anim_set_repeat_count :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* repeat count or LV_ANIM_REPEAT_INFINITE for infinite repetition. 0: to disable repetition.  */cnt: u32) ---
	/* Set a delay before repeating the animation.  */
	lv_anim_set_repeat_delay :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* delay in milliseconds before repeating the animation.  */delay: u32) ---
	/* Set a whether the animation's should be applied immediately or only when the delay expired.  */
	lv_anim_set_early_apply :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* true: apply the start value immediately in lv_anim_start ; false: apply the start value only when delay ms is elapsed and the animations really starts  */en: bool) ---
	/* Set the custom user data field of the animation.  */
	lv_anim_set_user_data :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* pointer to the new user_data.  */user_data: rawptr) ---
	/* Set parameter for cubic bezier path  */
	lv_anim_set_bezier3_param :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t, /* first control point X  */x1: i16, /* first control point Y  */y1: i16, /* second control point X  */x2: i16, /* second control point Y  */y2: i16) ---
	/* Create an animation pointer to the created animation (different from the a parameter)  */
	lv_anim_start :: proc(/* an initialized 'anim_t' variable. Not required after call.  */a: ^lv_anim_t) -> ^lv_anim_t ---
	/* Get a delay before starting the animation delay before the animation in milliseconds  */
	lv_anim_get_delay :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t) -> u32 ---
	/* Get the time used to play the animation. the play time in milliseconds.  */
	lv_anim_get_playtime :: proc(/* pointer to an animation.  */a: ^lv_anim_t) -> u32 ---
	/* Get the duration of an animation the duration of the animation in milliseconds  */
	lv_anim_get_time :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t) -> u32 ---
	/* Get the repeat count of the animation. the repeat count or LV_ANIM_REPEAT_INFINITE for infinite repetition. 0: disabled repetition.  */
	lv_anim_get_repeat_count :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t) -> u32 ---
	/* Get the user_data field of the animation the pointer to the custom user_data of the animation  */
	lv_anim_get_user_data :: proc(/* pointer to an initialized lv_anim_t variable  */a: ^lv_anim_t) -> rawptr ---
	/* Delete animation(s) of a variable with a given animator function true: at least 1 animation is deleted, false: no animation is deleted  */
	lv_anim_delete :: proc(/* pointer to variable  */var: rawptr, /* a function pointer which is animating 'var', or NULL to ignore it and delete all the animations of 'var  */exec_cb: lv_anim_exec_xcb_t) -> bool ---
	/* Delete all the animations  */
	lv_anim_delete_all :: proc() ---
	/* Get the animation of a variable and its exec_cb . pointer to the animation.  */
	lv_anim_get :: proc(/* pointer to variable  */var: rawptr, /* a function pointer which is animating 'var', or NULL to return first matching 'var'  */exec_cb: lv_anim_exec_xcb_t) -> ^lv_anim_t ---
	/* Get global animation refresher timer. pointer to the animation refresher timer.  */
	lv_anim_get_timer :: proc() -> ^lv_timer_t ---
	/* Delete an animation by getting the animated variable from a . Only animations with exec_cb will be deleted. This function exists because it's logical that all anim. functions receives an lv_anim_t as their first parameter. It's not practical in C but might make the API more consequent and makes easier to generate bindings. true: at least 1 animation is deleted, false: no animation is deleted  */
	lv_anim_custom_delete :: proc(/* pointer to an animation.  */a: ^lv_anim_t, /* a function pointer which is animating 'var', or NULL to ignore it and delete all the animations of 'var  */exec_cb: lv_anim_custom_exec_cb_t) -> bool ---
	/* Get the animation of a variable and its exec_cb . This function exists because it's logical that all anim. functions receives an lv_anim_t as their first parameter. It's not practical in C but might make the API more consequent and makes easier to generate bindings. pointer to the animation.  */
	lv_anim_custom_get :: proc(/* pointer to an animation.  */a: ^lv_anim_t, /* a function pointer which is animating 'var', or NULL to return first matching 'var'  */exec_cb: lv_anim_custom_exec_cb_t) -> ^lv_anim_t ---
	/* Get the number of currently running animations the number of running animations  */
	lv_anim_count_running :: proc() -> u16 ---
	/* Store the speed as a special value which can be used as time in animations. It will be converted to time internally based on the start and end values. The return value can be used as a constant with multiple animations and let LVGL convert the speed to time based on the actual values. LIMITATION: the max time stored this way can be 10,000 ms. a special value which can be used as an animation time  internally speed is stored as 10 unit/sec  */
	lv_anim_speed :: proc(/* the speed of the animation in with unit / sec resolution in 0..10k range  */speed: u32) -> u32 ---
	/* Store the speed as a special value which can be used as time in animations. It will be converted to time internally based on the start and end values. The return value can be used as a constant with multiple animations and let LVGL convert the speed to time based on the actual values. a special value in where all three values are stored and can be used as an animation time  internally speed is stored as 10 unit/sec  internally min/max_time are stored with 10 ms unit  */
	lv_anim_speed_clamped :: proc(/* the speed of the animation in as unit / sec resolution in 0..10k range  */speed: u32, /* the minimum time in 0..10k range  */min_time: u32, /* the maximum time in 0..10k range  */max_time: u32) -> u32 ---
	/* Resolve the speed (created with lv_anim_speed or lv_anim_speed_clamped ) to time based on start and end values. the time required to get from start to end with the given speed setting  */
	lv_anim_resolve_speed :: proc(/* return values of lv_anim_speed or lv_anim_speed_clamped  */speed: u32, /* the start value of the animation  */start: i32, /* the end value of the animation  */end: i32) -> u32 ---
	/* Calculate the time of an animation based on its speed, start and end values. It simpler than lv_anim_speed or lv_anim_speed_clamped as it converts speed, start, and end to a time immediately. As it's simpler there is no limit on the maximum time. the time of the animation in milliseconds  */
	lv_anim_speed_to_time :: proc(/* the speed of the animation  */speed: u32, /* the start value  */start: i32, /* the end value  */end: i32) -> u32 ---
	/* Manually refresh the state of the animations. Useful to make the animations running in a blocking process where lv_timer_handler can't run for a while. Shouldn't be used directly because it is called in :ref:`lv_refr_now()` .  */
	lv_anim_refr_now :: proc() ---
	/* Calculate the current value of an animation applying linear characteristic the current value to set  */
	lv_anim_path_linear :: proc(/* pointer to an animation  */a: ^lv_anim_t) -> i32 ---
	/* Calculate the current value of an animation slowing down the start phase the current value to set  */
	lv_anim_path_ease_in :: proc(/* pointer to an animation  */a: ^lv_anim_t) -> i32 ---
	/* Calculate the current value of an animation slowing down the end phase the current value to set  */
	lv_anim_path_ease_out :: proc(/* pointer to an animation  */a: ^lv_anim_t) -> i32 ---
	/* Calculate the current value of an animation applying an "S" characteristic (cosine) the current value to set  */
	lv_anim_path_ease_in_out :: proc(/* pointer to an animation  */a: ^lv_anim_t) -> i32 ---
	/* Calculate the current value of an animation with overshoot at the end the current value to set  */
	lv_anim_path_overshoot :: proc(/* pointer to an animation  */a: ^lv_anim_t) -> i32 ---
	/* Calculate the current value of an animation with 3 bounces the current value to set  */
	lv_anim_path_bounce :: proc(/* pointer to an animation  */a: ^lv_anim_t) -> i32 ---
	/* Calculate the current value of an animation applying step characteristic. (Set end value on the end of the animation) the current value to set  */
	lv_anim_path_step :: proc(/* pointer to an animation  */a: ^lv_anim_t) -> i32 ---
	/* A custom cubic bezier animation path, need to specify cubic-parameters in a->parameter.bezier3 the current value to set  */
	lv_anim_path_custom_bezier3 :: proc(/* pointer to an animation  */a: ^lv_anim_t) -> i32 ---
	/* Create an animation timeline. pointer to the animation timeline.  */
	lv_anim_timeline_create :: proc() -> ^lv_anim_timeline_t ---
	/* Delete animation timeline.  */
	lv_anim_timeline_delete :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) ---
	/* Add animation to the animation timeline.  */
	lv_anim_timeline_add :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t, /* the time the animation started on the timeline, note that start_time will override the value of delay.  */start_time: u32, /* pointer to an animation.  */a: ^lv_anim_t) ---
	/* Start the animation timeline. total time spent in animation timeline.  */
	lv_anim_timeline_start :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) -> u32 ---
	/* Pause the animation timeline.  */
	lv_anim_timeline_pause :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) ---
	/* Set the playback direction of the animation timeline.  */
	lv_anim_timeline_set_reverse :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t, /* whether to play in reverse.  */reverse: bool) ---
	/* Set the time to wait before starting the animation. Applies only when playing from the very start, or reverse from the very end.  */
	lv_anim_timeline_set_delay :: proc(/* pointer to an animation timeline  */at: ^lv_anim_timeline_t, /* the delay time in milliseconds  */delay: u32) ---
	/* Make the animation timeline repeat itself.  */
	lv_anim_timeline_set_repeat_count :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t, /* repeat count or LV_ANIM_REPEAT_INFINITE for infinite repetition. 0: to disable repetition.  */cnt: u32) ---
	/* Set a delay before repeating the animation timeline.  */
	lv_anim_timeline_set_repeat_delay :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t, /* delay in milliseconds before repeating the animation timeline.  */delay: u32) ---
	/* Set the progress of the animation timeline.  */
	lv_anim_timeline_set_progress :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t, /* set value 0~65535 to map 0~100% animation progress.  */progress: u16) ---
	/* Set the user_data of a an animation timeline  */
	lv_anim_timeline_set_user_data :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t, /* pointer to any data. Only the pointer will be saved.  */user_data: rawptr) ---
	/* Get the time used to play the animation timeline. total time spent in animation timeline.  */
	lv_anim_timeline_get_playtime :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) -> u32 ---
	/* Get whether the animation timeline is played in reverse. return true if it is reverse playback.  */
	lv_anim_timeline_get_reverse :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) -> bool ---
	/* Get the wait time when playing from the very start, or reverse from the very end. the remaining time in milliseconds  */
	lv_anim_timeline_get_delay :: proc(/* pointer to an animation timeline  */at: ^lv_anim_timeline_t) -> u32 ---
	/* Get the progress of the animation timeline. return value 0~65535 to map 0~100% animation progress.  */
	lv_anim_timeline_get_progress :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) -> u16 ---
	/* Get repeat count of the animation timeline.  */
	lv_anim_timeline_get_repeat_count :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) -> u32 ---
	/* Get repeat delay of the animation timeline.  */
	lv_anim_timeline_get_repeat_delay :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) -> u32 ---
	/* Get the user_data of a an animation timeline  */
	lv_anim_timeline_get_user_data :: proc(/* pointer to the animation timeline.  */at: ^lv_anim_timeline_t) -> rawptr ---
	/* Merge (add) all animations of a timeline to another  */
	lv_anim_timeline_merge :: proc(/* merge animation into this timeline  */dest: ^lv_anim_timeline_t, /* merge the animations of this timeline  */src: ^lv_anim_timeline_t, /* add the animations with this extra delay  */delay: i32) ---
	lv_rb_init :: proc(tree: ^lv_rb_t, compare: lv_rb_compare_t, node_size: uint) -> bool ---
	lv_rb_insert :: proc(tree: ^lv_rb_t, key: rawptr) -> ^lv_rb_node_t ---
	lv_rb_find :: proc(tree: ^lv_rb_t, key: rawptr) -> ^lv_rb_node_t ---
	lv_rb_remove_node :: proc(tree: ^lv_rb_t, node: ^lv_rb_node_t) -> rawptr ---
	lv_rb_remove :: proc(tree: ^lv_rb_t, key: rawptr) -> rawptr ---
	lv_rb_drop_node :: proc(tree: ^lv_rb_t, node: ^lv_rb_node_t) -> bool ---
	lv_rb_drop :: proc(tree: ^lv_rb_t, key: rawptr) -> bool ---
	lv_rb_minimum :: proc(node: ^lv_rb_t) -> ^lv_rb_node_t ---
	lv_rb_maximum :: proc(node: ^lv_rb_t) -> ^lv_rb_node_t ---
	lv_rb_minimum_from :: proc(node: ^lv_rb_node_t) -> ^lv_rb_node_t ---
	lv_rb_maximum_from :: proc(node: ^lv_rb_node_t) -> ^lv_rb_node_t ---
	lv_rb_destroy :: proc(tree: ^lv_rb_t) ---
	/* Initialize an area  */
	lv_area_set :: proc(/* pointer to an area  */area_p: ^lv_area_t, /* left coordinate of the area  */x1: i32, /* top coordinate of the area  */y1: i32, /* right coordinate of the area  */x2: i32, /* bottom coordinate of the area  */y2: i32) ---
	/* Copy an area  */
	lv_area_copy :: proc(/* pointer to the destination area  */dest: ^lv_area_t, /* pointer to the source area  */src: ^lv_area_t) ---
	/* Get the width of an area the width of the area (if x1 == x2 -> width = 1)  */
	lv_area_get_width :: proc(/* pointer to an area  */area_p: ^lv_area_t) -> i32 ---
	/* Get the height of an area the height of the area (if y1 == y2 -> height = 1)  */
	lv_area_get_height :: proc(/* pointer to an area  */area_p: ^lv_area_t) -> i32 ---
	/* Set the width of an area  */
	lv_area_set_width :: proc(/* pointer to an area  */area_p: ^lv_area_t, /* the new width of the area (w == 1 makes x1 == x2)  */w: i32) ---
	/* Set the height of an area  */
	lv_area_set_height :: proc(/* pointer to an area  */area_p: ^lv_area_t, /* the new height of the area (h == 1 makes y1 == y2)  */h: i32) ---
	/* Return with area of an area (x * y) size of area  */
	lv_area_get_size :: proc(/* pointer to an area  */area_p: ^lv_area_t) -> u32 ---
	lv_area_increase :: proc(area: ^lv_area_t, w_extra: i32, h_extra: i32) ---
	lv_area_move :: proc(area: ^lv_area_t, x_ofs: i32, y_ofs: i32) ---
	/* Align an area to another  */
	lv_area_align :: proc(/* an area where the other will be aligned  */base: ^lv_area_t, /* the area to align  */to_align: ^lv_area_t, /* LV_ALIGN_...  */align: lv_align_t, /* X offset  */ofs_x: i32, /* Y offset  */ofs_y: i32) ---
	/* Transform a point  */
	lv_point_transform :: proc(/* pointer to a point  */point: ^lv_point_t, /* angle with 0.1 resolutions (123 means 12.3)  */angle: i32, /* horizontal zoom, 256 means 100%  */scale_x: i32, /* vertical zoom, 256 means 100%  */scale_y: i32, /* pointer to the pivot point of the transformation  */pivot: ^lv_point_t, /* true: zoom first and rotate after that; else: opposite order  */zoom_first: bool) ---
	/* Transform an array of points  */
	lv_point_array_transform :: proc(/* pointer to an array of points  */points: ^lv_point_t, /* number of points in the array  */count: uint, /* angle with 0.1 resolutions (123 means 12.3)  */angle: i32, /* horizontal zoom, 256 means 100%  */scale_x: i32, /* vertical zoom, 256 means 100%  */scale_y: i32, /* pointer to the pivot point of the transformation  */pivot: ^lv_point_t, /* true: zoom first and rotate after that; else: opposite order  */zoom_first: bool) ---
	lv_point_from_precise :: proc(p: ^lv_point_precise_t) -> lv_point_t ---
	lv_point_to_precise :: proc(p: ^lv_point_t) -> lv_point_precise_t ---
	lv_point_set :: proc(p: ^lv_point_t, x: i32, y: i32) ---
	lv_point_precise_set :: proc(p: ^lv_point_precise_t, x: lv_value_precise_t, y: lv_value_precise_t) ---
	lv_point_swap :: proc(p1: ^lv_point_t, p2: ^lv_point_t) ---
	lv_point_precise_swap :: proc(p1: ^lv_point_precise_t, p2: ^lv_point_precise_t) ---
	/* Convert a percentage value to int32_t . Percentage values are stored in special range a coordinate that stores the percentage  */
	lv_pct :: proc(/* the percentage (0..1000)  */x: i32) -> i32 ---
	lv_pct_to_px :: proc(v: i32, base: i32) -> i32 ---
	/* Get the pixel size of a color format in bits, bpp the pixel size in bits  :ref:`LV_COLOR_FORMAT_GET_BPP`  */
	lv_color_format_get_bpp :: proc(/* a color format ( LV_COLOR_FORMAT_... )  */cf: lv_color_format_t) -> u8 ---
	/* Get the pixel size of a color format in bytes the pixel size in bytes  :ref:`LV_COLOR_FORMAT_GET_SIZE`  */
	lv_color_format_get_size :: proc(/* a color format ( LV_COLOR_FORMAT_... )  */cf: lv_color_format_t) -> u8 ---
	/* Check if a color format has alpha channel or not true: has alpha channel; false: doesn't have alpha channel  */
	lv_color_format_has_alpha :: proc(/* a color format ( LV_COLOR_FORMAT_... )  */src_cf: lv_color_format_t) -> bool ---
	/* Create an ARGB8888 color from RGB888 + alpha the ARGB8888 color  */
	lv_color_to_32 :: proc(/* an RGB888 color  */color: lv_color_t, /* the alpha value  */opa: lv_opa_t) -> lv_color32_t ---
	/* Convert an RGB888 color to an integer c as an integer  */
	lv_color_to_int :: proc(/* an RGB888 color  */c: lv_color_t) -> u32 ---
	/* Check if two RGB888 color are equal true: equal  */
	lv_color_eq :: proc(/* the first color  */c1: lv_color_t, /* the second color  */c2: lv_color_t) -> bool ---
	/* Check if two ARGB8888 color are equal true: equal  */
	lv_color32_eq :: proc(/* the first color  */c1: lv_color32_t, /* the second color  */c2: lv_color32_t) -> bool ---
	/* Create a color from 0x000000..0xffffff input the color  */
	lv_color_hex :: proc(/* the hex input  */c: u32) -> lv_color_t ---
	/* Create an RGB888 color the color  */
	lv_color_make :: proc(/* the red channel (0..255)  */r: u8, /* the green channel (0..255)  */g: u8, /* the blue channel (0..255)  */b: u8) -> lv_color_t ---
	/* Create an ARGB8888 color the color  */
	lv_color32_make :: proc(/* the red channel (0..255)  */r: u8, /* the green channel (0..255)  */g: u8, /* the blue channel (0..255)  */b: u8, /* the alpha channel (0..255)  */a: u8) -> lv_color32_t ---
	/* Create a color from 0x000..0xfff input the color  */
	lv_color_hex3 :: proc(/* the hex input (e.g. 0x123 will be 0x112233)  */c: u32) -> lv_color_t ---
	/* Check if a color with an RGB888 color is within the color range defined by l_color and h_color. true: pixel is within the color range  */
	lv_color_is_in_range :: proc(/* the color to check  */color: lv_color_t, /* the lower bound color  */l_color: lv_color_t, /* the upper bound color  */h_color: lv_color_t) -> bool ---
	/* Convert a RGB565 color to RGB888 the color  */
	lv_color16_to_color :: proc(/* a RGB565 color on :ref:`lv_color16_t`  */c: lv_color16_t) -> lv_color_t ---
	/* Convert am RGB888 color to RGB565 stored in uint16_t  color as RGB565 on uin16_t  */
	lv_color_to_u16 :: proc(/* and RGB888 color  */color: lv_color_t) -> u16 ---
	/* Convert am RGB888 color to XRGB8888 stored in uint32_t  color as XRGB8888 on uin32_t (the alpha channel is always set to 0xFF)  */
	lv_color_to_u32 :: proc(/* and RGB888 color  */color: lv_color_t) -> u32 ---
	/* Mix two RGB565 colors mix == 0: c2 mix == 255: c1 mix == 128: 0.5 x c1 + 0.5 x c2  */
	lv_color_16_16_mix :: proc(/* the first color (typically the foreground color)  */c1: u16, /* the second color (typically the background color)  */c2: u16, /* 0..255, or LV_OPA_0/10/20...  */mix: u8) -> u16 ---
	/* Mix white to a color the mixed color  */
	lv_color_lighten :: proc(/* the base color  */c: lv_color_t, /* the intensity of white (0: no change, 255: fully white)  */lvl: lv_opa_t) -> lv_color_t ---
	/* Mix black to a color the mixed color  */
	lv_color_darken :: proc(/* the base color  */c: lv_color_t, /* the intensity of black (0: no change, 255: fully black)  */lvl: lv_opa_t) -> lv_color_t ---
	/* Convert a HSV color to RGB the given RGB color in RGB (with LV_COLOR_DEPTH depth)  */
	lv_color_hsv_to_rgb :: proc(/* hue [0..359]  */h: u16, /* saturation [0..100]  */s: u8, /* value [0..100]  */v: u8) -> lv_color_t ---
	/* Convert a 32-bit RGB color to HSV the given RGB color in HSV  */
	lv_color_rgb_to_hsv :: proc(/* 8-bit red  */r8: u8, /* 8-bit green  */g8: u8, /* 8-bit blue  */b8: u8) -> lv_color_hsv_t ---
	/* Convert a color to HSV the given color in HSV  */
	lv_color_to_hsv :: proc(/* color  */color: lv_color_t) -> lv_color_hsv_t ---
	/* A helper for white color a white color  */
	lv_color_white :: proc() -> lv_color_t ---
	/* A helper for black color a black color  */
	lv_color_black :: proc() -> lv_color_t ---
	lv_color_premultiply :: proc(c: ^lv_color32_t) ---
	lv_color16_premultiply :: proc(c: ^lv_color16_t, a: lv_opa_t) ---
	/* Get the luminance of a color: luminance = 0.3 R + 0.59 G + 0.11 B the brightness [0..255]  */
	lv_color_luminance :: proc(/* a color  */c: lv_color_t) -> u8 ---
	/* Get the luminance of a color16: luminance = 0.3 R + 0.59 G + 0.11 B the brightness [0..255]  */
	lv_color16_luminance :: proc(/* a color  */c: lv_color16_t) -> u8 ---
	/* Get the luminance of a color24: luminance = 0.3 R + 0.59 G + 0.11 B the brightness [0..255]  */
	lv_color24_luminance :: proc(/* a color  */c: ^u8) -> u8 ---
	/* Get the luminance of a color32: luminance = 0.3 R + 0.59 G + 0.11 B the brightness [0..255]  */
	lv_color32_luminance :: proc(/* a color  */c: lv_color32_t) -> u8 ---
	/* Swap the endianness of an rgb565 color the swapped color  */
	lv_color_swap_16 :: proc(/* a color  */c: u16) -> u16 ---
	lv_palette_main :: proc(p: lv_palette_t) -> lv_color_t ---
	lv_palette_lighten :: proc(p: lv_palette_t, lvl: u8) -> lv_color_t ---
	lv_palette_darken :: proc(p: lv_palette_t, lvl: u8) -> lv_color_t ---
	/* Mix two colors with a given ratio. the mixed color  */
	lv_color_mix :: proc(/* the first color to mix (usually the foreground)  */c1: lv_color_t, /* the second color to mix (usually the background)  */c2: lv_color_t, /* The ratio of the colors. 0: full c2 , 255: full c1 , 127: half c1 and half c2  */mix: u8) -> lv_color_t ---
	/* Use bg.alpha in the return value Use fg.alpha as mix ratio  */
	lv_color_mix32 :: proc(fg: lv_color32_t, bg: lv_color32_t) -> lv_color32_t ---
	/* This function correctly blends the foreground (fg) and background (bg) colors, ensuring that the output remains in a premultiplied alpha format. 

The resulting blended color in premultiplied ARGB8888 format. If the foreground is fully opaque, it is returned as is.  If the foreground is fully transparent, the background is returned.    */
	lv_color_mix32_premultiplied :: proc(/* The foreground color in premultiplied ARGB8888 format.  */fg: lv_color32_t, /* The background color in premultiplied ARGB8888 format.  */bg: lv_color32_t) -> lv_color32_t ---
	/* Get the brightness of a color brightness in range [0..255]  */
	lv_color_brightness :: proc(/* a color  */c: lv_color_t) -> u8 ---
	lv_color_filter_dsc_init :: proc(dsc: ^lv_color_filter_dsc_t, cb: lv_color_filter_cb_t) ---
	/* Blend two colors that have not been pre-multiplied using their alpha values result color  */
	lv_color_over32 :: proc(/* the foreground color  */fg: lv_color32_t, /* the background color  */bg: lv_color32_t) -> lv_color32_t ---
	/* Initialize the draw buffer with the default handlers.  */
	lv_draw_buf_init_with_default_handlers :: proc(/* the draw buffer handlers to set  */handlers: ^lv_draw_buf_handlers_t) ---
	/* Initialize the draw buffer with given handlers.  */
	lv_draw_buf_handlers_init :: proc(/* the draw buffer handlers to set  */handlers: ^lv_draw_buf_handlers_t, /* the callback to allocate memory for the buffer  */buf_malloc_cb: lv_draw_buf_malloc_cb_t, /* the callback to free memory of the buffer  */buf_free_cb: lv_draw_buf_free_cb_t, /* the callback to copy a draw buffer to an other  */buf_copy_cb: lv_draw_buf_copy_cb_t, /* the callback to align the buffer  */align_pointer_cb: lv_draw_buf_align_cb_t, /* the callback to invalidate the cache of the buffer  */invalidate_cache_cb: lv_draw_buf_cache_operation_cb_t, /* the callback to flush buffer  */flush_cache_cb: lv_draw_buf_cache_operation_cb_t, /* the callback to calculate the stride based on the width and color format  */width_to_stride_cb: lv_draw_buf_width_to_stride_cb_t) ---
	/* Get the struct which holds the callbacks for draw buf management. Custom callback can be set on the returned value pointer to the struct of handlers  */
	lv_draw_buf_get_handlers :: proc() -> ^lv_draw_buf_handlers_t ---
	lv_draw_buf_get_font_handlers :: proc() -> ^lv_draw_buf_handlers_t ---
	lv_draw_buf_get_image_handlers :: proc() -> ^lv_draw_buf_handlers_t ---
	/* Align the address of a buffer. The buffer needs to be large enough for the real data after alignment the aligned buffer  */
	lv_draw_buf_align :: proc(/* the data to align  */buf: rawptr, /* the color format of the buffer  */color_format: lv_color_format_t) -> rawptr ---
	/* Align the address of a buffer with custom draw buffer handlers. The buffer needs to be large enough for the real data after alignment the aligned buffer  */
	lv_draw_buf_align_ex :: proc(/* the draw buffer handlers  */handlers: ^lv_draw_buf_handlers_t, /* the data to align  */buf: rawptr, /* the color format of the buffer  */color_format: lv_color_format_t) -> rawptr ---
	/* Invalidate the cache of the buffer  */
	lv_draw_buf_invalidate_cache :: proc(/* the draw buffer needs to be invalidated  */draw_buf: ^lv_draw_buf_t, /* the area to invalidate in the buffer, use NULL to invalidate the whole draw buffer address range  */area: ^lv_area_t) ---
	/* Flush the cache of the buffer  */
	lv_draw_buf_flush_cache :: proc(/* the draw buffer needs to be flushed  */draw_buf: ^lv_draw_buf_t, /* the area to flush in the buffer, use NULL to flush the whole draw buffer address range  */area: ^lv_area_t) ---
	/* Calculate the stride in bytes based on a width and color format the stride in bytes  */
	lv_draw_buf_width_to_stride :: proc(/* the width in pixels  */w: u32, /* the color format  */color_format: lv_color_format_t) -> u32 ---
	/* Calculate the stride in bytes based on a width and color format the stride in bytes  */
	lv_draw_buf_width_to_stride_ex :: proc(/* the draw buffer handlers  */handlers: ^lv_draw_buf_handlers_t, /* the width in pixels  */w: u32, /* the color format  */color_format: lv_color_format_t) -> u32 ---
	/* Clear an area on the buffer  */
	lv_draw_buf_clear :: proc(/* pointer to draw buffer  */draw_buf: ^lv_draw_buf_t, /* the area to clear, or NULL to clear the whole buffer  */a: ^lv_area_t) ---
	/* Note: Eventually, lv_draw_buf_malloc/free will be kept as private. For now, we use create to distinguish with malloc. 

Create an draw buf by allocating struct for lv_draw_buf_t and allocating a buffer for it that meets specified requirements.   */
	lv_draw_buf_create :: proc(/* the buffer width in pixels  */w: u32, /* the buffer height in pixels  */h: u32, /* the color format for image  */cf: lv_color_format_t, /* the stride in bytes for image. Use 0 for automatic calculation based on w, cf, and global stride alignment configuration.  */stride: u32) -> ^lv_draw_buf_t ---
	/* Note: Eventually, lv_draw_buf_malloc/free will be kept as private. For now, we use create to distinguish with malloc. 

Create an draw buf by allocating struct for lv_draw_buf_t and allocating a buffer for it that meets specified requirements.   */
	lv_draw_buf_create_ex :: proc(/* the draw buffer handlers  */handlers: ^lv_draw_buf_handlers_t, /* the buffer width in pixels  */w: u32, /* the buffer height in pixels  */h: u32, /* the color format for image  */cf: lv_color_format_t, /* the stride in bytes for image. Use 0 for automatic calculation based on w, cf, and global stride alignment configuration.  */stride: u32) -> ^lv_draw_buf_t ---
	/* Duplicate a draw buf with same image size, stride and color format. Copy the image data too. the duplicated draw buf on success, NULL if failed  */
	lv_draw_buf_dup :: proc(/* the draw buf to duplicate  */draw_buf: ^lv_draw_buf_t) -> ^lv_draw_buf_t ---
	/* Duplicate a draw buf with same image size, stride and color format. Copy the image data too. the duplicated draw buf on success, NULL if failed  */
	lv_draw_buf_dup_ex :: proc(/* the draw buffer handlers  */handlers: ^lv_draw_buf_handlers_t, /* the draw buf to duplicate  */draw_buf: ^lv_draw_buf_t) -> ^lv_draw_buf_t ---
	/* Initialize a draw buf with the given buffer and parameters. Clear draw buffer flag to zero. return LV_RESULT_OK on success, LV_RESULT_INVALID otherwise  */
	lv_draw_buf_init :: proc(/* the draw buf to initialize  */draw_buf: ^lv_draw_buf_t, /* the buffer width in pixels  */w: u32, /* the buffer height in pixels  */h: u32, /* the color format  */cf: lv_color_format_t, /* the stride in bytes. Use 0 for automatic calculation  */stride: u32, /* the buffer used for drawing. Unaligned data will be aligned internally  */data: rawptr, /* the size of the buffer in bytes  */data_size: u32) -> lv_result_t ---
	/* Keep using the existing memory, reshape the draw buffer to the given width and height. Return NULL if data_size is smaller than the required size.  */
	lv_draw_buf_reshape :: proc(/* pointer to a draw buffer  */draw_buf: ^lv_draw_buf_t, /* the new color format, use 0 or LV_COLOR_FORMAT_UNKNOWN to keep using the original color format.  */cf: lv_color_format_t, /* the new width in pixels  */w: u32, /* the new height in pixels  */h: u32, /* the stride in bytes for image. Use 0 for automatic calculation.  */stride: u32) -> ^lv_draw_buf_t ---
	/* Destroy a draw buf by freeing the actual buffer if it's marked as LV_IMAGE_FLAGS_ALLOCATED in header. Then free the lv_draw_buf_t struct.  */
	lv_draw_buf_destroy :: proc(/* the draw buffer to destroy  */draw_buf: ^lv_draw_buf_t) ---
	/* Copy an area from a buffer to another dest_area and src_area should have the same width and height  The default copy function required dest and src to have the same color format. Overwriting dest->handlers->buf_copy_cb can resolve this limitation.  */
	lv_draw_buf_copy :: proc(/* pointer to the destination draw buffer  */dest: ^lv_draw_buf_t, /* the area to copy from the destination buffer, if NULL, use the whole buffer  */dest_area: ^lv_area_t, /* pointer to the source draw buffer  */src: ^lv_draw_buf_t, /* the area to copy from the destination buffer, if NULL, use the whole buffer  */src_area: ^lv_area_t) ---
	/* Return pointer to the buffer at the given coordinates  */
	lv_draw_buf_goto_xy :: proc(buf: ^lv_draw_buf_t, x: u32, y: u32) -> rawptr ---
	/* Adjust the stride of a draw buf in place. LV_RESULT_OK: success or LV_RESULT_INVALID: failed  */
	lv_draw_buf_adjust_stride :: proc(/* pointer to a draw buffer  */src: ^lv_draw_buf_t, /* the new stride in bytes for image. Use LV_STRIDE_AUTO for automatic calculation.  */stride: u32) -> lv_result_t ---
	/* Premultiply draw buffer color with alpha channel. If it's already premultiplied, return directly. Only color formats with alpha channel will be processed. 

LV_RESULT_OK: premultiply success   */
	lv_draw_buf_premultiply :: proc(draw_buf: ^lv_draw_buf_t) -> lv_result_t ---
	/* Check if a draw buffer has a given flag. true: the flag is set, false: the flag is not set  */
	lv_draw_buf_has_flag :: proc(/* pointer to a draw buffer  */draw_buf: ^lv_draw_buf_t, /* the flag to check  */flag: lv_image_flags_t) -> bool ---
	/* Set a flag to a draw buffer.  */
	lv_draw_buf_set_flag :: proc(/* pointer to a draw buffer  */draw_buf: ^lv_draw_buf_t, /* the flag to set  */flag: lv_image_flags_t) ---
	/* Clear a flag from a draw buffer.  */
	lv_draw_buf_clear_flag :: proc(/* pointer to a draw buffer  */draw_buf: ^lv_draw_buf_t, /* the flag to clear  */flag: lv_image_flags_t) ---
	/* As of now, draw buf share same definition as :ref:`lv_img_dsc_t` . And is interchangeable with :ref:`lv_img_dsc_t` .  */
	lv_draw_buf_from_image :: proc(buf: ^lv_draw_buf_t, img: ^lv_img_dsc_t) -> lv_result_t ---
	lv_draw_buf_to_image :: proc(buf: ^lv_draw_buf_t, img: ^lv_img_dsc_t) ---
	/* Set the palette color of an indexed image. Valid only for LV_COLOR_FORMAT_I1/2/4/8  */
	lv_draw_buf_set_palette :: proc(/* pointer to an image descriptor  */draw_buf: ^lv_draw_buf_t, /* the palette color to set: for LV_COLOR_FORMAT_I1 : 0..1 for LV_COLOR_FORMAT_I2 : 0..3 for LV_COLOR_FORMAT_I4 : 0..15 for LV_COLOR_FORMAT_I8 : 0..255  */index: u8, /* the color to set in :ref:`lv_color32_t` format  */color: lv_color32_t) ---
	/* Deprecated Use lv_draw_buf_set_palette instead.  */
	lv_image_buf_set_palette :: proc(dsc: ^lv_img_dsc_t, id: u8, c: lv_color32_t) ---
	/* Deprecated Use lv_draw_buffer_create/destroy instead. Free the data pointer and dsc struct of an image.  */
	lv_image_buf_free :: proc(dsc: ^lv_img_dsc_t) ---
	/* Searches base[0] to base[n - 1] for an item that matches *key. 

The function cmp must return negative if it's first argument (the search key) is less that it's second (a table entry), zero if equal, and positive if greater. Items in the array must be in ascending order.  a pointer to a matching item, or NULL if none exists.    */
	lv_utils_bsearch :: proc(/* Pointer to item being searched for  */key: rawptr, /* Pointer to first element to search  */base: rawptr, /* Number of elements  */n: uint, /* Size of each element  */size: uint, /* Pointer to comparison function (see unicode_list_compare() as a comparison function example)  */cmp: #type proc "c" (pRef: rawptr, pElement: rawptr) -> i32) -> rawptr ---
	/* Save a draw buf to a file LV_RESULT_OK: success; LV_RESULT_INVALID: error  */
	lv_draw_buf_save_to_file :: proc(/* pointer to a draw buffer  */draw_buf: ^lv_draw_buf_t, /* path to the file to save  */path: ^u8) -> lv_result_t ---
	/* Reverse the order of the bytes in a 32-bit value. the value x with reversed byte-order.  */
	lv_swap_bytes_32 :: proc(/* a 32-bit value.  */x: u32) -> u32 ---
	/* Reverse the order of the bytes in a 16-bit value. the value x with reversed byte-order.  */
	lv_swap_bytes_16 :: proc(/* a 16-bit value.  */x: u16) -> u16 ---
	/* Create an iterator based on an instance, and then the next element of the iterator can be obtained through lv_iter_next, In order to obtain the next operation in a unified and abstract way. The iterator object  */
	lv_iter_create :: proc(/* The instance to be iterated  */instance: rawptr, /* The size of the element to be iterated in bytes  */elem_size: u32, /* The size of the context to be passed to the next_cb in bytes  */context_size: u32, /* The callback function to get the next element  */next_cb: lv_iter_next_cb) -> ^lv_iter_t ---
	/* Get the context of the iterator. You can use it to store some temporary variables associated with current iterator.. the iter context  */
	lv_iter_get_context :: proc(/* lv_iter_t object create before  */iter: ^lv_iter_t) -> rawptr ---
	/* Destroy the iterator object, and release the context. Other resources allocated by the user are not released. The user needs to release it by itself.  */
	lv_iter_destroy :: proc(/* lv_iter_t object create before  */iter: ^lv_iter_t) ---
	/* Get the next element of the iterator. LV_RESULT_OK: Get the next element successfully LV_RESULT_INVALID: The next element is invalid  */
	lv_iter_next :: proc(/* lv_iter_t object create before  */iter: ^lv_iter_t, /* The pointer to store the next element  */elem: rawptr) -> lv_result_t ---
	/* Make the iterator peekable, which means that the user can peek the next element without advancing the iterator.  */
	lv_iter_make_peekable :: proc(/* lv_iter_t object create before  */iter: ^lv_iter_t, /* The capacity of the peek buffer  */capacity: u32) ---
	/* Peek the next element of the iterator without advancing the iterator. LV_RESULT_OK: Peek the next element successfully LV_RESULT_INVALID: The next element is invalid  */
	lv_iter_peek :: proc(/* lv_iter_t object create before  */iter: ^lv_iter_t, /* The pointer to store the next element  */elem: rawptr) -> lv_result_t ---
	/* Only advance the iterator without getting the next element. LV_RESULT_OK: Peek the next element successfully LV_RESULT_INVALID: The next element is invalid  */
	lv_iter_peek_advance :: proc(/* lv_iter_t object create before  */iter: ^lv_iter_t) -> lv_result_t ---
	/* Reset the peek cursor to the next cursor. LV_RESULT_OK: Reset the peek buffer successfully LV_RESULT_INVALID: The peek buffer is invalid  */
	lv_iter_peek_reset :: proc(/* lv_iter_t object create before  */iter: ^lv_iter_t) -> lv_result_t ---
	/* Inspect the element of the iterator. The callback function will be called for each element of the iterator.  */
	lv_iter_inspect :: proc(/* lv_iter_t object create before  */iter: ^lv_iter_t, /* The callback function to inspect the element  */inspect_cb: lv_iter_inspect_cb) ---
	/* Create a circle buffer pointer to the created buffer  */
	lv_circle_buf_create :: proc(/* the maximum number of elements in the buffer  */capacity: u32, /* the size of an element in bytes  */element_size: u32) -> ^lv_circle_buf_t ---
	/* Create a circle buffer from an existing buffer pointer to the created buffer  */
	lv_circle_buf_create_from_buf :: proc(/* pointer to a buffer  */buf: rawptr, /* the maximum number of elements in the buffer  */capacity: u32, /* the size of an element in bytes  */element_size: u32) -> ^lv_circle_buf_t ---
	/* Create a circle buffer from an existing array pointer to the created buffer  */
	lv_circle_buf_create_from_array :: proc(/* pointer to an array  */array: ^lv_array_t) -> ^lv_circle_buf_t ---
	/* Resize the buffer LV_RESULT_OK: the buffer is resized; LV_RESULT_INVALID: the buffer is not resized  */
	lv_circle_buf_resize :: proc(/* pointer to a buffer  */circle_buf: ^lv_circle_buf_t, /* the new capacity of the buffer  */capacity: u32) -> lv_result_t ---
	/* Destroy a circle buffer  */
	lv_circle_buf_destroy :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) ---
	/* Get the size of the buffer the number of elements in the buffer  */
	lv_circle_buf_size :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) -> u32 ---
	/* Get the capacity of the buffer the maximum number of elements in the buffer  */
	lv_circle_buf_capacity :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) -> u32 ---
	/* Get the remaining space in the buffer the number of elements that can be written to the buffer  */
	lv_circle_buf_remain :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) -> u32 ---
	/* Check if the buffer is empty true: the buffer is empty; false: the buffer is not empty  */
	lv_circle_buf_is_empty :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) -> bool ---
	/* Check if the buffer is full true: the buffer is full; false: the buffer is not full  */
	lv_circle_buf_is_full :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) -> bool ---
	/* Reset the buffer LV_RESULT_OK: the buffer is reset; LV_RESULT_INVALID: the buffer is not reset  */
	lv_circle_buf_reset :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) ---
	/* Get the head of the buffer pointer to the head of the buffer  */
	lv_circle_buf_head :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) -> rawptr ---
	/* Get the tail of the buffer pointer to the tail of the buffer  */
	lv_circle_buf_tail :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) -> rawptr ---
	/* Read a value LV_RESULT_OK: the value is read; LV_RESULT_INVALID: the value is not read  */
	lv_circle_buf_read :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t, /* pointer to a variable to store the read value  */data: rawptr) -> lv_result_t ---
	/* Write a value LV_RESULT_OK: the value is written; LV_RESULT_INVALID: the value is not written  */
	lv_circle_buf_write :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t, /* pointer to the value to write  */data: rawptr) -> lv_result_t ---
	/* Fill the buffer with values the number of values filled  */
	lv_circle_buf_fill :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t, /* the number of values to fill  */count: u32, /* the callback function to fill the buffer  */fill_cb: lv_circle_buf_fill_cb_t, user_data: rawptr) -> u32 ---
	/* Skip a value LV_RESULT_OK: the value is skipped; LV_RESULT_INVALID: the value is not skipped  */
	lv_circle_buf_skip :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t) -> lv_result_t ---
	/* Peek a value LV_RESULT_OK: the value is peeked; LV_RESULT_INVALID: the value is not peeked  */
	lv_circle_buf_peek :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t, /* pointer to a variable to store the peeked value  */data: rawptr) -> lv_result_t ---
	/* Peek a value at an index LV_RESULT_OK: the value is peeked; LV_RESULT_INVALID: the value is not peeked  */
	lv_circle_buf_peek_at :: proc(/* pointer to buffer  */circle_buf: ^lv_circle_buf_t, /* the index of the value to peek, if the index is greater than the size of the buffer, it will return looply.  */index: u32, /* pointer to a variable to store the peeked value  */data: rawptr) -> lv_result_t ---
	/* pointer to the new node  */
	lv_tree_node_create :: proc(/* pointer to a class of the node  */class_p: ^lv_tree_class_t, /* pointer to the parent node (or NULL if it's the root node)  */parent: ^lv_tree_node_t) -> ^lv_tree_node_t ---
	lv_tree_node_delete :: proc(/* pointer to the node to delete  */node: ^lv_tree_node_t) ---
	/* true: traversal is finished; false: traversal broken  */
	lv_tree_walk :: proc(/* pointer to the root node of the tree  */node: ^lv_tree_node_t, /* LV_TREE_WALK_PRE_ORDER or LV_TREE_WALK_POST_ORDER  */mode: lv_tree_walk_mode_t, /* callback function to call on each node  */cb: lv_tree_traverse_cb_t, /* callback function to call before visiting a node  */bcb: lv_tree_before_cb_t, /* callback function to call after visiting a node  */acb: lv_tree_after_cb_t, /* user data to pass to the callback functions  */user_data: rawptr) -> bool ---
	/* Lock LVGL's general mutex. LVGL is not thread safe, so a mutex is used to avoid executing multiple LVGL functions at the same time from different threads. It shall be called when calling LVGL functions from threads different than lv_timer_handler's thread. It doesn't need to be called in LVGL events because they are called from :ref:`lv_timer_handler()` . It is called internally in :ref:`lv_timer_handler()` .  */
	lv_lock :: proc() ---
	/* Same as :ref:`lv_lock()` but can be called from an interrupt. LV_RESULT_OK: success; LV_RESULT_INVALID: failure  */
	lv_lock_isr :: proc() -> lv_result_t ---
	/* The pair of :ref:`lv_lock()` and :ref:`lv_lock_isr()` . It unlocks LVGL general mutex. It is called internally in :ref:`lv_timer_handler()` .  */
	lv_unlock :: proc() ---
	/* Sleeps the current thread by an amount of milliseconds.  */
	lv_sleep_ms :: proc(/* amount of milliseconds to sleep the current thread.  */ms: u32) ---
	/* Return with the bitmap of a font. It always converts the normal fonts to A8 format in a draw_buf with LV_DRAW_BUF_ALIGN and LV_DRAW_BUF_STRIDE_ALIGN You must call :ref:`lv_font_get_glyph_dsc()` to get g_dsc ( :ref:`lv_font_glyph_dsc_t` ) before you can call this function.  pointer to the glyph's data. It can be a draw buffer for bitmap fonts or an image source for imgfonts.  */
	lv_font_get_glyph_bitmap :: proc(/* the glyph descriptor including which font to use, which supply the glyph_index and the format.  */g_dsc: ^lv_font_glyph_dsc_t, /* a draw buffer that can be used to store the bitmap of the glyph.  */draw_buf: ^lv_draw_buf_t) -> rawptr ---
	/* Return the bitmap as it is. It works only if the font stores the bitmap in a non-volitile memory. the bitmap as it is  */
	lv_font_get_glyph_static_bitmap :: proc(/* the glyph descriptor including which font to use, which supply the glyph_index and the format.  */g_dsc: ^lv_font_glyph_dsc_t) -> rawptr ---
	/* Get the descriptor of a glyph true: descriptor is successfully loaded into dsc_out . false: the letter was not found, no data is loaded to dsc_out  */
	lv_font_get_glyph_dsc :: proc(/* pointer to font  */font: ^lv_font_t, /* store the result descriptor here  */dsc_out: ^lv_font_glyph_dsc_t, /* a UNICODE letter code  */letter: u32, /* the next letter after letter . Used for kerning  */letter_next: u32) -> bool ---
	/* Release the bitmap of a font. You must call :ref:`lv_font_get_glyph_dsc()` to get g_dsc ( :ref:`lv_font_glyph_dsc_t` ) before you can call this function.  */
	lv_font_glyph_release_draw_data :: proc(/* the glyph descriptor including which font to use, which supply the glyph_index and the format.  */g_dsc: ^lv_font_glyph_dsc_t) ---
	/* Get the width of a glyph with kerning the width of the glyph  */
	lv_font_get_glyph_width :: proc(/* pointer to a font  */font: ^lv_font_t, /* a UNICODE letter  */letter: u32, /* the next letter after letter . Used for kerning  */letter_next: u32) -> u16 ---
	/* Get the line height of a font. All characters fit into this height the height of a font  */
	lv_font_get_line_height :: proc(/* pointer to a font  */font: ^lv_font_t) -> i32 ---
	/* Configure the use of kerning information stored in a font  */
	lv_font_set_kerning :: proc(/* pointer to a font  */font: ^lv_font_t, /* LV_FONT_KERNING_NORMAL (default) or LV_FONT_KERNING_NONE  */kerning: lv_font_kerning_t) ---
	/* Get the default font, defined by LV_FONT_DEFAULT return pointer to the default font  */
	lv_font_get_default :: proc() -> ^lv_font_t ---
	/* Compare font information. return true if the fonts are equal.  */
	lv_font_info_is_equal :: proc(/* font information 1.  */ft_info_1: ^lv_font_info_t, /* font information 2.  */ft_info_2: ^lv_font_info_t) -> bool ---
	/* Checks if a font has a static rendering bitmap. return true if the font has a bitmap generated for static rendering.  */
	lv_font_has_static_bitmap :: proc(/* pointer to a font  */font: ^lv_font_t) -> bool ---
	/* Get size of a text  */
	lv_text_get_size :: proc(/* pointer to a 'point_t' variable to store the result  */size_res: ^lv_point_t, /* pointer to a text  */text: ^u8, /* pointer to font of the text  */font: ^lv_font_t, /* letter space of the text  */letter_space: i32, /* line space of the text  */line_space: i32, /* max width of the text (break the lines to fit this size). Set COORD_MAX to avoid  */max_width: i32, /* settings for the text from :ref:`lv_text_flag_t`  */flag: lv_text_flag_t) ---
	/* Get the real text alignment from the a text alignment, base direction and a text.  */
	lv_bidi_calculate_align :: proc(/* LV_TEXT_ALIGN_..., write back the calculated align here (LV_TEXT_ALIGN_LEFT/RIGHT/CENTER)  */align: ^lv_text_align_t, /* LV_BASE_DIR_..., write the calculated base dir here (LV_BASE_DIR_LTR/RTL)  */base_dir: ^lv_base_dir_t, /* a text, used with LV_BASE_DIR_AUTO to determine the base direction  */txt: ^u8) ---
	/* Set custom neutrals string  */
	lv_bidi_set_custom_neutrals_static :: proc(/* default " \t\n\r.,:;'\"`!?%/\\-=()[]{}<>@#&$|"  */neutrals: ^u8) ---
	/* Initialize gradient color map from a table  */
	lv_grad_init_stops :: proc(/* pointer to a gradient descriptor  */grad: ^lv_grad_dsc_t, /* color array  */colors: []lv_color_t, /* opacity array: if NULL, then LV_OPA_COVER is assumed  */opa: []lv_opa_t, /* position array (0..255): if NULL, then colors are distributed evenly  */fracs: []u8, /* number of gradient stops (1..LV_GRADIENT_MAX_STOPS)  */num_stops: i32) ---
	/* Helper function to initialize a horizontal gradient.  */
	lv_grad_horizontal_init :: proc(/* gradient descriptor  */dsc: ^lv_grad_dsc_t) ---
	/* Helper function to initialize a vertical gradient.  */
	lv_grad_vertical_init :: proc(/* gradient descriptor  */dsc: ^lv_grad_dsc_t) ---
	/* Helper function to initialize linear gradient  */
	lv_grad_linear_init :: proc(/* gradient descriptor  */dsc: ^lv_grad_dsc_t, /* start x position: can be a coordinate or an :ref:`lv_pct()` value predefined constants LV_GRAD_LEFT, LV_GRAD_RIGHT, LV_GRAD_TOP, LV_GRAD_BOTTOM, LV_GRAD_CENTER can be used as well  */from_x: i32, /* start y position  */from_y: i32, /* end x position  */to_x: i32, /* end y position  */to_y: i32, /* one of LV_GRAD_EXTEND_PAD, LV_GRAD_EXTEND_REPEAT or LV_GRAD_EXTEND_REFLECT  */extend: lv_grad_extend_t) ---
	/* Helper function to initialize radial gradient  */
	lv_grad_radial_init :: proc(/* gradient descriptor  */dsc: ^lv_grad_dsc_t, /* center x position: can be a coordinate or an :ref:`lv_pct()` value predefined constants LV_GRAD_LEFT, LV_GRAD_RIGHT, LV_GRAD_TOP, LV_GRAD_BOTTOM, LV_GRAD_CENTER can be used as well  */center_x: i32, /* center y position  */center_y: i32, /* point on the end circle x position  */to_x: i32, /* point on the end circle y position  */to_y: i32, /* one of LV_GRAD_EXTEND_PAD, LV_GRAD_EXTEND_REPEAT or LV_GRAD_EXTEND_REFLECT  */extend: lv_grad_extend_t) ---
	/* Set focal (starting) circle of a radial gradient  */
	lv_grad_radial_set_focal :: proc(/* gradient descriptor  */dsc: ^lv_grad_dsc_t, /* center x position: can be a coordinate or an :ref:`lv_pct()` value predefined constants LV_GRAD_LEFT, LV_GRAD_RIGHT, LV_GRAD_TOP, LV_GRAD_BOTTOM, LV_GRAD_CENTER can be used as well  */center_x: i32, /* center y position  */center_y: i32, /* radius of the starting circle (NOTE: this must be a scalar number, not percentage)  */radius: i32) ---
	/* Helper function to initialize conical gradient  */
	lv_grad_conical_init :: proc(/* gradient descriptor  */dsc: ^lv_grad_dsc_t, /* center x position: can be a coordinate or an :ref:`lv_pct()` value predefined constants LV_GRAD_LEFT, LV_GRAD_RIGHT, LV_GRAD_TOP, LV_GRAD_BOTTOM, LV_GRAD_CENTER can be used as well  */center_x: i32, /* center y position  */center_y: i32, /* start angle in degrees  */start_angle: i32, /* end angle in degrees  */end_angle: i32, /* one of LV_GRAD_EXTEND_PAD, LV_GRAD_EXTEND_REPEAT or LV_GRAD_EXTEND_REFLECT  */extend: lv_grad_extend_t) ---
	/* Register a new layout the ID of the new layout  */
	lv_layout_register :: proc(/* the layout update callback  */cb: lv_layout_update_cb_t, /* custom data that will be passed to cb  */user_data: rawptr) -> u32 ---
	/* Initialize a flex layout to default values  */
	lv_flex_init :: proc() ---
	/* Set how the item should flow  */
	lv_obj_set_flex_flow :: proc(/* pointer to an object. The parent must have flex layout else nothing will happen.  */obj: ^lv_obj_t, /* an element of lv_flex_flow_t .  */flow: lv_flex_flow_t) ---
	/* Set how to place (where to align) the items and tracks  */
	lv_obj_set_flex_align :: proc(/* pointer to an object. The parent must have flex layout else nothing will happen.  */obj: ^lv_obj_t, /* where to place the items on main axis (in their track). Any value of lv_flex_align_t .  */main_place: lv_flex_align_t, /* where to place the item in their track on the cross axis. LV_FLEX_ALIGN_START/END/CENTER  */cross_place: lv_flex_align_t, /* where to place the tracks in the cross direction. Any value of lv_flex_align_t .  */track_cross_place: lv_flex_align_t) ---
	/* Sets the width or height (on main axis) to grow the object in order fill the free space  */
	lv_obj_set_flex_grow :: proc(/* pointer to an object. The parent must have flex layout else nothing will happen.  */obj: ^lv_obj_t, /* a value to set how much free space to take proportionally to other growing items.  */grow: u8) ---
	lv_grid_init :: proc() ---
	lv_obj_set_grid_dsc_array :: proc(obj: ^lv_obj_t, col_dsc: []i32, row_dsc: []i32) ---
	lv_obj_set_grid_align :: proc(obj: ^lv_obj_t, column_align: lv_grid_align_t, row_align: lv_grid_align_t) ---
	/* Set the cell of an object. The object's parent needs to have grid layout, else nothing will happen  */
	lv_obj_set_grid_cell :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the vertical alignment in the cell. LV_GRID_START/END/CENTER/STRETCH  */column_align: lv_grid_align_t, /* column ID  */col_pos: i32, /* number of columns to take (>= 1)  */col_span: i32, /* the horizontal alignment in the cell. LV_GRID_START/END/CENTER/STRETCH  */row_align: lv_grid_align_t, /* row ID  */row_pos: i32, /* number of rows to take (>= 1)  */row_span: i32) ---
	/* Just a wrapper to LV_GRID_FR for bindings.  */
	lv_grid_fr :: proc(x: u8) -> i32 ---
	/* Initialize a style Do not call lv_style_init on styles that already have some properties because this function won't free the used memory, just sets a default state for the style. In other words be sure to initialize styles only once!  */
	lv_style_init :: proc(/* pointer to a style to initialize  */style: ^lv_style_t) ---
	/* Clear all properties from a style and free all allocated memories.  */
	lv_style_reset :: proc(/* pointer to a style  */style: ^lv_style_t) ---
	/* Copy all properties of a style to an other. It has the same affect callying the same lv_set_style_... functions on both styles. It means new memory will be allocated to store the properties in the destination style. After the copy the destination style is fully independent of the source and source can removed without affecting the destination style.  */
	lv_style_copy :: proc(/* the destination to copy into (can not the a constant style)  */dst: ^lv_style_t, /* the source style to copy from.  */src: ^lv_style_t) ---
	/* Copy all properties of a style to an other without resetting the dst style. It has the same effect as calling the same lv_set_style_... functions on both styles. It means new memory will be allocated to store the properties in the destination style. After the copy the destination style is fully independent of the source and source can removed without affecting the destination style.  */
	lv_style_merge :: proc(/* the destination to copy into (cannot be a constant style)  */dst: ^lv_style_t, /* the source style to copy from.  */src: ^lv_style_t) ---
	/* Check if a style is constant true: the style is constant  */
	lv_style_is_const :: proc(/* pointer to a style  */style: ^lv_style_t) -> bool ---
	/* Register a new style property for custom usage a new property ID, or LV_STYLE_PROP_INV if there are no more available. Example: lv_style_prop_t MY_PROP; static inline void lv_style_set_my_prop(lv_style_t * style, lv_color_t value) {  lv_style_value_t v = {.color = value}; lv_style_set_prop(style, MY_PROP, v); }  ...  MY_PROP = lv_style_register_prop();  ...  lv_style_set_my_prop(&style1, lv_palette_main(LV_PALETTE_RED));  */
	lv_style_register_prop :: proc(flag: u8) -> lv_style_prop_t ---
	/* Get the number of custom properties that have been registered thus far.  */
	lv_style_get_num_custom_props :: proc() -> lv_style_prop_t ---
	/* Remove a property from a style true: the property was found and removed; false: the property wasn't found  */
	lv_style_remove_prop :: proc(/* pointer to a style  */style: ^lv_style_t, /* a style property ORed with a state.  */prop: lv_style_prop_t) -> bool ---
	/* Set the value of property in a style. This function shouldn't be used directly by the user. Instead use lv_style_set_<prop_name>() . E.g. lv_style_set_bg_color()  */
	lv_style_set_prop :: proc(/* pointer to style  */style: ^lv_style_t, /* the ID of a property (e.g. LV_STYLE_BG_COLOR )  */prop: lv_style_prop_t, /* :ref:`lv_style_value_t` variable in which a field is set according to the type of prop  */value: lv_style_value_t) ---
	/* Get the value of a property LV_RESULT_INVALID: the property wasn't found in the style ( value is unchanged) LV_RESULT_OK: the property was fond, and value is set accordingly  For performance reasons there are no sanity check on style  */
	lv_style_get_prop :: proc(/* pointer to a style  */style: ^lv_style_t, /* the ID of a property  */prop: lv_style_prop_t, /* pointer to a :ref:`lv_style_value_t` variable to store the value  */value: ^lv_style_value_t) -> lv_style_res_t ---
	/* Initialize a transition descriptor. const static lv_style_prop_t trans_props[] = { LV_STYLE_BG_OPA, LV_STYLE_BG_COLOR, 0 }; static lv_style_transition_dsc_t trans1;  lv_style_transition_dsc_init(&trans1, trans_props, NULL, 300, 0, NULL);  */
	lv_style_transition_dsc_init :: proc(/* pointer to a transition descriptor to initialize  */tr: ^lv_style_transition_dsc_t, /* an array with the properties to transition. The last element must be zero.  */props: []lv_style_prop_t, /* an animation path (ease) callback. If NULL liner path will be used.  */path_cb: lv_anim_path_cb_t, /* duration of the transition in [ms]  */time: u32, /* delay before the transition in [ms]  */delay: u32, /* any custom data that will be saved in the transition animation and will be available when path_cb is called  */user_data: rawptr) ---
	/* Get the default value of a property the default value  */
	lv_style_prop_get_default :: proc(/* the ID of a property  */prop: lv_style_prop_t) -> lv_style_value_t ---
	/* Get the value of a property LV_RESULT_INVALID: the property wasn't found in the style ( value is unchanged) LV_RESULT_OK: the property was fond, and value is set accordingly  For performance reasons there are no sanity check on style  This function is the same as :ref:`lv_style_get_prop` but inlined. Use it only on performance critical places  */
	lv_style_get_prop_inlined :: proc(/* pointer to a style  */style: ^lv_style_t, /* the ID of a property  */prop: lv_style_prop_t, /* pointer to a :ref:`lv_style_value_t` variable to store the value  */value: ^lv_style_value_t) -> lv_style_res_t ---
	/* Checks if a style is empty (has no properties) true if the style is empty  */
	lv_style_is_empty :: proc(/* pointer to a style  */style: ^lv_style_t) -> bool ---
	/* Tell the group of a property. If the a property from a group is set in a style the (1 << group) bit of style->has_group is set. It allows early skipping the style if the property is not exists in the style at all. the group [0..30] 30 means all the custom properties with index > 120  */
	lv_style_get_prop_group :: proc(/* a style property  */prop: lv_style_prop_t) -> u32 ---
	/* Get the flags of a built-in or custom property. 

the flags of the property   */
	lv_style_prop_lookup_flags :: proc(/* a style property  */prop: lv_style_prop_t) -> u8 ---
	lv_style_set_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_min_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_max_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_height :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_min_height :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_max_height :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_length :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_x :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_y :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_align :: proc(style: ^lv_style_t, value: lv_align_t) ---
	lv_style_set_transform_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_height :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_translate_x :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_translate_y :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_translate_radial :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_scale_x :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_scale_y :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_rotation :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_pivot_x :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_pivot_y :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_skew_x :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_skew_y :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_top :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_bottom :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_left :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_right :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_row :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_column :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_radial :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_margin_top :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_margin_bottom :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_margin_left :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_margin_right :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_bg_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_bg_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_bg_grad_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_bg_grad_dir :: proc(style: ^lv_style_t, value: lv_grad_dir_t) ---
	lv_style_set_bg_main_stop :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_bg_grad_stop :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_bg_main_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_bg_grad_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_bg_grad :: proc(style: ^lv_style_t, value: ^lv_grad_dsc_t) ---
	lv_style_set_bg_image_src :: proc(style: ^lv_style_t, value: rawptr) ---
	lv_style_set_bg_image_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_bg_image_recolor :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_bg_image_recolor_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_bg_image_tiled :: proc(style: ^lv_style_t, value: bool) ---
	lv_style_set_border_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_border_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_border_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_border_side :: proc(style: ^lv_style_t, value: lv_border_side_t) ---
	lv_style_set_border_post :: proc(style: ^lv_style_t, value: bool) ---
	lv_style_set_outline_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_outline_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_outline_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_outline_pad :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_shadow_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_shadow_offset_x :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_shadow_offset_y :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_shadow_spread :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_shadow_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_shadow_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_image_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_image_recolor :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_image_recolor_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_image_colorkey :: proc(style: ^lv_style_t, value: ^lv_image_colorkey_t) ---
	lv_style_set_line_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_line_dash_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_line_dash_gap :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_line_rounded :: proc(style: ^lv_style_t, value: bool) ---
	lv_style_set_line_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_line_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_arc_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_arc_rounded :: proc(style: ^lv_style_t, value: bool) ---
	lv_style_set_arc_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_arc_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_arc_image_src :: proc(style: ^lv_style_t, value: rawptr) ---
	lv_style_set_text_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_text_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_text_font :: proc(style: ^lv_style_t, value: ^lv_font_t) ---
	lv_style_set_text_letter_space :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_text_line_space :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_text_decor :: proc(style: ^lv_style_t, value: lv_text_decor_t) ---
	lv_style_set_text_align :: proc(style: ^lv_style_t, value: lv_text_align_t) ---
	lv_style_set_text_outline_stroke_color :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_text_outline_stroke_width :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_text_outline_stroke_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_radius :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_radial_offset :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_clip_corner :: proc(style: ^lv_style_t, value: bool) ---
	lv_style_set_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_opa_layered :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_color_filter_dsc :: proc(style: ^lv_style_t, value: ^lv_color_filter_dsc_t) ---
	lv_style_set_color_filter_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_recolor :: proc(style: ^lv_style_t, value: lv_color_t) ---
	lv_style_set_recolor_opa :: proc(style: ^lv_style_t, value: lv_opa_t) ---
	lv_style_set_blur_radius :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_blur_backdrop :: proc(style: ^lv_style_t, value: bool) ---
	lv_style_set_blur_quality :: proc(style: ^lv_style_t, value: lv_blur_quality_t) ---
	lv_style_set_anim :: proc(style: ^lv_style_t, value: ^lv_anim_t) ---
	lv_style_set_anim_duration :: proc(style: ^lv_style_t, value: u32) ---
	lv_style_set_transition :: proc(style: ^lv_style_t, value: ^lv_style_transition_dsc_t) ---
	lv_style_set_blend_mode :: proc(style: ^lv_style_t, value: lv_blend_mode_t) ---
	lv_style_set_layout :: proc(style: ^lv_style_t, value: u16) ---
	lv_style_set_base_dir :: proc(style: ^lv_style_t, value: lv_base_dir_t) ---
	lv_style_set_bitmap_mask_src :: proc(style: ^lv_style_t, value: rawptr) ---
	lv_style_set_rotary_sensitivity :: proc(style: ^lv_style_t, value: u32) ---
	lv_style_set_flex_flow :: proc(style: ^lv_style_t, value: lv_flex_flow_t) ---
	lv_style_set_flex_main_place :: proc(style: ^lv_style_t, value: lv_flex_align_t) ---
	lv_style_set_flex_cross_place :: proc(style: ^lv_style_t, value: lv_flex_align_t) ---
	lv_style_set_flex_track_place :: proc(style: ^lv_style_t, value: lv_flex_align_t) ---
	lv_style_set_flex_grow :: proc(style: ^lv_style_t, value: u8) ---
	lv_style_set_grid_column_dsc_array :: proc(style: ^lv_style_t, value: ^i32) ---
	lv_style_set_grid_column_align :: proc(style: ^lv_style_t, value: lv_grid_align_t) ---
	lv_style_set_grid_row_dsc_array :: proc(style: ^lv_style_t, value: ^i32) ---
	lv_style_set_grid_row_align :: proc(style: ^lv_style_t, value: lv_grid_align_t) ---
	lv_style_set_grid_cell_column_pos :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_grid_cell_x_align :: proc(style: ^lv_style_t, value: lv_grid_align_t) ---
	lv_style_set_grid_cell_column_span :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_grid_cell_row_pos :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_grid_cell_y_align :: proc(style: ^lv_style_t, value: lv_grid_align_t) ---
	lv_style_set_grid_cell_row_span :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_size :: proc(style: ^lv_style_t, width: i32, height: i32) ---
	lv_style_set_pad_all :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_hor :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_ver :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_pad_gap :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_margin_hor :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_margin_ver :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_margin_all :: proc(style: ^lv_style_t, value: i32) ---
	lv_style_set_transform_scale :: proc(style: ^lv_style_t, value: i32) ---
	/* Do not pass multiple flags to this function as backwards-compatibility is not guaranteed for that. 

true if the flag is set for this property   */
	lv_style_prop_has_flag :: proc(/* Property ID  */prop: lv_style_prop_t, /* Flag  */flag: u8) -> bool ---
	lv_event_send :: proc(list: ^lv_event_list_t, e: ^lv_event_t, preprocess: bool) -> lv_result_t ---
	lv_event_add :: proc(list: ^lv_event_list_t, cb: lv_event_cb_t, filter: lv_event_code_t, user_data: rawptr) -> ^lv_event_dsc_t ---
	lv_event_remove_dsc :: proc(list: ^lv_event_list_t, dsc: ^lv_event_dsc_t) -> bool ---
	lv_event_get_count :: proc(list: ^lv_event_list_t) -> u32 ---
	lv_event_get_dsc :: proc(list: ^lv_event_list_t, index: u32) -> ^lv_event_dsc_t ---
	lv_event_dsc_get_cb :: proc(dsc: ^lv_event_dsc_t) -> lv_event_cb_t ---
	lv_event_dsc_get_user_data :: proc(dsc: ^lv_event_dsc_t) -> rawptr ---
	lv_event_remove :: proc(list: ^lv_event_list_t, index: u32) -> bool ---
	lv_event_remove_all :: proc(list: ^lv_event_list_t) ---
	/* Get Widget originally targeted by the event. It's the same even if event was bubbled. the target of the event_code  */
	lv_event_get_target :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) -> rawptr ---
	/* Get current target of the event. It's the Widget for which the event handler being called. If the event is not bubbled it's the same as "normal" target. pointer to the current target of the event_code  */
	lv_event_get_current_target :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) -> rawptr ---
	/* Get event code of an event. the event code. (E.g. LV_EVENT_CLICKED , LV_EVENT_FOCUSED , etc)  */
	lv_event_get_code :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) -> lv_event_code_t ---
	/* Get parameter passed when event was sent. pointer to the parameter  */
	lv_event_get_param :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) -> rawptr ---
	/* Get user_data passed when event was registered on Widget. pointer to the user_data  */
	lv_event_get_user_data :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) -> rawptr ---
	/* Stop event from bubbling. This is only valid when called in the middle of an event processing chain.  */
	lv_event_stop_bubbling :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) ---
	/* Stop event from trickling down to children. This is only valid when called in the middle of an event processing chain.  */
	lv_event_stop_trickling :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) ---
	/* Stop processing this event. This is only valid when called in the middle of an event processing chain.  */
	lv_event_stop_processing :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) ---
	/* Helper function typically used in LV_EVENT_DELETE to free the event's user_data  */
	lv_event_free_user_data_cb :: proc(/* pointer to an event descriptor  */e: ^lv_event_t) ---
	/* Register a new, custom event ID. It can be used the same way as e.g. LV_EVENT_CLICKED to send custom events the new event id Example: uint32_t LV_EVENT_MINE = 0; ...  e = lv_event_register_id();  ...  lv_obj_send_event(obj, LV_EVENT_MINE, &some_data);  */
	lv_event_register_id :: proc() -> u32 ---
	/* Get the name of an event code. the name of the event code as a string  */
	lv_event_code_get_name :: proc(/* the event code  */code: lv_event_code_t) -> ^u8 ---
	/* Create a new display with the given resolution pointer to a display object or NULL on error  */
	lv_display_create :: proc(/* horizontal resolution in pixels  */hor_res: i32, /* vertical resolution in pixels  */ver_res: i32) -> ^lv_display_t ---
	/* Remove a display  */
	lv_display_delete :: proc(/* pointer to display  */disp: ^lv_display_t) ---
	/* Set a default display. The new screens will be created on it by default.  */
	lv_display_set_default :: proc(/* pointer to a display  */disp: ^lv_display_t) ---
	/* Get the default display pointer to the default display  */
	lv_display_get_default :: proc() -> ^lv_display_t ---
	/* Get the next display. the next display or NULL if no more. Gives the first display when the parameter is NULL.  */
	lv_display_get_next :: proc(/* pointer to the current display. NULL to initialize.  */disp: ^lv_display_t) -> ^lv_display_t ---
	/* Sets the resolution of a display. LV_EVENT_RESOLUTION_CHANGED event will be sent. Here the native resolution of the device should be set. If the display will be rotated later with lv_display_set_rotation LVGL will swap the hor. and ver. resolution automatically.  */
	lv_display_set_resolution :: proc(/* pointer to a display  */disp: ^lv_display_t, /* the new horizontal resolution  */hor_res: i32, /* the new vertical resolution  */ver_res: i32) ---
	/* It's not mandatory to use the whole display for LVGL, however in some cases physical resolution is important. For example the touchpad still sees whole resolution and the values needs to be converted to the active LVGL display area.  */
	lv_display_set_physical_resolution :: proc(/* pointer to a display  */disp: ^lv_display_t, /* the new physical horizontal resolution, or -1 to assume it's the same as the normal hor. res.  */hor_res: i32, /* the new physical vertical resolution, or -1 to assume it's the same as the normal hor. res.  */ver_res: i32) ---
	/* If physical resolution is not the same as the normal resolution the offset of the active display area can be set here.  */
	lv_display_set_offset :: proc(/* pointer to a display  */disp: ^lv_display_t, /* X offset  */x: i32, /* Y offset  */y: i32) ---
	/* Set the rotation of this display. LVGL will swap the horizontal and vertical resolutions internally.  */
	lv_display_set_rotation :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t, /* LV_DISPLAY_ROTATION_0/90/180/270  */rotation: lv_display_rotation_t) ---
	/* Use matrix rotation for the display. This function is depended on LV_DRAW_TRANSFORM_USE_MATRIX  */
	lv_display_set_matrix_rotation :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t, /* true: enable matrix rotation, false: disable  */enable: bool) ---
	/* Set the DPI (dot per inch) of the display. dpi = sqrt(hor_res^2 + ver_res^2) / diagonal"  */
	lv_display_set_dpi :: proc(/* pointer to a display  */disp: ^lv_display_t, /* the new DPI  */dpi: i32) ---
	/* Get the horizontal resolution of a display. the horizontal resolution of the display.  */
	lv_display_get_horizontal_resolution :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Get the vertical resolution of a display the vertical resolution of the display  */
	lv_display_get_vertical_resolution :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Get the original horizontal resolution of a display without considering rotation the horizontal resolution of the display.  */
	lv_display_get_original_horizontal_resolution :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Get the original vertical resolution of a display without considering rotation the vertical resolution of the display  */
	lv_display_get_original_vertical_resolution :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Get the physical horizontal resolution of a display the physical horizontal resolution of the display  */
	lv_display_get_physical_horizontal_resolution :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Get the physical vertical resolution of a display the physical vertical resolution of the display  */
	lv_display_get_physical_vertical_resolution :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Get the horizontal offset from the full / physical display the horizontal offset from the physical display  */
	lv_display_get_offset_x :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Get the vertical offset from the full / physical display the horizontal offset from the physical display  */
	lv_display_get_offset_y :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Get the current rotation of this display. the current rotation  */
	lv_display_get_rotation :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> lv_display_rotation_t ---
	/* Get if matrix rotation is enabled for a display or not true: matrix rotation is enabled; false: disabled  */
	lv_display_get_matrix_rotation :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> bool ---
	/* Get the DPI of the display dpi of the display  */
	lv_display_get_dpi :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> i32 ---
	/* Set the buffers for a display, similarly to lv_display_set_draw_buffers , but accept the raw buffer pointers. For DIRECT/FULL rending modes, the buffer size must be at least hor_res * ver_res * lv_color_format_get_size(lv_display_get_color_format(disp))  */
	lv_display_set_buffers :: proc(/* pointer to a display  */disp: ^lv_display_t, /* first buffer  */buf1: rawptr, /* second buffer (can be NULL )  */buf2: rawptr, /* buffer size in byte  */buf_size: u32, /* LV_DISPLAY_RENDER_MODE_PARTIAL/DIRECT/FULL  */render_mode: lv_display_render_mode_t) ---
	/* Set the frame buffers for a display, similarly to lv_display_set_buffers , but allow for a custom stride as required by a display controller. This allows the frame buffers to have a stride alignment different from the rest of the buffers @param disp pointer to a display @param buf1 first buffer @param buf2 second buffer (can be NULL`)  */
	lv_display_set_buffers_with_stride :: proc(disp: ^lv_display_t, buf1: rawptr, buf2: rawptr, /* buffer size in byte  */buf_size: u32, /* buffer stride in bytes  */stride: u32, /* LV_DISPLAY_RENDER_MODE_PARTIAL/DIRECT/FULL  */render_mode: lv_display_render_mode_t) ---
	/* Set the buffers for a display, accept a draw buffer pointer. Normally use lv_display_set_buffers is enough for most cases. Use this function when an existing lv_draw_buf_t is available.  */
	lv_display_set_draw_buffers :: proc(/* pointer to a display  */disp: ^lv_display_t, /* first buffer  */buf1: ^lv_draw_buf_t, /* second buffer (can be NULL )  */buf2: ^lv_draw_buf_t) ---
	/* Set the third draw buffer for a display.  */
	lv_display_set_3rd_draw_buffer :: proc(/* pointer to a display  */disp: ^lv_display_t, /* third buffer  */buf3: ^lv_draw_buf_t) ---
	/* Set display render mode  */
	lv_display_set_render_mode :: proc(/* pointer to a display  */disp: ^lv_display_t, /* LV_DISPLAY_RENDER_MODE_PARTIAL/DIRECT/FULL  */render_mode: lv_display_render_mode_t) ---
	/* Set the flush callback which will be called to copy the rendered image to the display.  */
	lv_display_set_flush_cb :: proc(/* pointer to a display  */disp: ^lv_display_t, /* the flush callback ( px_map contains the rendered image as raw pixel map and it should be copied to area on the display)  */flush_cb: lv_display_flush_cb_t) ---
	/* Set a callback to be used while LVGL is waiting flushing to be finished. It can do any complex logic to wait, including semaphores, mutexes, polling flags, etc. If not set the disp->flushing flag is used which can be cleared with :ref:`lv_display_flush_ready()`  */
	lv_display_set_flush_wait_cb :: proc(/* pointer to a display  */disp: ^lv_display_t, /* a callback to call while LVGL is waiting for flush ready. If NULL :ref:`lv_display_flush_ready()` can be used to signal that flushing is ready.  */wait_cb: lv_display_flush_wait_cb_t) ---
	/* Set the color format of the display. To change the endianness of the rendered image in case of RGB565 format (i.e. swap the 2 bytes) call lv_draw_sw_rgb565_swap in the flush_cb  */
	lv_display_set_color_format :: proc(/* pointer to a display  */disp: ^lv_display_t, /* Possible values are LV_COLOR_FORMAT_RGB565 LV_COLOR_FORMAT_RGB888 LV_COLOR_FORMAT_XRGB888 LV_COLOR_FORMAT_ARGB888  */color_format: lv_color_format_t) ---
	/* Get the color format of the display the color format  */
	lv_display_get_color_format :: proc(/* pointer to a display  */disp: ^lv_display_t) -> lv_color_format_t ---
	/* Set the number of tiles for parallel rendering.  */
	lv_display_set_tile_cnt :: proc(/* pointer to a display  */disp: ^lv_display_t, /* number of tiles (1 =< tile_cnt < 256)  */tile_cnt: u32) ---
	/* Get the number of tiles used for parallel rendering number of tiles  */
	lv_display_get_tile_cnt :: proc(/* pointer to a display  */disp: ^lv_display_t) -> u32 ---
	/* Disabling anti-aliasing is not supported since v9. This function will be removed. Enable anti-aliasing for the render engine  */
	lv_display_set_antialiasing :: proc(/* pointer to a display  */disp: ^lv_display_t, /* true/false  */en: bool) ---
	/* Get if anti-aliasing is enabled for a display or not true/false  */
	lv_display_get_antialiasing :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> bool ---
	/* Call from the display driver when the flushing is finished  */
	lv_display_flush_ready :: proc(/* pointer to display whose flush_cb was called  */disp: ^lv_display_t) ---
	/* Tell if it's the last area of the refreshing process. Can be called from flush_cb to execute some special display refreshing if needed when all areas area flushed. true: it's the last area to flush; false: there are other areas too which will be refreshed soon  */
	lv_display_flush_is_last :: proc(/* pointer to display  */disp: ^lv_display_t) -> bool ---
	lv_display_is_double_buffered :: proc(disp: ^lv_display_t) -> bool ---
	/* Get display render mode display's render mode (LV_DISPLAY_RENDER_MODE_PARTIAL/DIRECT/FULL)  */
	lv_display_get_render_mode :: proc(/* pointer to a display  */disp: ^lv_display_t) -> lv_display_render_mode_t ---
	/* Return a pointer to the active screen on a display pointer to the active screen object (loaded by ' :ref:`lv_screen_load()` ')  */
	lv_display_get_screen_active :: proc(/* pointer to display which active screen should be get. (NULL to use the default screen)  */disp: ^lv_display_t) -> ^lv_obj_t ---
	/* Return with a pointer to the previous screen. Only used during screen transitions. pointer to the previous screen object or NULL if not used now  */
	lv_display_get_screen_prev :: proc(/* pointer to display which previous screen should be get. (NULL to use the default screen)  */disp: ^lv_display_t) -> ^lv_obj_t ---
	/* Return the screen that is currently being loaded by the display pointer to the screen being loaded or NULL if no screen is currently being loaded  */
	lv_display_get_screen_loading :: proc(/* pointer to a display object (NULL to use the default screen)  */disp: ^lv_display_t) -> ^lv_obj_t ---
	/* Return the top layer. The top layer is the same on all screens and it is above the normal screen layer. pointer to the top layer object  */
	lv_display_get_layer_top :: proc(/* pointer to display which top layer should be get. (NULL to use the default screen)  */disp: ^lv_display_t) -> ^lv_obj_t ---
	/* Return the sys. layer. The system layer is the same on all screen and it is above the normal screen and the top layer. pointer to the sys layer object  */
	lv_display_get_layer_sys :: proc(/* pointer to display which sys. layer should be retrieved. (NULL to use the default screen)  */disp: ^lv_display_t) -> ^lv_obj_t ---
	/* Return the bottom layer. The bottom layer is the same on all screen and it is under the normal screen layer. It's visible only if the screen is transparent. pointer to the bottom layer object  */
	lv_display_get_layer_bottom :: proc(/* pointer to display (NULL to use the default screen)  */disp: ^lv_display_t) -> ^lv_obj_t ---
	/* Load a screen on the default display  */
	lv_screen_load :: proc(/* pointer to a screen  */scr: ^lv_obj_t ) ---
	/* Switch screen with animation  */
	lv_screen_load_anim :: proc(/* pointer to the new screen to load  */scr: ^lv_obj_t, /* type of the animation from lv_screen_load_anim_t , e.g. LV_SCREEN_LOAD_ANIM_MOVE_LEFT  */anim_type: lv_screen_load_anim_t, /* time of the animation  */time: u32, /* delay before the transition  */delay: u32, /* true: automatically delete the old screen  */auto_del: bool) ---
	/* Get the active screen of the default display pointer to the active screen  */
	lv_screen_active :: proc() -> ^lv_obj_t ---
	/* Get the top layer of the default display pointer to the top layer  */
	lv_layer_top :: proc() -> ^lv_obj_t ---
	/* Get the system layer of the default display pointer to the sys layer  */
	lv_layer_sys :: proc() -> ^lv_obj_t ---
	/* Get the bottom layer of the default display pointer to the bottom layer  */
	lv_layer_bottom :: proc() -> ^lv_obj_t ---
	/* Add an event handler to the display  */
	lv_display_add_event_cb :: proc(/* pointer to a display  */disp: ^lv_display_t, /* an event callback  */event_cb: lv_event_cb_t, /* event code to react or LV_EVENT_ALL  */filter: lv_event_code_t, /* optional user_data  */user_data: rawptr) ---
	/* Get the number of event attached to a display number of events  */
	lv_display_get_event_count :: proc(/* pointer to a display  */disp: ^lv_display_t) -> u32 ---
	/* Get an event descriptor for an event the event descriptor  */
	lv_display_get_event_dsc :: proc(/* pointer to a display  */disp: ^lv_display_t, /* the index of the event  */index: u32) -> ^lv_event_dsc_t ---
	/* Remove an event true: and event was removed; false: no event was removed  */
	lv_display_delete_event :: proc(/* pointer to a display  */disp: ^lv_display_t, /* the index of the event to remove  */index: u32) -> bool ---
	/* Remove an event_cb with user_data the count of the event removed  */
	lv_display_remove_event_cb_with_user_data :: proc(/* pointer to a display  */disp: ^lv_display_t, /* the event_cb of the event to remove  */event_cb: lv_event_cb_t, /* user_data  */user_data: rawptr) -> u32 ---
	/* Send an event to a display LV_RESULT_OK: disp wasn't deleted in the event.  */
	lv_display_send_event :: proc(/* pointer to a display  */disp: ^lv_display_t, /* an event code. LV_EVENT_...  */code: lv_event_code_t, /* optional param  */param: rawptr) -> lv_result_t ---
	/* Get the area to be invalidated. Can be used in LV_EVENT_INVALIDATE_AREA  the area to invalidated (can be modified as required)  */
	lv_event_get_invalidated_area :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_area_t ---
	/* Set the theme of a display. If there are no user created widgets yet the screens' theme will be updated  */
	lv_display_set_theme :: proc(/* pointer to a display  */disp: ^lv_display_t, /* pointer to a theme  */th: ^lv_theme_t) ---
	/* Get the theme of a display the display's theme (can be NULL)  */
	lv_display_get_theme :: proc(/* pointer to a display  */disp: ^lv_display_t) -> ^lv_theme_t ---
	/* Get elapsed time since last user activity on a display (e.g. click) elapsed ticks (milliseconds) since the last activity  */
	lv_display_get_inactive_time :: proc(/* pointer to a display (NULL to get the overall smallest inactivity)  */disp: ^lv_display_t) -> u32 ---
	/* Manually trigger an activity on a display  */
	lv_display_trigger_activity :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) ---
	/* Temporarily enable and disable the invalidation of the display.  */
	lv_display_enable_invalidation :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t, /* true: enable invalidation; false: invalidation  */en: bool) ---
	/* Get display invalidation is enabled. return true if invalidation is enabled  */
	lv_display_is_invalidation_enabled :: proc(/* pointer to a display (NULL to use the default display)  */disp: ^lv_display_t) -> bool ---
	/* Get a pointer to the screen refresher timer to modify its parameters with lv_timer_... functions. pointer to the display refresher timer. (NULL on error)  */
	lv_display_get_refr_timer :: proc(/* pointer to a display  */disp: ^lv_display_t) -> ^lv_timer_t ---
	/* Delete screen refresher timer  */
	lv_display_delete_refr_timer :: proc(/* pointer to a display  */disp: ^lv_display_t) ---
	/* Register vsync event of a display. LV_EVENT_VSYNC event will be sent periodically. Please don't use it in display event listeners, as it may cause memory leaks and illegal access issues.  */
	lv_display_register_vsync_event :: proc(/* pointer to a display  */disp: ^lv_display_t, /* an event callback  */event_cb: lv_event_cb_t, /* optional user_data  */user_data: rawptr) -> bool ---
	/* Unregister vsync event of a display. LV_EVENT_VSYNC event won't be sent periodically. Please don't use it in display event listeners, as it may cause memory leaks and illegal access issues.  */
	lv_display_unregister_vsync_event :: proc(/* pointer to a display  */disp: ^lv_display_t, /* an event callback  */event_cb: lv_event_cb_t, /* optional user_data  */user_data: rawptr) -> bool ---
	/* Send an vsync event to a display LV_RESULT_OK: disp wasn't deleted in the event.  */
	lv_display_send_vsync_event :: proc(/* pointer to a display  */disp: ^lv_display_t, /* optional param  */param: rawptr) -> lv_result_t ---
	lv_display_set_user_data :: proc(disp: ^lv_display_t, user_data: rawptr) ---
	lv_display_set_driver_data :: proc(disp: ^lv_display_t, driver_data: rawptr) ---
	lv_display_get_user_data :: proc(disp: ^lv_display_t) -> rawptr ---
	lv_display_get_driver_data :: proc(disp: ^lv_display_t) -> rawptr ---
	lv_display_get_buf_active :: proc(disp: ^lv_display_t) -> ^lv_draw_buf_t ---
	/* Rotate an area in-place according to the display's rotation  */
	lv_display_rotate_area :: proc(/* pointer to a display  */disp: ^lv_display_t, /* pointer to an area to rotate  */area: ^lv_area_t) ---
	/* Get the size of the draw buffers the size of the draw buffer in bytes for valid display, 0 otherwise  */
	lv_display_get_draw_buf_size :: proc(/* pointer to a display  */disp: ^lv_display_t) -> u32 ---
	/* Get the size of the invalidated draw buffer. Can be used in the flush callback to get the number of bytes used in the current render buffer. the size of the invalidated draw buffer in bytes, not accounting for any preceding palette information for a valid display, 0 otherwise  */
	lv_display_get_invalidated_draw_buf_size :: proc(/* pointer to a display  */disp: ^lv_display_t, /* the width of the invalidated area  */width: u32, /* the height of the invalidated area  */height: u32) -> u32 ---
	/* For default display, computes the number of pixels (a distance or size) as if the display had 160 DPI. This allows you to specify 1/160-th fractions of an inch to get real distance on the display that will be consistent regardless of its current DPI. It ensures lv_dpx(100) , for example, will have the same physical size regardless to the DPI of the display. number of pixels to use to make that distance  */
	lv_dpx :: proc(/* number of 1/160-th-inch units to compute with  */n: i32) -> i32 ---
	/* For specified display, computes the number of pixels (a distance or size) as if the display had 160 DPI. This allows you to specify 1/160-th fractions of an inch to get real distance on the display that will be consistent regardless of its current DPI. It ensures lv_dpx(100) , for example, will have the same physical size regardless to the DPI of the display. number of pixels to use to make that distance  */
	lv_display_dpx :: proc(/* pointer to display whose dpi should be considered  */disp: ^lv_display_t, /* number of 1/160-th-inch units to compute with  */n: i32) -> i32 ---
	/* Delete an object and all of its children. Also remove the objects from their group and remove all animations (if any). Send LV_EVENT_DELETE to deleted objects.  */
	lv_obj_delete :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Delete all children of an object. Also remove the objects from their group and remove all animations (if any). Send LV_EVENT_DELETE to deleted objects.  */
	lv_obj_clean :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Delete an object after some delay  */
	lv_obj_delete_delayed :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* time to wait before delete in milliseconds  */delay_ms: u32) ---
	/* A function to be easily used in animation ready callback to delete an object when the animation is ready  */
	lv_obj_delete_anim_completed_cb :: proc(/* pointer to the animation  */a: ^lv_anim_t) ---
	/* Helper function for asynchronously deleting objects. Useful for cases where you can't delete an object directly in an LV_EVENT_DELETE handler (i.e. parent). :ref:`lv_async_call`  */
	lv_obj_delete_async :: proc(/* object to delete  */obj: ^lv_obj_t) ---
	/* Move the parent of an object. The relative coordinates will be kept.  */
	lv_obj_set_parent :: proc(/* pointer to an object whose parent needs to be changed  */obj: ^lv_obj_t, /* pointer to the new parent  */parent: ^lv_obj_t) ---
	/* Swap the positions of two objects. When used in listboxes, it can be used to sort the listbox items.  */
	lv_obj_swap :: proc(/* pointer to the first object  */obj1: ^lv_obj_t, /* pointer to the second object  */obj2: ^lv_obj_t) ---
	/* moves the object to the given index in its parent. When used in listboxes, it can be used to sort the listbox items. to move to the background: lv_obj_move_to_index(obj, 0)  to move forward (up): lv_obj_move_to_index(obj, lv_obj_get_index(obj) - 1)  */
	lv_obj_move_to_index :: proc(/* pointer to the object to be moved.  */obj: ^lv_obj_t, /* new index in parent. -1 to count from the back  */index: i32) ---
	/* Get the screen of an object pointer to the object's screen  */
	lv_obj_get_screen :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the display of the object pointer to the object's display  */
	lv_obj_get_display :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_display_t ---
	/* Get the parent of an object the parent of the object. (NULL if obj was a screen)  */
	lv_obj_get_parent :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the child of an object by the child's index. pointer to the child or NULL if the index was invalid  */
	lv_obj_get_child :: proc(/* pointer to an object whose child should be get  */obj: ^lv_obj_t, /* the index of the child. 0: the oldest (firstly created) child 1: the second oldest child count-1: the youngest -1: the youngest -2: the second youngest  */idx: i32) -> ^lv_obj_t ---
	/* Get the child of an object by the child's index. Consider the children only with a given type. pointer to the child or NULL if the index was invalid  */
	lv_obj_get_child_by_type :: proc(/* pointer to an object whose child should be get  */obj: ^lv_obj_t, /* the index of the child. 0: the oldest (firstly created) child 1: the second oldest child count-1: the youngest -1: the youngest -2: the second youngest  */idx: i32, /* the type of the children to check  */class_p: ^lv_obj_class_t) -> ^lv_obj_t ---
	/* Return a sibling of an object pointer to the requested sibling or NULL if there is no such sibling  */
	lv_obj_get_sibling :: proc(/* pointer to an object whose sibling should be get  */obj: ^lv_obj_t, /* 0: obj itself -1: the first older sibling -2: the next older sibling 1: the first younger sibling 2: the next younger sibling etc  */idx: i32) -> ^lv_obj_t ---
	/* Return a sibling of an object. Consider the siblings only with a given type. pointer to the requested sibling or NULL if there is no such sibling  */
	lv_obj_get_sibling_by_type :: proc(/* pointer to an object whose sibling should be get  */obj: ^lv_obj_t, /* 0: obj itself -1: the first older sibling -2: the next older sibling 1: the first younger sibling 2: the next younger sibling etc  */idx: i32, /* the type of the children to check  */class_p: ^lv_obj_class_t) -> ^lv_obj_t ---
	/* Get the number of children the number of children  */
	lv_obj_get_child_count :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the number of children having a given type. the number of children  */
	lv_obj_get_child_count_by_type :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the type of the children to check  */class_p: ^lv_obj_class_t) -> u32 ---
	/* Get the index of a child. the child index of the object. E.g. 0: the oldest (firstly created child). (-1 if child could not be found or no parent exists)  */
	lv_obj_get_index :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the index of a child. Consider the children only with a given type. the child index of the object. E.g. 0: the oldest (firstly created child with the given class). (-1 if child could not be found or no parent exists)  */
	lv_obj_get_index_by_type :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the type of the children to check  */class_p: ^lv_obj_class_t) -> i32 ---
	/* Iterate through all children of any object.  */
	lv_obj_tree_walk :: proc(/* start integrating from this object  */start_obj: ^lv_obj_t, /* call this callback on the objects  */cb: lv_obj_tree_walk_cb_t, /* pointer to any user related data (will be passed to cb )  */user_data: rawptr) ---
	/* Iterate through all children of any object and print their ID.  */
	lv_obj_dump_tree :: proc(/* start integrating from this object  */start_obj: ^lv_obj_t) ---
	/* Set the position of an object relative to the set alignment. With default alignment it's the distance from the top left corner  E.g. LV_ALIGN_CENTER alignment it's the offset from the center of the parent  The position is interpreted on the content area of the parent  The values can be set in pixel or in percentage of parent size with lv_pct(v)  */
	lv_obj_set_pos :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* new x coordinate  */x: i32, /* new y coordinate  */y: i32) ---
	/* Set the x coordinate of an object With default alignment it's the distance from the top left corner  E.g. LV_ALIGN_CENTER alignment it's the offset from the center of the parent  The position is interpreted on the content area of the parent  The values can be set in pixel or in percentage of parent size with lv_pct(v)  */
	lv_obj_set_x :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* new x coordinate  */x: i32) ---
	/* Set the y coordinate of an object With default alignment it's the distance from the top left corner  E.g. LV_ALIGN_CENTER alignment it's the offset from the center of the parent  The position is interpreted on the content area of the parent  The values can be set in pixel or in percentage of parent size with lv_pct(v)  */
	lv_obj_set_y :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* new y coordinate  */y: i32) ---
	/* Set the size of an object. possible values are: pixel simple set the size accordingly LV_SIZE_CONTENT set the size to involve all children in the given direction lv_pct(x) to set size in percentage of the parent's content area size (the size without paddings). x should be in [0..1000]% range  */
	lv_obj_set_size :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the new width  */w: i32, /* the new height  */h: i32) ---
	/* Recalculate the size of the object true: the size has been changed  */
	lv_obj_refr_size :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> bool ---
	/* Set the width of an object possible values are: pixel simple set the size accordingly LV_SIZE_CONTENT set the size to involve all children in the given direction lv_pct(x) to set size in percentage of the parent's content area size (the size without paddings). x should be in [0..1000]% range  */
	lv_obj_set_width :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the new width  */w: i32) ---
	/* Set the height of an object possible values are: pixel simple set the size accordingly LV_SIZE_CONTENT set the size to involve all children in the given direction lv_pct(x) to set size in percentage of the parent's content area size (the size without paddings). x should be in [0..1000]% range  */
	lv_obj_set_height :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the new height  */h: i32) ---
	/* Set the width reduced by the left and right padding and the border width.  */
	lv_obj_set_content_width :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the width without paddings in pixels  */w: i32) ---
	/* Set the height reduced by the top and bottom padding and the border width.  */
	lv_obj_set_content_height :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the height without paddings in pixels  */h: i32) ---
	/* Set a layout for an object  */
	lv_obj_set_layout :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to a layout descriptor to set  */layout: u32) ---
	/* Test whether the and object is positioned by a layout or not true: positioned by a layout; false: not positioned by a layout  */
	lv_obj_is_layout_positioned :: proc(/* pointer to an object to test  */obj: ^lv_obj_t) -> bool ---
	/* Mark the object for layout update.  */
	lv_obj_mark_layout_as_dirty :: proc(/* pointer to an object whose children need to be updated  */obj: ^lv_obj_t) ---
	/* Update the layout of an object.  */
	lv_obj_update_layout :: proc(/* pointer to an object whose position and size needs to be updated  */obj: ^lv_obj_t) ---
	/* Change the alignment of an object.  */
	lv_obj_set_align :: proc(/* pointer to an object to align  */obj: ^lv_obj_t, /* type of alignment (see 'lv_align_t' enum) LV_ALIGN_OUT_... can't be used.  */align: lv_align_t) ---
	/* Change the alignment of an object and set new coordinates. Equivalent to: lv_obj_set_align(obj, align); lv_obj_set_pos(obj, x_ofs, y_ofs);  */
	lv_obj_align :: proc(/* pointer to an object to align  */obj: ^lv_obj_t, /* type of alignment (see 'lv_align_t' enum) LV_ALIGN_OUT_... can't be used.  */align: lv_align_t, /* x coordinate offset after alignment  */x_ofs: i32, /* y coordinate offset after alignment  */y_ofs: i32) ---
	/* Align an object to another object. if the position or size of base changes obj needs to be aligned manually again  */
	lv_obj_align_to :: proc(/* pointer to an object to align  */obj: ^lv_obj_t, /* pointer to another object (if NULL obj s parent is used). 'obj' will be aligned to it.  */base: ^lv_obj_t, /* type of alignment (see 'lv_align_t' enum)  */align: lv_align_t, /* x coordinate offset after alignment  */x_ofs: i32, /* y coordinate offset after alignment  */y_ofs: i32) ---
	/* Align an object to the center on its parent. if the parent size changes obj needs to be aligned manually again  */
	lv_obj_center :: proc(/* pointer to an object to align  */obj: ^lv_obj_t) ---
	/* Set the transform matrix of an object LV_DRAW_TRANSFORM_USE_MATRIX needs to be enabled.  */
	lv_obj_set_transform :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to a matrix to set  */mtx: ^lv_matrix_t) ---
	/* Reset the transform matrix of an object to identity matrix LV_DRAW_TRANSFORM_USE_MATRIX needs to be enabled.  */
	lv_obj_reset_transform :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Copy the coordinates of an object to an area  */
	lv_obj_get_coords :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to an area to store the coordinates  */coords: ^lv_area_t) ---
	/* Get the x coordinate of object. distance of obj from the left side of its parent plus the parent's left padding  The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  Zero return value means the object is on the left padding of the parent, and not on the left edge.  Scrolling of the parent doesn't change the returned value.  The returned value is always the distance from the parent even if obj is positioned by a layout.  */
	lv_obj_get_x :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the x2 coordinate of object. distance of obj from the right side of its parent plus the parent's right padding  The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  Zero return value means the object is on the right padding of the parent, and not on the right edge.  Scrolling of the parent doesn't change the returned value.  The returned value is always the distance from the parent even if obj is positioned by a layout.  */
	lv_obj_get_x2 :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the y coordinate of object. distance of obj from the top side of its parent plus the parent's top padding  The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  Zero return value means the object is on the top padding of the parent, and not on the top edge.  Scrolling of the parent doesn't change the returned value.  The returned value is always the distance from the parent even if obj is positioned by a layout.  */
	lv_obj_get_y :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the y2 coordinate of object. distance of obj from the bottom side of its parent plus the parent's bottom padding  The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  Zero return value means the object is on the bottom padding of the parent, and not on the bottom edge.  Scrolling of the parent doesn't change the returned value.  The returned value is always the distance from the parent even if obj is positioned by a layout.  */
	lv_obj_get_y2 :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the actually set x coordinate of object, i.e. the offset from the set alignment the set x coordinate  */
	lv_obj_get_x_aligned :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the actually set y coordinate of object, i.e. the offset from the set alignment the set y coordinate  */
	lv_obj_get_y_aligned :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the width of an object The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  the width in pixels  */
	lv_obj_get_width :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the height of an object The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  the height in pixels  */
	lv_obj_get_height :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the width reduced by the left and right padding and the border width. The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  the width which still fits into its parent without causing overflow (making the parent scrollable)  */
	lv_obj_get_content_width :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the height reduced by the top and bottom padding and the border width. The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  the height which still fits into the parent without causing overflow (making the parent scrollable)  */
	lv_obj_get_content_height :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the area reduced by the paddings and the border width. The position of the object is recalculated only on the next redraw. To force coordinate recalculation call lv_obj_update_layout(obj) .  */
	lv_obj_get_content_coords :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the area which still fits into the parent without causing overflow (making the parent scrollable)  */area: ^lv_area_t) ---
	/* Get the width occupied by the "parts" of the widget. E.g. the width of all columns of a table. the width of the virtually drawn content  This size independent from the real size of the widget. It just tells how large the internal ("virtual") content is.  */
	lv_obj_get_self_width :: proc(/* pointer to an objects  */obj: ^lv_obj_t) -> i32 ---
	/* Get the height occupied by the "parts" of the widget. E.g. the height of all rows of a table. the width of the virtually drawn content  This size independent from the real size of the widget. It just tells how large the internal ("virtual") content is.  */
	lv_obj_get_self_height :: proc(/* pointer to an objects  */obj: ^lv_obj_t) -> i32 ---
	/* Handle if the size of the internal ("virtual") content of an object has changed. false: nothing happened; true: refresh happened  */
	lv_obj_refresh_self_size :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> bool ---
	lv_obj_refr_pos :: proc(obj: ^lv_obj_t) ---
	lv_obj_move_to :: proc(obj: ^lv_obj_t, x: i32, y: i32) ---
	lv_obj_move_children_by :: proc(obj: ^lv_obj_t, x_diff: i32, y_diff: i32, ignore_floating: bool) ---
	/* Get the transform matrix of an object pointer to the transform matrix or NULL if not set  */
	lv_obj_get_transform :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_matrix_t ---
	/* Transform a point using the angle and zoom style properties of an object  */
	lv_obj_transform_point :: proc(/* pointer to an object whose style properties should be used  */obj: ^lv_obj_t, /* a point to transform, the result will be written back here too  */p: ^lv_point_t, /* OR-ed valued of :cpp:enum: lv_obj_point_transform_flag_t  */flags: lv_obj_point_transform_flag_t) ---
	/* Transform an array of points using the angle and zoom style properties of an object  */
	lv_obj_transform_point_array :: proc(/* pointer to an object whose style properties should be used  */obj: ^lv_obj_t, /* the array of points to transform, the result will be written back here too  */points: []lv_point_t, /* number of points in the array  */count: uint, /* OR-ed valued of :cpp:enum: lv_obj_point_transform_flag_t  */flags: lv_obj_point_transform_flag_t) ---
	/* Transform an area using the angle and zoom style properties of an object  */
	lv_obj_get_transformed_area :: proc(/* pointer to an object whose style properties should be used  */obj: ^lv_obj_t, /* an area to transform, the result will be written back here too  */area: ^lv_area_t, /* OR-ed valued of :cpp:enum: lv_obj_point_transform_flag_t  */flags: lv_obj_point_transform_flag_t) ---
	/* Mark an area of an object as invalid. The area will be truncated to the object's area and marked for redraw. LV_RESULT_OK: the area is invalidated; LV_RESULT_INVALID: the area wasn't invalidated. (maybe it was off-screen or fully clipped)  */
	lv_obj_invalidate_area :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the area to redraw  */area: ^lv_area_t) -> lv_result_t ---
	/* Mark the object as invalid to redrawn its area LV_RESULT_OK: the area is invalidated; LV_RESULT_INVALID: the area wasn't invalidated. (maybe it was off-screen or fully clipped)  */
	lv_obj_invalidate :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> lv_result_t ---
	/* Tell whether an area of an object is visible (even partially) now or not true visible; false not visible (hidden, out of parent, on other screen, etc)  */
	lv_obj_area_is_visible :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the are to check. The visible part of the area will be written back here.  */area: ^lv_area_t) -> bool ---
	/* Tell whether an object is visible (even partially) now or not true: visible; false not visible (hidden, out of parent, on other screen, etc)  */
	lv_obj_is_visible :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> bool ---
	/* Set the size of an extended clickable area  */
	lv_obj_set_ext_click_area :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* extended clickable area in all 4 directions [px]  */size: i32) ---
	/* Get the an area where to object can be clicked. It's the object's normal area plus the extended click area.  */
	lv_obj_get_click_area :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* store the result area here  */area: ^lv_area_t) ---
	/* Hit-test an object given a particular point in screen space. true: if the object is considered under the point  */
	lv_obj_hit_test :: proc(/* object to hit-test  */obj: ^lv_obj_t, /* screen-space point (absolute coordinate)  */point: ^lv_point_t) -> bool ---
	/* Clamp a width between min and max width. If the min/max width is in percentage value use the ref_width the clamped width  */
	lv_clamp_width :: proc(/* width to clamp  */width: i32, /* the minimal width  */min_width: i32, /* the maximal width  */max_width: i32, /* the reference width used when min/max width is in percentage  */ref_width: i32) -> i32 ---
	/* Clamp a height between min and max height. If the min/max height is in percentage value use the ref_height the clamped height  */
	lv_clamp_height :: proc(/* height to clamp  */height: i32, /* the minimal height  */min_height: i32, /* the maximal height  */max_height: i32, /* the reference height used when min/max height is in percentage  */ref_height: i32) -> i32 ---
	/* The computed width for the object: If the style width is a fixed value, that value is returned.  If the style width is LV_SIZE_CONTENT , the content width is calculated and returned.  If the style width is a LV_PCT() , the percentage is applied to the parent's width.  */
	lv_obj_calc_dynamic_width :: proc(/* Pointer to the LVGL object whose width is being calculated.  */obj: ^lv_obj_t, /* Which style width to calculate for. Valid values are: LV_STYLE_WIDTH, LV_STYLE_MIN_WIDTH, or LV_STYLE_MAX_WIDTH.  */prop: lv_style_prop_t, /* Pointer to an integer storing the object's content width. If negative and width is LV_SIZE_CONTENT , it will be calculated.  */content_width: ^i32) -> i32 ---
	/* The computed height for the object: If the style height is a fixed value, that value is returned.  If the style height is LV_SIZE_CONTENT , the content height is calculated and returned.  If the style height is a LV_PCT() , the percentage is applied to the parent's height.  */
	lv_obj_calc_dynamic_height :: proc(/* Pointer to the LVGL object whose height is being calculated.  */obj: ^lv_obj_t, /* Which style height to calculate for. Valid values are: LV_STYLE_HEIGHT, LV_STYLE_MIN_HEIGHT, or LV_STYLE_MAX_HEIGHT.  */prop: lv_style_prop_t, /* Pointer to an integer storing the object's content height. If negative and height is LV_SIZE_CONTENT , it will be calculated.  */content_height: ^i32) -> i32 ---
	/* Set how the scrollbars should behave.  */
	lv_obj_set_scrollbar_mode :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* LV_SCROLL_MODE_ON/OFF/AUTO/ACTIVE  */mode: lv_scrollbar_mode_t) ---
	/* Set direction Widget can be scrolled  */
	lv_obj_set_scroll_dir :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* one or more bit-wise OR-ed values of lv_dir_t enumeration  */dir: lv_dir_t) ---
	/* Set where to snap the children when scrolling ends horizontally  */
	lv_obj_set_scroll_snap_x :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* value from lv_scroll_snap_t enumeration  */align: lv_scroll_snap_t) ---
	/* Set where to snap the children when scrolling ends vertically  */
	lv_obj_set_scroll_snap_y :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* value from lv_scroll_snap_t enumeration  */align: lv_scroll_snap_t) ---
	/* Get the current scroll mode (when to hide the scrollbars) the current scroll mode from lv_scrollbar_mode_t  */
	lv_obj_get_scrollbar_mode :: proc(/* pointer to Widget  */obj: ^lv_obj_t) -> lv_scrollbar_mode_t ---
	/* Get directions Widget can be scrolled (set with :ref:`lv_obj_set_scroll_dir()` ) current scroll direction bit(s)  */
	lv_obj_get_scroll_dir :: proc(/* pointer to Widget  */obj: ^lv_obj_t) -> lv_dir_t ---
	/* Get where to snap child Widgets when horizontal scrolling ends. current snap value from lv_scroll_snap_t  */
	lv_obj_get_scroll_snap_x :: proc(/* pointer to Widget  */obj: ^lv_obj_t) -> lv_scroll_snap_t ---
	/* Get where to snap child Widgets when vertical scrolling ends. current snap value from lv_scroll_snap_t  */
	lv_obj_get_scroll_snap_y :: proc(/* pointer to Widget  */obj: ^lv_obj_t) -> lv_scroll_snap_t ---
	/* Get current X scroll position. Identical to :ref:`lv_obj_get_scroll_left()` . current scroll position from left edge If Widget is not scrolled return 0. If scrolled return > 0. If scrolled inside (elastic scroll) return < 0.  */
	lv_obj_get_scroll_x :: proc(/* pointer to scrollable container Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Get current Y scroll position. Identical to :ref:`lv_obj_get_scroll_top()` . current scroll position from top edge If Widget is not scrolled return 0. If scrolled return > 0. If scrolled inside (elastic scroll) return < 0.  */
	lv_obj_get_scroll_y :: proc(/* pointer to scrollable container Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Number of pixels a scrollable container Widget can be scrolled down before its top edge appears. When LV_OBJ_FLAG_SCROLL_ELASTIC flag is set in Widget, this value can go negative while Widget is being dragged below its normal top-edge boundary. pixels Widget can be scrolled down before its top edge appears  */
	lv_obj_get_scroll_top :: proc(/* pointer to scrollable container Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Number of pixels a scrollable container Widget can be scrolled up before its bottom edge appears. When LV_OBJ_FLAG_SCROLL_ELASTIC flag is set in Widget, this value can go negative while Widget is being dragged above its normal bottom-edge boundary. pixels Widget can be scrolled up before its bottom edge appears  */
	lv_obj_get_scroll_bottom :: proc(/* pointer to scrollable container Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Number of pixels a scrollable container Widget can be scrolled right before its left edge appears. When LV_OBJ_FLAG_SCROLL_ELASTIC flag is set in Widget, this value can go negative while Widget is being dragged farther right than its normal left-edge boundary. pixels Widget can be scrolled right before its left edge appears  */
	lv_obj_get_scroll_left :: proc(/* pointer to scrollable container Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Number of pixels a scrollable container Widget can be scrolled left before its right edge appears. When LV_OBJ_FLAG_SCROLL_ELASTIC flag is set in Widget, this value can go negative while Widget is being dragged farther left than its normal right-edge boundary. pixels Widget can be scrolled left before its right edge appears  */
	lv_obj_get_scroll_right :: proc(/* pointer to scrollable container Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Get the X and Y coordinates where the scrolling will end for Widget if a scrolling animation is in progress. If no scrolling animation, give the current x or y scroll position.  */
	lv_obj_get_scroll_end :: proc(/* pointer to scrollable Widget  */obj: ^lv_obj_t, /* pointer to :ref:`lv_point_t` object in which to store result  */end: ^lv_point_t) ---
	/* Scroll by given amount of pixels. > 0 value means scroll right/bottom (show the more content on the right/bottom)  e.g. dy = -20 means scroll down 20 px  */
	lv_obj_scroll_by :: proc(/* pointer to scrollable Widget to scroll  */obj: ^lv_obj_t, /* pixels to scroll horizontally  */dx: i32, /* pixels to scroll vertically  */dy: i32, /* LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately  */anim_en: lv_anim_enable_t) ---
	/* Scroll by given amount of pixels. dx and dy will be limited internally to allow scrolling only on the content area. e.g. dy = -20 means scroll down 20 px  */
	lv_obj_scroll_by_bounded :: proc(/* pointer to scrollable Widget to scroll  */obj: ^lv_obj_t, /* pixels to scroll horizontally  */dx: i32, /* pixels to scroll vertically  */dy: i32, /* LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately  */anim_en: lv_anim_enable_t) ---
	/* Scroll to given coordinate on Widget. x and y will be limited internally to allow scrolling only on the content area.  */
	lv_obj_scroll_to :: proc(/* pointer to scrollable Widget to scroll  */obj: ^lv_obj_t, /* pixels to scroll horizontally  */x: i32, /* pixels to scroll vertically  */y: i32, /* LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately  */anim_en: lv_anim_enable_t) ---
	/* Scroll to X coordinate on Widget. x will be limited internally to allow scrolling only on the content area.  */
	lv_obj_scroll_to_x :: proc(/* pointer to scrollable Widget to scroll  */obj: ^lv_obj_t, /* pixels to scroll horizontally  */x: i32, /* LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately  */anim_en: lv_anim_enable_t) ---
	/* Scroll to Y coordinate on Widget. y will be limited internally to allow scrolling only on the content area.  */
	lv_obj_scroll_to_y :: proc(/* pointer to scrollable Widget to scroll  */obj: ^lv_obj_t, /* pixels to scroll vertically  */y: i32, /* LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately  */anim_en: lv_anim_enable_t) ---
	/* Scroll obj 's parent Widget until obj becomes visible.  */
	lv_obj_scroll_to_view :: proc(/* pointer to Widget to scroll into view  */obj: ^lv_obj_t, /* LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately  */anim_en: lv_anim_enable_t) ---
	/* Scroll obj 's parent Widgets recursively until obj becomes visible. Widget will be scrolled into view even it has nested scrollable parents.  */
	lv_obj_scroll_to_view_recursive :: proc(/* pointer to Widget to scroll into view  */obj: ^lv_obj_t, /* LV_ANIM_ON: scroll with animation; LV_ANIM_OFF: scroll immediately  */anim_en: lv_anim_enable_t) ---
	/* Tell whether Widget is being scrolled or not at this moment true: obj is being scrolled  */
	lv_obj_is_scrolling :: proc(/* pointer to Widget  */obj: ^lv_obj_t) -> bool ---
	/* Stop scrolling the current object  */
	lv_obj_stop_scroll_anim :: proc(/* The object being scrolled  */obj: ^lv_obj_t) ---
	/* Check children of obj and scroll obj to fulfill scroll_snap settings.  */
	lv_obj_update_snap :: proc(/* Widget whose children need to be checked and snapped  */obj: ^lv_obj_t, /* LV_ANIM_ON/OFF  */anim_en: lv_anim_enable_t) ---
	/* Get the area of the scrollbars  */
	lv_obj_get_scrollbar_area :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to store the area of the horizontal scrollbar  */hor: ^lv_area_t, /* pointer to store the area of the vertical scrollbar  */ver: ^lv_area_t) ---
	/* Invalidate the area of the scrollbars  */
	lv_obj_scrollbar_invalidate :: proc(/* pointer to Widget  */obj: ^lv_obj_t) ---
	/* Checks if the content is scrolled "in" and adjusts it to a normal position.  */
	lv_obj_readjust_scroll :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* LV_ANIM_ON/OFF  */anim_en: lv_anim_enable_t) ---
	/* Add a style to an object. lv_obj_add_style(btn, &style_btn, 0); //Default button style lv_obj_add_style(btn, &btn_red, LV_STATE_PRESSED); //Overwrite only some colors to red when pressed  */
	lv_obj_add_style :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to a style to add  */style: ^lv_style_t, /* OR-ed value of parts and state to which the style should be added  */selector: lv_style_selector_t) ---
	/* Replaces a style of an object, preserving the order of the style stack (local styles and transitions are ignored). lv_obj_replace_style(obj, &yellow_style, &blue_style, LV_PART_ANY | LV_STATE_ANY); //Replace a specific style lv_obj_replace_style(obj, &yellow_style, &blue_style, LV_PART_MAIN | LV_STATE_PRESSED); //Replace a specific style assigned to the main part when it is pressed  */
	lv_obj_replace_style :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to a style to replace.  */old_style: ^lv_style_t, /* pointer to a style to replace the old style with.  */new_style: ^lv_style_t, /* OR-ed values of states and a part to replace only styles with matching selectors. LV_STATE_ANY and LV_PART_ANY can be used  */selector: lv_style_selector_t) -> bool ---
	/* Remove a style from an object. lv_obj_remove_style(obj, &style, LV_PART_ANY | LV_STATE_ANY); //Remove a specific style lv_obj_remove_style(obj, NULL, LV_PART_MAIN | LV_STATE_ANY); //Remove all styles from the main part  lv_obj_remove_style(obj, NULL, LV_PART_ANY | LV_STATE_ANY); //Remove all styles  */
	lv_obj_remove_style :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to a style to remove. Can be NULL to check only the selector  */style: ^lv_style_t, /* OR-ed values of states and a part to remove only styles with matching selectors. LV_STATE_ANY and LV_PART_ANY can be used  */selector: lv_style_selector_t) ---
	/* Remove all styles from an object  */
	lv_obj_remove_style_all :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Notify all object if a style is modified  */
	lv_obj_report_style_change :: proc(/* pointer to a style. Only the objects with this style will be notified (NULL to notify all objects)  */style: ^lv_style_t) ---
	/* Notify an object and its children about its style is modified.  */
	lv_obj_refresh_style :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the part whose style was changed. E.g. LV_PART_ANY , LV_PART_MAIN  */part: lv_part_t, /* LV_STYLE_PROP_ANY or an LV_STYLE_... property. It is used to optimize what needs to be refreshed. LV_STYLE_PROP_INV to perform only a style cache update  */prop: lv_style_prop_t) ---
	/* Temporary disable a style for a selector. It will look like is the style wasn't added  */
	lv_obj_style_set_disabled :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to a style  */style: ^lv_style_t, /* the selector of a style (e.g. LV_STATE_PRESSED | LV_PART_KNOB)  */selector: lv_style_selector_t, /* true: disable the style, false: enable the style  */dis: bool) ---
	/* Get if a given style is disabled on an object. true: disable the style, false: enable the style  */
	lv_obj_style_get_disabled :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to a style  */style: ^lv_style_t, /* the selector of a style (e.g. LV_STATE_PRESSED | LV_PART_KNOB)  */selector: lv_style_selector_t) -> bool ---
	/* Enable or disable automatic style refreshing when a new style is added/removed to/from an object or any other style change happens.  */
	lv_obj_enable_style_refresh :: proc(/* true: enable refreshing; false: disable refreshing  */en: bool) ---
	/* Get the value of a style property. The current state of the object will be considered. Inherited properties will be inherited. If a property is not set a default value will be returned. the value of the property. Should be read from the correct field of the :ref:`lv_style_value_t` according to the type of the property.  */
	lv_obj_get_style_prop :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* a part from which the property should be get  */part: lv_part_t, /* the property to get  */prop: lv_style_prop_t) -> lv_style_value_t ---
	/* Check if an object has a specified style property for a given style selector. true if the object has the specified selector and property, false otherwise.  */
	lv_obj_has_style_prop :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the style selector to be checked, defining the scope of the style to be examined.  */selector: lv_style_selector_t, /* the property to be checked.  */prop: lv_style_prop_t) -> bool ---
	/* Set local style property on an object's part and state.  */
	lv_obj_set_local_style_prop :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the property  */prop: lv_style_prop_t, /* value of the property. The correct element should be set according to the type of the property  */value: lv_style_value_t, /* OR-ed value of parts and state for which the style should be set  */selector: lv_style_selector_t) ---
	lv_obj_get_local_style_prop :: proc(obj: ^lv_obj_t, prop: lv_style_prop_t, value: ^lv_style_value_t, selector: lv_style_selector_t) -> lv_style_res_t ---
	/* Remove a local style property from a part of an object with a given state. true the property was found and removed; false: the property was not found  */
	lv_obj_remove_local_style_prop :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* a style property to remove.  */prop: lv_style_prop_t, /* OR-ed value of parts and state for which the style should be removed  */selector: lv_style_selector_t) -> bool ---
	/* Used internally for color filtering  */
	lv_obj_style_apply_color_filter :: proc(obj: ^lv_obj_t, part: lv_part_t, v: lv_style_value_t) -> lv_style_value_t ---
	/* Fade in an an object and all its children.  */
	lv_obj_fade_in :: proc(/* the object to fade in  */obj: ^lv_obj_t, /* time of fade  */time: u32, /* delay to start the animation  */delay: u32) ---
	/* Fade out an an object and all its children.  */
	lv_obj_fade_out :: proc(/* the object to fade out  */obj: ^lv_obj_t, /* time of fade  */time: u32, /* delay to start the animation  */delay: u32) ---
	lv_obj_style_get_selector_state :: proc(selector: lv_style_selector_t) -> lv_state_t ---
	lv_obj_style_get_selector_part :: proc(selector: lv_style_selector_t) -> lv_part_t ---
	lv_obj_get_style_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_min_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_max_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_height :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_min_height :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_max_height :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_length :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_x :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_y :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_align :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_align_t ---
	lv_obj_get_style_transform_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_height :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_translate_x :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_translate_y :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_translate_radial :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_scale_x :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_scale_y :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_rotation :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_pivot_x :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_pivot_y :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_skew_x :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_skew_y :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_pad_top :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_pad_bottom :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_pad_left :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_pad_right :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_pad_row :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_pad_column :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_pad_radial :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_margin_top :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_margin_bottom :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_margin_left :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_margin_right :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_bg_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_bg_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_bg_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_bg_grad_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_bg_grad_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_bg_grad_dir :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_grad_dir_t ---
	lv_obj_get_style_bg_main_stop :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_bg_grad_stop :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_bg_main_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_bg_grad_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_bg_grad :: proc(obj: ^lv_obj_t, part: lv_part_t) -> ^lv_grad_dsc_t ---
	lv_obj_get_style_bg_image_src :: proc(obj: ^lv_obj_t, part: lv_part_t) -> rawptr ---
	lv_obj_get_style_bg_image_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_bg_image_recolor :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_bg_image_recolor_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_bg_image_recolor_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_bg_image_tiled :: proc(obj: ^lv_obj_t, part: lv_part_t) -> bool ---
	lv_obj_get_style_border_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_border_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_border_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_border_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_border_side :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_border_side_t ---
	lv_obj_get_style_border_post :: proc(obj: ^lv_obj_t, part: lv_part_t) -> bool ---
	lv_obj_get_style_outline_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_outline_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_outline_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_outline_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_outline_pad :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_shadow_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_shadow_offset_x :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_shadow_offset_y :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_shadow_spread :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_shadow_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_shadow_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_shadow_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_image_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_image_recolor :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_image_recolor_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_image_recolor_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_image_colorkey :: proc(obj: ^lv_obj_t, part: lv_part_t) -> ^lv_image_colorkey_t ---
	lv_obj_get_style_line_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_line_dash_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_line_dash_gap :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_line_rounded :: proc(obj: ^lv_obj_t, part: lv_part_t) -> bool ---
	lv_obj_get_style_line_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_line_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_line_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_arc_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_arc_rounded :: proc(obj: ^lv_obj_t, part: lv_part_t) -> bool ---
	lv_obj_get_style_arc_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_arc_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_arc_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_arc_image_src :: proc(obj: ^lv_obj_t, part: lv_part_t) -> rawptr ---
	lv_obj_get_style_text_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_text_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_text_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_text_font :: proc(obj: ^lv_obj_t, part: lv_part_t) -> ^lv_font_t ---
	lv_obj_get_style_text_letter_space :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_text_line_space :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_text_decor :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_text_decor_t ---
	lv_obj_get_style_text_align :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_text_align_t ---
	lv_obj_get_style_text_outline_stroke_color :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_text_outline_stroke_color_filtered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_text_outline_stroke_width :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_text_outline_stroke_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_radius :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_radial_offset :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_clip_corner :: proc(obj: ^lv_obj_t, part: lv_part_t) -> bool ---
	lv_obj_get_style_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_opa_layered :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_color_filter_dsc :: proc(obj: ^lv_obj_t, part: lv_part_t) -> ^lv_color_filter_dsc_t ---
	lv_obj_get_style_color_filter_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_recolor :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_color_t ---
	lv_obj_get_style_recolor_opa :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_opa_t ---
	lv_obj_get_style_blur_radius :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_blur_backdrop :: proc(obj: ^lv_obj_t, part: lv_part_t) -> bool ---
	lv_obj_get_style_blur_quality :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_blur_quality_t ---
	lv_obj_get_style_anim :: proc(obj: ^lv_obj_t, part: lv_part_t) -> ^lv_anim_t ---
	lv_obj_get_style_anim_duration :: proc(obj: ^lv_obj_t, part: lv_part_t) -> u32 ---
	lv_obj_get_style_transition :: proc(obj: ^lv_obj_t, part: lv_part_t) -> ^lv_style_transition_dsc_t ---
	lv_obj_get_style_blend_mode :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_blend_mode_t ---
	lv_obj_get_style_layout :: proc(obj: ^lv_obj_t, part: lv_part_t) -> u16 ---
	lv_obj_get_style_base_dir :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_base_dir_t ---
	lv_obj_get_style_bitmap_mask_src :: proc(obj: ^lv_obj_t, part: lv_part_t) -> rawptr ---
	lv_obj_get_style_rotary_sensitivity :: proc(obj: ^lv_obj_t, part: lv_part_t) -> u32 ---
	lv_obj_get_style_flex_flow :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_flex_flow_t ---
	lv_obj_get_style_flex_main_place :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_flex_align_t ---
	lv_obj_get_style_flex_cross_place :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_flex_align_t ---
	lv_obj_get_style_flex_track_place :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_flex_align_t ---
	lv_obj_get_style_flex_grow :: proc(obj: ^lv_obj_t, part: lv_part_t) -> u8 ---
	lv_obj_get_style_grid_column_dsc_array :: proc(obj: ^lv_obj_t, part: lv_part_t) -> ^i32 ---
	lv_obj_get_style_grid_column_align :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_grid_align_t ---
	lv_obj_get_style_grid_row_dsc_array :: proc(obj: ^lv_obj_t, part: lv_part_t) -> ^i32 ---
	lv_obj_get_style_grid_row_align :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_grid_align_t ---
	lv_obj_get_style_grid_cell_column_pos :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_grid_cell_x_align :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_grid_align_t ---
	lv_obj_get_style_grid_cell_column_span :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_grid_cell_row_pos :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_grid_cell_y_align :: proc(obj: ^lv_obj_t, part: lv_part_t) -> lv_grid_align_t ---
	lv_obj_get_style_grid_cell_row_span :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_set_style_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_min_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_max_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_height :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_min_height :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_max_height :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_length :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_x :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_y :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_align :: proc(obj: ^lv_obj_t, value: lv_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_height :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_translate_x :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_translate_y :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_translate_radial :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_scale_x :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_scale_y :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_rotation :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_pivot_x :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_pivot_y :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_skew_x :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_skew_y :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_top :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_bottom :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_left :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_right :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_row :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_column :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_radial :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_margin_top :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_margin_bottom :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_margin_left :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_margin_right :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_grad_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_grad_dir :: proc(obj: ^lv_obj_t, value: lv_grad_dir_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_main_stop :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_grad_stop :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_main_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_grad_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_grad :: proc(obj: ^lv_obj_t, value: ^lv_grad_dsc_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_image_src :: proc(obj: ^lv_obj_t, value: rawptr, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_image_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_image_recolor :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_image_recolor_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bg_image_tiled :: proc(obj: ^lv_obj_t, value: bool, selector: lv_style_selector_t) ---
	lv_obj_set_style_border_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_border_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_border_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_border_side :: proc(obj: ^lv_obj_t, value: lv_border_side_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_border_post :: proc(obj: ^lv_obj_t, value: bool, selector: lv_style_selector_t) ---
	lv_obj_set_style_outline_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_outline_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_outline_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_outline_pad :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_shadow_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_shadow_offset_x :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_shadow_offset_y :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_shadow_spread :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_shadow_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_shadow_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_image_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_image_recolor :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_image_recolor_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_image_colorkey :: proc(obj: ^lv_obj_t, value: ^lv_image_colorkey_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_line_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_line_dash_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_line_dash_gap :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_line_rounded :: proc(obj: ^lv_obj_t, value: bool, selector: lv_style_selector_t) ---
	lv_obj_set_style_line_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_line_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_arc_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_arc_rounded :: proc(obj: ^lv_obj_t, value: bool, selector: lv_style_selector_t) ---
	lv_obj_set_style_arc_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_arc_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_arc_image_src :: proc(obj: ^lv_obj_t, value: rawptr, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_font :: proc(obj: ^lv_obj_t, value: ^lv_font_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_letter_space :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_line_space :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_decor :: proc(obj: ^lv_obj_t, value: lv_text_decor_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_align :: proc(obj: ^lv_obj_t, value: lv_text_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_outline_stroke_color :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_outline_stroke_width :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_text_outline_stroke_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_radius :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_radial_offset :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_clip_corner :: proc(obj: ^lv_obj_t, value: bool, selector: lv_style_selector_t) ---
	lv_obj_set_style_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_opa_layered :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_color_filter_dsc :: proc(obj: ^lv_obj_t, value: ^lv_color_filter_dsc_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_color_filter_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_recolor :: proc(obj: ^lv_obj_t, value: lv_color_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_recolor_opa :: proc(obj: ^lv_obj_t, value: lv_opa_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_blur_radius :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_blur_backdrop :: proc(obj: ^lv_obj_t, value: bool, selector: lv_style_selector_t) ---
	lv_obj_set_style_blur_quality :: proc(obj: ^lv_obj_t, value: lv_blur_quality_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_anim :: proc(obj: ^lv_obj_t, value: ^lv_anim_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_anim_duration :: proc(obj: ^lv_obj_t, value: u32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transition :: proc(obj: ^lv_obj_t, value: ^lv_style_transition_dsc_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_blend_mode :: proc(obj: ^lv_obj_t, value: lv_blend_mode_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_layout :: proc(obj: ^lv_obj_t, value: u16, selector: lv_style_selector_t) ---
	lv_obj_set_style_base_dir :: proc(obj: ^lv_obj_t, value: lv_base_dir_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_bitmap_mask_src :: proc(obj: ^lv_obj_t, value: rawptr, selector: lv_style_selector_t) ---
	lv_obj_set_style_rotary_sensitivity :: proc(obj: ^lv_obj_t, value: u32, selector: lv_style_selector_t) ---
	lv_obj_set_style_flex_flow :: proc(obj: ^lv_obj_t, value: lv_flex_flow_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_flex_main_place :: proc(obj: ^lv_obj_t, value: lv_flex_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_flex_cross_place :: proc(obj: ^lv_obj_t, value: lv_flex_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_flex_track_place :: proc(obj: ^lv_obj_t, value: lv_flex_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_flex_grow :: proc(obj: ^lv_obj_t, value: u8, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_column_dsc_array :: proc(obj: ^lv_obj_t, value: ^i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_column_align :: proc(obj: ^lv_obj_t, value: lv_grid_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_row_dsc_array :: proc(obj: ^lv_obj_t, value: ^i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_row_align :: proc(obj: ^lv_obj_t, value: lv_grid_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_cell_column_pos :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_cell_x_align :: proc(obj: ^lv_obj_t, value: lv_grid_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_cell_column_span :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_cell_row_pos :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_cell_y_align :: proc(obj: ^lv_obj_t, value: lv_grid_align_t, selector: lv_style_selector_t) ---
	lv_obj_set_style_grid_cell_row_span :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_all :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_hor :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_ver :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_margin_all :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_margin_hor :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_margin_ver :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_pad_gap :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_size :: proc(obj: ^lv_obj_t, width: i32, height: i32, selector: lv_style_selector_t) ---
	lv_obj_set_style_transform_scale :: proc(obj: ^lv_obj_t, value: i32, selector: lv_style_selector_t) ---
	lv_obj_get_style_space_left :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_space_right :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_space_top :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_space_bottom :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_calculate_style_text_align :: proc(obj: ^lv_obj_t, part: lv_part_t, txt: ^u8) -> lv_text_align_t ---
	lv_obj_get_style_transform_scale_x_safe :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	lv_obj_get_style_transform_scale_y_safe :: proc(obj: ^lv_obj_t, part: lv_part_t) -> i32 ---
	/* Get the opa style property from all parents and multiply and >> 8 them. the final opacity considering the parents' opacity too  */
	lv_obj_get_style_opa_recursive :: proc(/* the object whose opacity should be get  */obj: ^lv_obj_t, /* the part whose opacity should be get. Non-MAIN parts will consider the opa of the MAIN part too  */part: lv_part_t) -> lv_opa_t ---
	/* Apply recolor effect to the input color based on the object's style properties. the blended color after applying recolor and opacity  */
	lv_obj_style_apply_recolor :: proc(/* the target object containing recolor style properties  */obj: ^lv_obj_t, /* the part to retrieve recolor styles.  */part: lv_part_t, /* the original color to be modified  */color: lv_color32_t) -> lv_color32_t ---
	/* Get the recolor style property from all parents and blend them recursively. the final blended recolor value combining all parent's recolor values  */
	lv_obj_get_style_recolor_recursive :: proc(/* the object whose recolor value should be retrieved  */obj: ^lv_obj_t, /* the target part to check. Non-MAIN parts will also consider the recolor value from the MAIN part during calculation  */part: lv_part_t) -> lv_color32_t ---
	/* Disable a style if a subject's value is not equal to a reference value pointer to newly-created Observer  */
	lv_obj_bind_style :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to a style  */style: ^lv_style_t, /* pointer to a selector  */selector: lv_style_selector_t, /* pointer to Subject  */subject: ^lv_subject_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Connect a subject's value to a style property of a widget. pointer to newly-created Observer  */
	lv_obj_bind_style_prop :: proc(/* pointer to a Widget  */obj: ^lv_obj_t, /* a style property  */prop: lv_style_prop_t, /* a selector for which the property should be added, e.g. LV_PART_KNOB | LV_STATE_PRESSED  */selector: lv_style_selector_t, /* pointer a Subject to which value the property should be bound  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Initialize a file system driver with default values. It is used to ensure all fields have known values and not memory junk. After it you can set the fields.  */
	lv_fs_drv_init :: proc(/* pointer to driver variable to initialize  */drv: ^lv_fs_drv_t) ---
	/* Add a new drive  */
	lv_fs_drv_register :: proc(/* pointer to an lv_fs_drv_t structure which is inited with the corresponding function pointers. Only pointer is saved, so the driver should be static or dynamically allocated.  */drv: ^lv_fs_drv_t) ---
	/* Give a pointer to a driver from its letter pointer to a driver or NULL if not found  */
	lv_fs_get_drv :: proc(/* the driver-identifier letter  */letter: u8) -> ^lv_fs_drv_t ---
	/* Remove a drive and call its remove function if available  */
	lv_fs_remove_drive :: proc(/* letter identifier of the drive to remove  */letter: u8) ---
	/* Test if a drive is ready or not. If the ready function was not initialized true will be returned. true: drive is ready; false: drive is not ready  */
	lv_fs_is_ready :: proc(/* letter of the drive  */letter: u8) -> bool ---
	/* Open a file LV_FS_RES_OK or any error from lv_fs_res_t enum  */
	lv_fs_open :: proc(/* pointer to a :ref:`lv_fs_file_t` variable  */file_p: ^lv_fs_file_t, /* path to the file beginning with the driver letter (e.g. S:/folder/file.txt)  */path: ^u8, /* read: FS_MODE_RD, write: FS_MODE_WR, both: FS_MODE_RD | FS_MODE_WR  */mode: lv_fs_mode_t) -> lv_fs_res_t ---
	/* Create a special object from buffer/ memory address which looks like a file and can be passed as path to lv_fs_open and other functions accepting a path. 

For example //Create a PNG file from t a buffer and use it lv_fs_path_ex_t p;  lv_fs_make_path_from_buffer(&p, 'A', my_buf, my_buf_size, "png");  lv_image_set_src(image1, &p);     */
	lv_fs_make_path_from_buffer :: proc(/* path to a lv_fs_path_ex object  */path: ^lv_fs_path_ex_t, /* the identifier letter of the driver. E.g. LV_FS_MEMFS_LETTER  */letter: u8, /* address of the memory buffer  */buf: rawptr, /* size of the memory buffer in bytes  */size: u32, /* the extension, e.g. "png", if NULL no extension will be added.  */ext: ^u8) ---
	/* Get the buffer address and size from a path object LV_RESULT_OK: buffer and size are set; LV_RESULT_INVALID: an error happened.  */
	lv_fs_get_buffer_from_path :: proc(/* pointer to an initialized lv_fs_path_ex data  */path: ^lv_fs_path_ex_t, /* pointer to a void * variable to store the address  */buffer: ^rawptr, /* pointer to an uint32_t data to store the size  */size: ^u32) -> lv_result_t ---
	/* Close an already opened file LV_FS_RES_OK or any error from lv_fs_res_t enum  */
	lv_fs_close :: proc(/* pointer to a :ref:`lv_fs_file_t` variable  */file_p: ^lv_fs_file_t) -> lv_fs_res_t ---
	/* Read from a file LV_FS_RES_OK or any error from lv_fs_res_t enum  */
	lv_fs_read :: proc(/* pointer to a :ref:`lv_fs_file_t` variable  */file_p: ^lv_fs_file_t, /* pointer to a buffer where the read bytes are stored  */buf: rawptr, /* Bytes To Read  */btr: u32, /* the number of real read bytes (Bytes Read). NULL if unused.  */br: ^u32) -> lv_fs_res_t ---
	/* Write into a file LV_FS_RES_OK or any error from lv_fs_res_t enum  */
	lv_fs_write :: proc(/* pointer to a :ref:`lv_fs_file_t` variable  */file_p: ^lv_fs_file_t, /* pointer to a buffer with the bytes to write  */buf: rawptr, /* Bytes To Write  */btw: u32, /* the number of real written bytes (Bytes Written). NULL if unused.  */bw: ^u32) -> lv_fs_res_t ---
	/* Set the position of the 'cursor' (read write pointer) in a file LV_FS_RES_OK or any error from lv_fs_res_t enum  */
	lv_fs_seek :: proc(/* pointer to a :ref:`lv_fs_file_t` variable  */file_p: ^lv_fs_file_t, /* the new position expressed in bytes index (0: start of file)  */pos: u32, /* tells from where to set position. See lv_fs_whence_t  */whence: lv_fs_whence_t) -> lv_fs_res_t ---
	/* Give the position of the read write pointer LV_FS_RES_OK or any error from 'fs_res_t'  */
	lv_fs_tell :: proc(/* pointer to a :ref:`lv_fs_file_t` variable  */file_p: ^lv_fs_file_t, /* pointer to store the position of the read write pointer  */pos: ^u32) -> lv_fs_res_t ---
	/* Get the size in bytes of an open file. The file read/write position will not be affected. LV_FS_RES_OK or any error from lv_fs_res_t  */
	lv_fs_get_size :: proc(/* pointer to a :ref:`lv_fs_file_t` variable  */file_p: ^lv_fs_file_t, /* pointer to store the file size  */size_res: ^u32) -> lv_fs_res_t ---
	/* Get the size in bytes of a file at the given path. LV_FS_RES_OK or any error from lv_fs_res_t  */
	lv_fs_path_get_size :: proc(/* the path of the file  */path: ^u8, /* pointer to store the file size  */size_res: ^u32) -> lv_fs_res_t ---
	/* Read the contents of a file at the given path into a buffer. LV_FS_RES_OK on success, LV_FS_RES_UNKNOWN if fewer than buf_size bytes could be read from the file, or any error from lv_fs_res_t  */
	lv_fs_load_to_buf :: proc(/* a buffer to read the contents of the file into  */buf: rawptr, /* the size of the buffer and the amount to read from the file  */buf_size: u32, /* the path of the file  */path: ^u8) -> lv_fs_res_t ---
	/* Load a file into a memory buffer. a pointer to the loaded file buffer, or NULL if an error occurred  */
	lv_fs_load_with_alloc :: proc(path: ^u8, /* pointer to store the size of the loaded file  */size: ^u32) -> rawptr ---
	/* Initialize a 'fs_dir_t' variable for directory reading LV_FS_RES_OK or any error from lv_fs_res_t enum  */
	lv_fs_dir_open :: proc(/* pointer to a ' :ref:`lv_fs_dir_t` ' variable  */rddir_p: ^lv_fs_dir_t, /* path to a directory  */path: ^u8) -> lv_fs_res_t ---
	/* Read the next filename form a directory. The name of the directories will begin with '/' LV_FS_RES_OK or any error from lv_fs_res_t enum  */
	lv_fs_dir_read :: proc(/* pointer to an initialized 'fs_dir_t' variable  */rddir_p: ^lv_fs_dir_t, /* pointer to a buffer to store the filename  */fn: ^u8, /* length of the buffer to store the filename  */fn_len: u32) -> lv_fs_res_t ---
	/* Close the directory reading LV_FS_RES_OK or any error from lv_fs_res_t enum  */
	lv_fs_dir_close :: proc(/* pointer to an initialized 'fs_dir_t' variable  */rddir_p: ^lv_fs_dir_t) -> lv_fs_res_t ---
	/* Fill a buffer with the letters of existing drivers the buffer  */
	lv_fs_get_letters :: proc(/* buffer to store the letters ('\0' added after the last letter)  */buf: ^u8) -> ^u8 ---
	/* Return with the extension of the filename pointer to the beginning extension or empty string if no extension  */
	lv_fs_get_ext :: proc(/* string with a filename  */fn: ^u8) -> ^u8 ---
	/* Step up one level the truncated file name  */
	lv_fs_up :: proc(/* pointer to a file name  */path: ^u8) -> ^u8 ---
	/* Get the last element of a path (e.g. U:/folder/file -> file) pointer to the beginning of the last element in the path  */
	lv_fs_get_last :: proc(/* pointer to a file name  */path: ^u8) -> ^u8 ---
	/* Concatenate two path components and automatically add/remove a separator as needed. buf, buf_sz, and the return value are analogous to lv_snprintf the number of characters (not including the null terminator) that would be written to buf, even if buf_sz-1 was smaller  */
	lv_fs_path_join :: proc(/* the buffer to place the result in  */buf: ^u8, /* the size of buf. At most buf_sz - 1 characters will be written to buf, and a null terminator  */buf_sz: uint, /* the first path component  */base: ^u8, /* the second path component  */end: ^u8) -> i32 ---
	/* Get information about an image. Try the created image decoder one by one. Once one is able to get info that info will be used. LV_RESULT_OK: success; LV_RESULT_INVALID: wasn't able to get info about the image  */
	lv_image_decoder_get_info :: proc(/* the image source. Can be 1) File name: E.g. "S:folder/img1.png" (The drivers needs to registered via :ref:`lv_fs_drv_register()` ) 2) Variable: Pointer to an :ref:`lv_img_dsc_t` variable 3) Symbol: E.g. LV_SYMBOL_OK  */src: rawptr, /* the image info will be stored here  */header: ^lv_image_header_t) -> lv_result_t ---
	/* Open an image. Try the created image decoders one by one. Once one is able to open the image that decoder is saved in dsc  LV_RESULT_OK: opened the image. dsc->decoded and dsc->header are set. LV_RESULT_INVALID: none of the registered image decoders were able to open the image.  */
	lv_image_decoder_open :: proc(/* describes a decoding session. Simply a pointer to an lv_image_decoder_dsc_t variable.  */dsc: ^lv_image_decoder_dsc_t, /* the image source. Can be 1) File name: E.g. "S:folder/img1.png" (The drivers needs to registered via :ref:`lv_fs_drv_register()` ) ) 2) Variable: Pointer to an :ref:`lv_img_dsc_t` variable 3) Symbol: E.g. LV_SYMBOL_OK  */src: rawptr, /* args about how the image should be opened.  */args: ^lv_image_decoder_args_t) -> lv_result_t ---
	/* Decode full_area pixels incrementally by calling in a loop. Set decoded_area to LV_COORD_MIN on first call. LV_RESULT_OK: success; LV_RESULT_INVALID: an error occurred or there is nothing left to decode  */
	lv_image_decoder_get_area :: proc(/* image decoder descriptor  */dsc: ^lv_image_decoder_dsc_t, /* input parameter. the full area to decode after enough subsequent calls  */full_area: ^lv_area_t, /* input+output parameter. set the values to LV_COORD_MIN for the first call and to reset decoding. the decoded area is stored here after each call.  */decoded_area: ^lv_area_t) -> lv_result_t ---
	/* Close a decoding session  */
	lv_image_decoder_close :: proc(/* pointer to lv_image_decoder_dsc_t used in lv_image_decoder_open  */dsc: ^lv_image_decoder_dsc_t) ---
	/* Create a new image decoder pointer to the new image decoder  */
	lv_image_decoder_create :: proc() -> ^lv_image_decoder_t ---
	/* Delete an image decoder  */
	lv_image_decoder_delete :: proc(/* pointer to an image decoder  */decoder: ^lv_image_decoder_t) ---
	/* Get the next image decoder in the linked list of image decoders the next image decoder or NULL if no more image decoder exists  */
	lv_image_decoder_get_next :: proc(/* pointer to an image decoder or NULL to get the first one  */decoder: ^lv_image_decoder_t) -> ^lv_image_decoder_t ---
	/* Set a callback to get information about the image  */
	lv_image_decoder_set_info_cb :: proc(/* pointer to an image decoder  */decoder: ^lv_image_decoder_t, /* a function to collect info about an image (fill an :ref:`lv_image_header_t` struct)  */info_cb: lv_image_decoder_info_f_t) ---
	/* Set a callback to open an image  */
	lv_image_decoder_set_open_cb :: proc(/* pointer to an image decoder  */decoder: ^lv_image_decoder_t, /* a function to open an image  */open_cb: lv_image_decoder_open_f_t) ---
	/* Set a callback to a decoded line of an image  */
	lv_image_decoder_set_get_area_cb :: proc(/* pointer to an image decoder  */decoder: ^lv_image_decoder_t, /* a function to read a line of an image  */read_line_cb: lv_image_decoder_get_area_cb_t) ---
	/* Set a callback to close a decoding session. E.g. close files and free other resources.  */
	lv_image_decoder_set_close_cb :: proc(/* pointer to an image decoder  */decoder: ^lv_image_decoder_t, /* a function to close a decoding session  */close_cb: lv_image_decoder_close_f_t) ---
	lv_image_decoder_add_to_cache :: proc(decoder: ^lv_image_decoder_t, search_key: ^lv_image_cache_data_t, decoded: ^lv_draw_buf_t, user_data: rawptr) -> ^lv_cache_entry_t ---
	/* Check the decoded image, make any modification if decoder args requires. A new draw buf will be allocated if provided decoded is not modifiable or stride mismatch etc.  post processed draw buffer, when it differs with decoded , it's newly allocated.  */
	lv_image_decoder_post_process :: proc(/* pointer to a decoder descriptor  */dsc: ^lv_image_decoder_dsc_t, /* pointer to a decoded image to post process to meet dsc->args requirement.  */decoded: ^lv_draw_buf_t) -> ^lv_draw_buf_t ---
	/* Used internally to initialize the drawing module  */
	lv_draw_init :: proc() ---
	/* Deinitialize the drawing module  */
	lv_draw_deinit :: proc() ---
	/* Allocate a new draw unit with the given size and appends it to the list of draw units  */
	lv_draw_create_unit :: proc(/* the size to allocate. E.g. sizeof(my_draw_unit_t) , where the first element of my_draw_unit_t is lv_draw_unit_t .  */size: uint) -> rawptr ---
	/* Add an empty draw task to the draw task list of a layer. the created draw task which needs to be further configured e.g. by added a draw descriptor  */
	lv_draw_add_task :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* the coordinates of the draw task  */coords: ^lv_area_t, type: lv_draw_task_type_t) -> ^lv_draw_task_t ---
	/* Needs to be called when a draw task is created and configured. It will send an event about the new draw task to the widget and assign it to a draw unit.  */
	lv_draw_finalize_task_creation :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to a draw task  */t: ^lv_draw_task_t) ---
	/* Try dispatching draw tasks to draw units  */
	lv_draw_dispatch :: proc() ---
	/* Used internally to try dispatching draw tasks of a specific layer at least one draw task is being rendered (maybe it was taken earlier)  */
	lv_draw_dispatch_layer :: proc(/* pointer to a display on which the dispatching was requested  */disp: ^lv_display_t, /* pointer to a layer  */layer: ^lv_layer_t) -> bool ---
	/* Wait for a new dispatch request. It's blocking if LV_USE_OS == 0 else it yields  */
	lv_draw_dispatch_wait_for_request :: proc() ---
	/* Wait for draw finish in case of asynchronous task execution. If LV_USE_OS == 0 it just return.  */
	lv_draw_wait_for_finish :: proc() ---
	/* When a draw unit finished a draw task it needs to request dispatching to let LVGL assign a new draw task to it  */
	lv_draw_dispatch_request :: proc() ---
	/* Get the total number of draw units.  */
	lv_draw_get_unit_count :: proc() -> u32 ---
	/* If there is only one draw unit check the first draw task if it's available. If there are multiple draw units call lv_draw_get_next_available_task to find a task. an available draw task or NULL if there is not any  */
	lv_draw_get_available_task :: proc(/* the draw layer to search in  */layer: ^lv_layer_t, /* continue searching from this task  */t_prev: ^lv_draw_task_t, /* check the task where preferred_draw_unit_id equals this value or LV_DRAW_UNIT_NONE  */draw_unit_id: u8) -> ^lv_draw_task_t ---
	/* Find and available draw task an available draw task or NULL if there is not any  */
	lv_draw_get_next_available_task :: proc(/* the draw layer to search in  */layer: ^lv_layer_t, /* continue searching from this task  */t_prev: ^lv_draw_task_t, /* check the task where preferred_draw_unit_id equals this value or LV_DRAW_UNIT_NONE  */draw_unit_id: u8) -> ^lv_draw_task_t ---
	/* Tell how many draw task are waiting to be drawn on the area of t_check . It can be used to determine if a GPU shall combine many draw tasks into one or not. If a lot of tasks are waiting for the current ones it makes sense to draw them one-by-one to not block the dependent tasks' rendering number of tasks depending on t_check  */
	lv_draw_get_dependent_count :: proc(/* the task whose dependent tasks shall be counted  */t_check: ^lv_draw_task_t) -> u32 ---
	/* Send an event to the draw units  */
	lv_draw_unit_send_event :: proc(/* the name of the draw unit to send the event to  */name: ^u8, /* the event code  */code: lv_event_code_t, /* the event parameter  */param: rawptr) ---
	/* Initialize a layer  */
	lv_layer_init :: proc(/* pointer to a layer to initialize  */layer: ^lv_layer_t) ---
	/* Reset the layer to a drawable state  */
	lv_layer_reset :: proc(/* pointer to a layer to reset  */layer: ^lv_layer_t) ---
	/* Create (allocate) a new layer on a parent layer the new target_layer or NULL on error  */
	lv_draw_layer_create :: proc(/* the parent layer to which the layer will be merged when it's rendered  */parent_layer: ^lv_layer_t, /* the color format of the layer  */color_format: lv_color_format_t, /* the areas of the layer (absolute coordinates)  */area: ^lv_area_t) -> ^lv_layer_t ---
	/* Initialize a layer which is allocated by the user the new target_layer or NULL on error  */
	lv_draw_layer_init :: proc(/* pointer the layer to initialize (its lifetime needs to be managed by the user)  */layer: ^lv_layer_t, /* the parent layer to which the layer will be merged when it's rendered  */parent_layer: ^lv_layer_t, /* the color format of the layer  */color_format: lv_color_format_t, /* the areas of the layer (absolute coordinates)  */area: ^lv_area_t) ---
	/* Try to allocate a buffer for the layer. pointer to the allocated aligned buffer or NULL on failure  */
	lv_draw_layer_alloc_buf :: proc(/* pointer to a layer  */layer: ^lv_layer_t) -> rawptr ---
	/* Got to a pixel at X and Y coordinate on a layer buf offset to point to the given X and Y coordinate  */
	lv_draw_layer_go_to_xy :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* the target X coordinate  */x: i32, /* the target X coordinate  */y: i32) -> rawptr ---
	/* Get the type of a draw task the draw task type  */
	lv_draw_task_get_type :: proc(/* the draw task to get the type of  */t: ^lv_draw_task_t) -> lv_draw_task_type_t ---
	/* Get the draw descriptor of a draw task a void pointer to the draw descriptor  */
	lv_draw_task_get_draw_dsc :: proc(/* the draw task to get the draw descriptor of  */t: ^lv_draw_task_t) -> rawptr ---
	/* Get the draw area of a draw task  */
	lv_draw_task_get_area :: proc(/* the draw task to get the draw area of  */t: ^lv_draw_task_t, /* the destination where the draw area will be stored  */area: ^lv_area_t) ---
	/* Initialize a rectangle draw descriptor.  */
	lv_draw_rect_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_rect_dsc_t) ---
	/* Initialize a fill draw descriptor.  */
	lv_draw_fill_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_fill_dsc_t) ---
	/* Try to get a fill draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_FILL  */
	lv_draw_task_get_fill_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_fill_dsc_t ---
	/* Fill an area  */
	lv_draw_fill :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized draw descriptor variable  */dsc: ^lv_draw_fill_dsc_t, /* the coordinates of the rectangle  */coords: ^lv_area_t) ---
	/* Initialize a border draw descriptor.  */
	lv_draw_border_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_border_dsc_t) ---
	/* Try to get a border draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_BORDER  */
	lv_draw_task_get_border_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_border_dsc_t ---
	/* Draw a border  */
	lv_draw_border :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized draw descriptor variable  */dsc: ^lv_draw_border_dsc_t, /* the coordinates of the rectangle  */coords: ^lv_area_t) ---
	/* Initialize a box shadow draw descriptor.  */
	lv_draw_box_shadow_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_box_shadow_dsc_t) ---
	/* Try to get a box shadow draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_BOX_SHADOW  */
	lv_draw_task_get_box_shadow_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_box_shadow_dsc_t ---
	/* Draw a box shadow  */
	lv_draw_box_shadow :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized draw descriptor variable  */dsc: ^lv_draw_box_shadow_dsc_t, /* the coordinates of the rectangle  */coords: ^lv_area_t) ---
	/* The rectangle is a wrapper for fill, border, bg. image and box shadow. Internally fill, border, image and box shadow draw tasks will be created.  */
	lv_draw_rect :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized draw descriptor variable  */dsc: ^lv_draw_rect_dsc_t, /* the coordinates of the rectangle  */coords: ^lv_area_t) ---
	lv_draw_letter_dsc_init :: proc(dsc: ^lv_draw_letter_dsc_t) ---
	/* Initialize a label draw descriptor  */
	lv_draw_label_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_label_dsc_t) ---
	/* Try to get a label draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_LABEL  */
	lv_draw_task_get_label_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_label_dsc_t ---
	/* Initialize a glyph draw descriptor. Used internally.  */
	lv_draw_glyph_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_glyph_dsc_t) ---
	/* Create a draw task to render a text  */
	lv_draw_label :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to draw descriptor  */dsc: ^lv_draw_label_dsc_t, /* coordinates of the character  */coords: ^lv_area_t) ---
	/* Create a draw task to render a single character  */
	lv_draw_character :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to draw descriptor  */dsc: ^lv_draw_label_dsc_t, /* position of the label  */point: ^lv_point_t, /* the letter to draw  */unicode_letter: u32) ---
	/* Draw a single letter  */
	lv_draw_letter :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to draw descriptor  */dsc: ^lv_draw_letter_dsc_t, /* position of the label  */point: ^lv_point_t) ---
	/* Should be used during rendering the characters to get the position and other parameters of the characters  */
	lv_draw_label_iterate_characters :: proc(/* pointer to a draw task  */t: ^lv_draw_task_t, /* pointer to draw descriptor  */dsc: ^lv_draw_label_dsc_t, /* coordinates of the label  */coords: ^lv_area_t, /* a callback to call to draw each glyphs one by one  */cb: lv_draw_glyph_cb_t) ---
	/* This function is responsible for rendering a single character from a text string, applying the necessary styling described by the glyph descriptor ( dsc ). It handles the retrieval of the glyph's description, checks its visibility within the clipping area, and invokes the callback ( cb ) to render the glyph at the specified position ( pos ) using the given font ( font ).  */
	lv_draw_unit_draw_letter :: proc(/* Pointer to the drawing task.  */t: ^lv_draw_task_t, /* Pointer to the descriptor containing styling for the glyph to be drawn.  */dsc: ^lv_draw_glyph_dsc_t, /* Pointer to the point coordinates where the letter should be drawn.  */pos: ^lv_point_t, /* Pointer to the font containing the glyph.  */font: ^lv_font_t, /* The Unicode code point of the letter to be drawn.  */letter: u32, /* Callback function to execute the actual rendering of the glyph.  */cb: lv_draw_glyph_cb_t) ---
	/* Initialize an image draw descriptor.  */
	lv_draw_image_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_image_dsc_t) ---
	/* Try to get an image draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_IMAGE  */
	lv_draw_task_get_image_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_image_dsc_t ---
	/* Create an image draw task coords can be small than the real image area (if only a part of the image is rendered) or can be larger (in case of tiled images). .  */
	lv_draw_image :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized draw descriptor  */dsc: ^lv_draw_image_dsc_t, /* the coordinates of the image  */coords: ^lv_area_t) ---
	/* Create a draw task to blend a layer to another layer coords can be small than the total widget area from which the layer is created (if only a part of the widget was rendered to a layer)  */
	lv_draw_layer :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized draw descriptor. src must be set to the layer to blend  */dsc: ^lv_draw_image_dsc_t, /* the coordinates of the layer.  */coords: ^lv_area_t) ---
	/* Get the type of an image source type of the image source LV_IMAGE_SRC_VARIABLE/FILE/SYMBOL/UNKNOWN  */
	lv_image_src_get_type :: proc(/* pointer to an image source: pointer to an 'lv_image_t' variable (image stored internally and compiled into the code) a path to a file (e.g. "S:/folder/image.bin") or a symbol (e.g. LV_SYMBOL_CLOSE)  */src: rawptr) -> lv_image_src_t ---
	/* Initialize a line draw descriptor  */
	lv_draw_line_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_line_dsc_t) ---
	/* Try to get a line draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_LINE  */
	lv_draw_task_get_line_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_line_dsc_t ---
	/* Create a line draw task  */
	lv_draw_line :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized :ref:`lv_draw_line_dsc_t` variable  */dsc: ^lv_draw_line_dsc_t) ---
	/* Initialize an arc draw descriptor.  */
	lv_draw_arc_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_arc_dsc_t) ---
	/* Try to get an arc draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_ARC  */
	lv_draw_task_get_arc_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_arc_dsc_t ---
	/* Create an arc draw task.  */
	lv_draw_arc :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized draw descriptor variable  */dsc: ^lv_draw_arc_dsc_t) ---
	/* Get an area the should be invalidated when the arcs angle changed between start_angle and end_ange  */
	lv_draw_arc_get_area :: proc(/* the x coordinate of the center of the arc  */x: i32, /* the y coordinate of the center of the arc  */y: i32, /* the radius of the arc  */radius: u16, /* the start angle of the arc (0 deg on the bottom, 90 deg on the right)  */start_angle: lv_value_precise_t, /* the end angle of the arc  */end_angle: lv_value_precise_t, /* width of the arc  */w: i32, /* true: the arc is rounded  */rounded: bool, /* store the area to invalidate here  */area: ^lv_area_t) ---
	/* Initialize a triangle draw descriptor  */
	lv_draw_triangle_dsc_init :: proc(/* pointer to a draw descriptor  */draw_dsc: ^lv_draw_triangle_dsc_t) ---
	/* Try to get a triangle draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_TRIANGLE  */
	lv_draw_task_get_triangle_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_triangle_dsc_t ---
	/* Create a triangle draw task  */
	lv_draw_triangle :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized :ref:`lv_draw_triangle_dsc_t` object  */draw_dsc: ^lv_draw_triangle_dsc_t) ---
	/* Initialize a blur draw descriptor  */
	lv_draw_blur_dsc_init :: proc(/* pointer to a draw descriptor  */dsc: ^lv_draw_blur_dsc_t) ---
	/* Try to get a blur draw descriptor from a draw task. the task's draw descriptor or NULL if the task is not of type LV_DRAW_TASK_TYPE_BLUR  */
	lv_draw_task_get_blur_dsc :: proc(/* draw task  */task: ^lv_draw_task_t) -> ^lv_draw_blur_dsc_t ---
	/* Create a blur draw task  */
	lv_draw_blur :: proc(/* pointer to a layer  */layer: ^lv_layer_t, /* pointer to an initialized :ref:`lv_draw_blur_dsc_t` variable  */dsc: ^lv_draw_blur_dsc_t, /* coordinates of the character  */coords: ^lv_area_t) ---
	/* Initialize a rectangle draw descriptor from an object's styles in its current state Only the relevant fields will be set. E.g. if border width == 0 the other border properties won't be evaluated.  */
	lv_obj_init_draw_rect_dsc :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* part of the object, e.g. LV_PART_MAIN , LV_PART_SCROLLBAR , LV_PART_KNOB , etc  */part: lv_part_t, /* the descriptor to initialize. If an ..._opa field is set to LV_OPA_TRANSP the related properties won't be initialized. Should be initialized with lv_draw_rect_dsc_init(draw_dsc) .  */draw_dsc: ^lv_draw_rect_dsc_t) ---
	/* Initialize a label draw descriptor from an object's styles in its current state  */
	lv_obj_init_draw_label_dsc :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* part of the object, e.g. LV_PART_MAIN , LV_PART_SCROLLBAR , LV_PART_KNOB , etc  */part: lv_part_t, /* the descriptor to initialize. If the opa field is set to or the property is equal to LV_OPA_TRANSP the rest won't be initialized. Should be initialized with lv_draw_label_dsc_init(draw_dsc) .  */draw_dsc: ^lv_draw_label_dsc_t) ---
	/* Initialize an image draw descriptor from an object's styles in its current state  */
	lv_obj_init_draw_image_dsc :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* part of the object, e.g. LV_PART_MAIN , LV_PART_SCROLLBAR , LV_PART_KNOB , etc  */part: lv_part_t, /* the descriptor to initialize. Should be initialized with lv_draw_image_dsc_init(draw_dsc) .  */draw_dsc: ^lv_draw_image_dsc_t) ---
	/* Initialize a line draw descriptor from an object's styles in its current state  */
	lv_obj_init_draw_line_dsc :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* part of the object, e.g. LV_PART_MAIN , LV_PART_SCROLLBAR , LV_PART_KNOB , etc  */part: lv_part_t, /* the descriptor to initialize. Should be initialized with lv_draw_line_dsc_init(draw_dsc) .  */draw_dsc: ^lv_draw_line_dsc_t) ---
	/* Initialize an arc draw descriptor from an object's styles in its current state  */
	lv_obj_init_draw_arc_dsc :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* part of the object, e.g. LV_PART_MAIN , LV_PART_SCROLLBAR , LV_PART_KNOB , etc  */part: lv_part_t, /* the descriptor to initialize. Should be initialized with lv_draw_arc_dsc_init(draw_dsc) .  */draw_dsc: ^lv_draw_arc_dsc_t) ---
	/* Initialize a blur draw descriptor from an object's styles in its current state. draw_dsc->radius will only be calculated if it's 0 initially. Radius can be set before calling this function to avoid getting it twice.  */
	lv_obj_init_draw_blur_dsc :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* part of the object, e.g. LV_PART_MAIN , LV_PART_SCROLLBAR , LV_PART_KNOB , etc  */part: lv_part_t, /* the descriptor to initialize. Should be initialized with lv_draw_blur_dsc_init(draw_dsc) .  */draw_dsc: ^lv_draw_blur_dsc_t) ---
	/* Get the required extra size (around the object's part) to draw shadow, outline, value etc. the extra size required around the object  */
	lv_obj_calculate_ext_draw_size :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* part of the object  */part: lv_part_t) -> i32 ---
	/* Send a 'LV_EVENT_REFR_EXT_DRAW_SIZE' Call the ancestor's event handler to the object to refresh the value of the extended draw size. The result will be saved in obj .  */
	lv_obj_refresh_ext_draw_size :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Create an object form a class descriptor pointer to the created object  */
	lv_obj_class_create_obj :: proc(/* pointer to a class  */class_p: ^lv_obj_class_t, /* pointer to an object where the new object should be created  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	lv_obj_class_init_obj :: proc(obj: ^lv_obj_t) ---
	lv_obj_is_editable :: proc(obj: ^lv_obj_t) -> bool ---
	lv_obj_is_group_def :: proc(obj: ^lv_obj_t) -> bool ---
	/* Create new Widget group. pointer to the new Widget group  */
	lv_group_create :: proc() -> ^lv_group_t ---
	/* Delete group object.  */
	lv_group_delete :: proc(/* pointer to a group  */group: ^lv_group_t) ---
	/* Set default group. New Widgets will be added to this group if it's enabled in their class with add_to_def_group = true .  */
	lv_group_set_default :: proc(/* pointer to a group (can be NULL )  */group: ^lv_group_t) ---
	/* Get default group. pointer to the default group  */
	lv_group_get_default :: proc() -> ^lv_group_t ---
	/* Add an Widget to group.  */
	lv_group_add_obj :: proc(/* pointer to a group  */group: ^lv_group_t, /* pointer to a Widget to add  */obj: ^lv_obj_t) ---
	/* Swap 2 Widgets in group. Widgets must be in the same group.  */
	lv_group_swap_obj :: proc(/* pointer to a Widget  */obj1: ^lv_obj_t, /* pointer to another Widget  */obj2: ^lv_obj_t) ---
	/* Remove a Widget from its group.  */
	lv_group_remove_obj :: proc(/* pointer to Widget to remove  */obj: ^lv_obj_t) ---
	/* Remove all Widgets from a group.  */
	lv_group_remove_all_objs :: proc(/* pointer to a group  */group: ^lv_group_t) ---
	/* Focus on a Widget (defocus the current).  */
	lv_group_focus_obj :: proc(/* pointer to Widget to focus on  */obj: ^lv_obj_t) ---
	/* Focus on next Widget in a group (defocus the current).  */
	lv_group_focus_next :: proc(/* pointer to a group  */group: ^lv_group_t) ---
	/* Focus on previous Widget in a group (defocus the current).  */
	lv_group_focus_prev :: proc(/* pointer to a group  */group: ^lv_group_t) ---
	/* Do not allow changing focus from current Widget.  */
	lv_group_focus_freeze :: proc(/* pointer to a group  */group: ^lv_group_t, /* true: freeze, false: release freezing (normal mode)  */en: bool) ---
	/* Send a control character to Widget that has focus in a group. result of Widget with focus in group.  */
	lv_group_send_data :: proc(/* pointer to a group  */group: ^lv_group_t, /* a character (use LV_KEY_.. to navigate)  */c: u32) -> lv_result_t ---
	/* Set a function for a group which will be called when a new Widget has focus.  */
	lv_group_set_focus_cb :: proc(/* pointer to a group  */group: ^lv_group_t, /* the call back function or NULL if unused  */focus_cb: lv_group_focus_cb_t) ---
	/* Set a function for a group which will be called when a focus edge is reached  */
	lv_group_set_edge_cb :: proc(/* pointer to a group  */group: ^lv_group_t, /* the call back function or NULL if unused  */edge_cb: lv_group_edge_cb_t) ---
	/* Set whether the next or previous Widget in a group gets focus when Widget that has focus is deleted.  */
	lv_group_set_refocus_policy :: proc(/* pointer to a group  */group: ^lv_group_t, /* new refocus policy enum  */policy: lv_group_refocus_policy_t) ---
	/* Manually set the current mode (edit or navigate).  */
	lv_group_set_editing :: proc(/* pointer to group  */group: ^lv_group_t, /* true: edit mode; false: navigate mode  */edit: bool) ---
	/* Set whether moving focus to next/previous Widget will allow wrapping from first->last or last->first Widget.  */
	lv_group_set_wrap :: proc(/* pointer to group  */group: ^lv_group_t, /* true: wrapping enabled; false: wrapping disabled  */en: bool) ---
	/* Get Widget that has focus, or NULL if there isn't one. pointer to Widget with focus  */
	lv_group_get_focused :: proc(/* pointer to a group  */group: ^lv_group_t) -> ^lv_obj_t ---
	/* Get focus callback function of a group. the call back function or NULL if not set  */
	lv_group_get_focus_cb :: proc(/* pointer to a group  */group: ^lv_group_t) -> lv_group_focus_cb_t ---
	/* Get edge callback function of a group. the call back function or NULL if not set  */
	lv_group_get_edge_cb :: proc(/* pointer to a group  */group: ^lv_group_t) -> lv_group_edge_cb_t ---
	/* Get current mode (edit or navigate). true: edit mode; false: navigate mode  */
	lv_group_get_editing :: proc(/* pointer to group  */group: ^lv_group_t) -> bool ---
	/* Get whether moving focus to next/previous Widget will allow wrapping from first->last or last->first Widget.  */
	lv_group_get_wrap :: proc(/* pointer to group  */group: ^lv_group_t) -> bool ---
	/* Get number of Widgets in group. number of Widgets in the group  */
	lv_group_get_obj_count :: proc(/* pointer to a group  */group: ^lv_group_t) -> u32 ---
	/* Get nth Widget within group. pointer to Widget  */
	lv_group_get_obj_by_index :: proc(/* pointer to a group  */group: ^lv_group_t, /* index of Widget within the group  */index: u32) -> ^lv_obj_t ---
	/* Get the number of groups. number of groups  */
	lv_group_get_count :: proc() -> u32 ---
	/* Get a group by its index. pointer to the group  */
	lv_group_by_index :: proc(/* index of the group  */index: u32) -> ^lv_group_t ---
	/* Set user data to the group  */
	lv_group_set_user_data :: proc(/* pointer to a group  */group: ^lv_group_t, /* pointer to user data  */user_data: rawptr) ---
	/* Get a pointer to the user data of the group pointer to the user data or NULL if group is NULL  */
	lv_group_get_user_data :: proc(group: ^lv_group_t) -> rawptr ---
	/* Create an indev Pointer to the created indev or NULL when allocation failed  */
	lv_indev_create :: proc() -> ^lv_indev_t ---
	/* Remove the provided input device. Make sure not to use the provided input device afterwards anymore.  */
	lv_indev_delete :: proc(/* pointer to delete  */indev: ^lv_indev_t) ---
	/* Get the next input device. the next input device or NULL if there are no more. Provide the first input device when the parameter is NULL  */
	lv_indev_get_next :: proc(/* pointer to the current input device. NULL to initialize.  */indev: ^lv_indev_t) -> ^lv_indev_t ---
	/* Read data from an input device.  */
	lv_indev_read :: proc(/* pointer to an input device  */indev: ^lv_indev_t) ---
	/* Called periodically to read the input devices  */
	lv_indev_read_timer_cb :: proc(/* pointer to a timer to read  */timer: ^lv_timer_t) ---
	/* Enable or disable one or all input devices (default enabled)  */
	lv_indev_enable :: proc(/* pointer to an input device or NULL to enable/disable all of them  */indev: ^lv_indev_t, /* true to enable, false to disable  */enable: bool) ---
	/* Get the currently processed input device. Can be used in action functions too. pointer to the currently processed input device or NULL if no input device processing right now  */
	lv_indev_active :: proc() -> ^lv_indev_t ---
	/* Set the type of an input device  */
	lv_indev_set_type :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* the type of the input device from lv_indev_type_t ( LV_INDEV_TYPE_... )  */indev_type: lv_indev_type_t) ---
	/* Set a callback function to read input device data to the indev  */
	lv_indev_set_read_cb :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* pointer to callback function to read input device data  */read_cb: lv_indev_read_cb_t) ---
	/* Set user data to the indev  */
	lv_indev_set_user_data :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* pointer to user data  */user_data: rawptr) ---
	/* Set driver data to the indev  */
	lv_indev_set_driver_data :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* pointer to driver data  */driver_data: rawptr) ---
	/* Assign a display to the indev  */
	lv_indev_set_display :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* pointer to an display  */disp: ^lv_display_t ) ---
	/* Set long press time to indev  */
	lv_indev_set_long_press_time :: proc(/* pointer to input device  */indev: ^lv_indev_t, /* time long press time in ms  */long_press_time: u16) ---
	/* Set long press repeat time to indev  */
	lv_indev_set_long_press_repeat_time :: proc(/* pointer to input device  */indev: ^lv_indev_t, /* long press repeat time in ms  */long_press_repeat_time: u16) ---
	/* Set scroll limit to the input device  */
	lv_indev_set_scroll_limit :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* the number of pixels to slide before actually drag the object  */scroll_limit: u8) ---
	/* Set scroll throw slow-down to the indev. Greater value means faster slow-down  */
	lv_indev_set_scroll_throw :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* the slow-down in [%]  */scroll_throw: u8) ---
	/* Get the type of an input device the type of the input device from lv_hal_indev_type_t ( LV_INDEV_TYPE_... )  */
	lv_indev_get_type :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> lv_indev_type_t ---
	/* Get the callback function to read input device data to the indev Pointer to callback function to read input device data or NULL if indev is NULL  */
	lv_indev_get_read_cb :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> lv_indev_read_cb_t ---
	/* Get the indev state Indev state or LV_INDEV_STATE_RELEASED if indev is NULL  */
	lv_indev_get_state :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> lv_indev_state_t ---
	/* Get the indev assigned group Pointer to indev assigned group or NULL if indev is NULL  */
	lv_indev_get_group :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> ^lv_group_t ---
	/* Get a pointer to the assigned display of the indev pointer to the assigned display or NULL if indev is NULL  */
	lv_indev_get_display :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> ^lv_display_t ---
	/* Get a pointer to the user data of the indev pointer to the user data or NULL if indev is NULL  */
	lv_indev_get_user_data :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> rawptr ---
	/* Get a pointer to the driver data of the indev pointer to the driver data or NULL if indev is NULL  */
	lv_indev_get_driver_data :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> rawptr ---
	/* Get whether indev is moved while pressed true: indev is moved while pressed; false: indev is not moved while pressed  */
	lv_indev_get_press_moved :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> bool ---
	/* Reset one or all input devices  */
	lv_indev_reset :: proc(/* pointer to an input device to reset or NULL to reset all of them  */indev: ^lv_indev_t, /* pointer to an object which triggers the reset.  */obj: ^lv_obj_t) ---
	/* Touch and key related events are sent to the input device first and to the widget after that. If this functions called in an indev event, the event won't be sent to the widget.  */
	lv_indev_stop_processing :: proc(/* pointer to an input device  */indev: ^lv_indev_t) ---
	/* Reset the long press state of an input device  */
	lv_indev_reset_long_press :: proc(/* pointer to an input device  */indev: ^lv_indev_t) ---
	/* Set a cursor for a pointer input device (for LV_INPUT_TYPE_POINTER and LV_INPUT_TYPE_BUTTON)  */
	lv_indev_set_cursor :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* pointer to an object to be used as cursor  */cur_obj: ^lv_obj_t) ---
	/* Set a destination group for a keypad input device (for LV_INDEV_TYPE_KEYPAD)  */
	lv_indev_set_group :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* pointer to a group  */group: ^lv_group_t) ---
	/* Set the an array of points for LV_INDEV_TYPE_BUTTON. These points will be assigned to the buttons to press a specific point on the screen  */
	lv_indev_set_button_points :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* array of points  */points: []lv_point_t) ---
	/* Get the last point of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON)  */
	lv_indev_get_point :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* pointer to a point to store the result  */point: ^lv_point_t) ---
	/* Get the current gesture direct current gesture direct  */
	lv_indev_get_gesture_dir :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> lv_dir_t ---
	/* Get the last pressed key of an input device (for LV_INDEV_TYPE_KEYPAD) the last pressed key (0 on error)  */
	lv_indev_get_key :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> u32 ---
	/* Get the counter for consecutive clicks within a short distance and time. The counter is updated before LV_EVENT_SHORT_CLICKED is fired. short click streak counter  */
	lv_indev_get_short_click_streak :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> u8 ---
	/* Check the current scroll direction of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON) LV_DIR_NONE: no scrolling now LV_DIR_HOR/VER  */
	lv_indev_get_scroll_dir :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> lv_dir_t ---
	/* Get the currently scrolled object (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON) pointer to the currently scrolled object or NULL if no scrolling by this indev  */
	lv_indev_get_scroll_obj :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> ^lv_obj_t ---
	/* Get the movement vector of an input device (for LV_INDEV_TYPE_POINTER and LV_INDEV_TYPE_BUTTON)  */
	lv_indev_get_vect :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* pointer to a point to store the types.pointer.vector  */point: ^lv_point_t) ---
	/* Get the cursor object of an input device (for LV_INDEV_TYPE_POINTER only) pointer to the cursor object  */
	lv_indev_get_cursor :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> ^lv_obj_t ---
	/* Do nothing until the next release  */
	lv_indev_wait_release :: proc(/* pointer to an input device  */indev: ^lv_indev_t) ---
	/* Gets a pointer to the currently active object in the currently processed input device. pointer to currently active object or NULL if no active object  */
	lv_indev_get_active_obj :: proc() -> ^lv_obj_t ---
	/* Get a pointer to the indev read timer to modify its parameters with lv_timer_... functions. pointer to the indev read refresher timer. (NULL on error)  */
	lv_indev_get_read_timer :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> ^lv_timer_t ---
	/* Set the input device's event model: event-driven mode or timer mode.  */
	lv_indev_set_mode :: proc(/* pointer to an input device  */indev: ^lv_indev_t, /* the mode of input device  */mode: lv_indev_mode_t) ---
	/* Get the input device's running mode. the running mode for the specified input device.  */
	lv_indev_get_mode :: proc(/* pointer to an input device  */indev: ^lv_indev_t) -> lv_indev_mode_t ---
	/* Search the most top, clickable object by a point pointer to the found object or NULL if there was no suitable object  */
	lv_indev_search_obj :: proc(/* pointer to a start object, typically the screen  */obj: ^lv_obj_t, /* pointer to a point for searching the most top child  */point: ^lv_point_t) -> ^lv_obj_t ---
	/* Add an event handler to the indev  */
	lv_indev_add_event_cb :: proc(/* pointer to an indev  */indev: ^lv_indev_t, /* an event callback  */event_cb: lv_event_cb_t, /* event code to react or LV_EVENT_ALL  */filter: lv_event_code_t, /* optional user_data  */user_data: rawptr) ---
	/* Get the number of event attached to an indev number of events  */
	lv_indev_get_event_count :: proc(/* pointer to an indev  */indev: ^lv_indev_t) -> u32 ---
	/* Get an event descriptor for an event the event descriptor  */
	lv_indev_get_event_dsc :: proc(/* pointer to an indev  */indev: ^lv_indev_t, /* the index of the event  */index: u32) -> ^lv_event_dsc_t ---
	/* Remove an event true: and event was removed; false: no event was removed  */
	lv_indev_remove_event :: proc(/* pointer to an indev  */indev: ^lv_indev_t, /* the index of the event to remove  */index: u32) -> bool ---
	/* Remove an event_cb with user_data the count of the event removed  */
	lv_indev_remove_event_cb_with_user_data :: proc(/* pointer to a indev  */indev: ^lv_indev_t, /* the event_cb of the event to remove  */event_cb: lv_event_cb_t, /* user_data  */user_data: rawptr) -> u32 ---
	/* Send an event to an indev LV_RESULT_OK: indev wasn't deleted in the event.  */
	lv_indev_send_event :: proc(/* pointer to an indev  */indev: ^lv_indev_t, /* an event code. LV_EVENT_...  */code: lv_event_code_t, /* optional param  */param: rawptr) -> lv_result_t ---
	/* Set key remapping callback (LV_INDEV_TYPE_KEYPAD)  */
	lv_indev_set_key_remap_cb :: proc(/* pointer to an indev  */indev: ^lv_indev_t, /* remapping function callback. Use NULL to disable callback.  */remap_cb: lv_indev_key_remap_cb_t) ---
	/* Send an event to the object LV_RESULT_OK: obj was not deleted in the event; LV_RESULT_INVALID: obj was deleted in the event_code  */
	lv_obj_send_event :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the type of the event from lv_event_t  */event_code: lv_event_code_t, /* arbitrary data depending on the widget type and the event. (Usually NULL )  */param: rawptr) -> lv_result_t ---
	/* Used by the widgets internally to call the ancestor widget types's event handler LV_RESULT_OK: the target object was not deleted in the event; LV_RESULT_INVALID: it was deleted in the event_code  */
	lv_obj_event_base :: proc(/* pointer to the class of the widget (NOT the ancestor class)  */class_p: ^lv_obj_class_t, /* pointer to the event descriptor  */e: ^lv_event_t) -> lv_result_t ---
	/* Get the current target of the event. It's the object which event handler being called. If the event is not bubbled it's the same as "original" target. the target of the event_code  */
	lv_event_get_current_target_obj :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) -> ^lv_obj_t ---
	/* Get the object originally targeted by the event. It's the same even if the event is bubbled. pointer to the original target of the event_code  */
	lv_event_get_target_obj :: proc(/* pointer to the event descriptor  */e: ^lv_event_t) -> ^lv_obj_t ---
	/* Add an event handler function for an object. Used by the user to react on event which happens with the object. An object can have multiple event handler. They will be called in the same order as they were added. handler to the event. It can be used in lv_obj_remove_event_dsc .  */
	lv_obj_add_event_cb :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the new event function  */event_cb: lv_event_cb_t, /* an event code (e.g. LV_EVENT_CLICKED ) on which the event should be called. LV_EVENT_ALL can be used to receive all the events.  */filter: lv_event_code_t, /* custom data will be available in event_cb  */user_data: rawptr) -> ^lv_event_dsc_t ---
	lv_obj_get_event_count :: proc(obj: ^lv_obj_t) -> u32 ---
	lv_obj_get_event_dsc :: proc(obj: ^lv_obj_t, index: u32) -> ^lv_event_dsc_t ---
	lv_obj_remove_event :: proc(obj: ^lv_obj_t, index: u32) -> bool ---
	lv_obj_remove_event_dsc :: proc(obj: ^lv_obj_t, dsc: ^lv_event_dsc_t) -> bool ---
	/* Remove an event_cb from an object the count of the event removed  */
	lv_obj_remove_event_cb :: proc(/* pointer to a obj  */obj: ^lv_obj_t, /* the event_cb of the event to remove  */event_cb: lv_event_cb_t) -> u32 ---
	/* Remove an event_cb with user_data the count of the event removed  */
	lv_obj_remove_event_cb_with_user_data :: proc(/* pointer to a obj  */obj: ^lv_obj_t, /* the event_cb of the event to remove  */event_cb: lv_event_cb_t, /* user_data  */user_data: rawptr) -> u32 ---
	/* Get the input device passed as parameter to indev related events. the indev that triggered the event or NULL if called on a not indev related event  */
	lv_event_get_indev :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_indev_t ---
	/* Get the draw context which should be the first parameter of the draw functions. Namely: LV_EVENT_DRAW_MAIN/POST , LV_EVENT_DRAW_MAIN/POST_BEGIN , LV_EVENT_DRAW_MAIN/POST_END  pointer to a draw context or NULL if called on an unrelated event  */
	lv_event_get_layer :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_layer_t ---
	/* Get the old area of the object before its size was changed. Can be used in LV_EVENT_SIZE_CHANGED  the old absolute area of the object or NULL if called on an unrelated event  */
	lv_event_get_old_size :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_area_t ---
	/* Get the key passed as parameter to an event. Can be used in LV_EVENT_KEY  the triggering key or NULL if called on an unrelated event  */
	lv_event_get_key :: proc(/* pointer to an event  */e: ^lv_event_t) -> u32 ---
	/* Get the signed rotary encoder diff. passed as parameter to an event. Can be used in LV_EVENT_ROTARY  the triggering key or NULL if called on an unrelated event  */
	lv_event_get_rotary_diff :: proc(/* pointer to an event  */e: ^lv_event_t) -> i32 ---
	/* Get the animation descriptor of a scrolling. Can be used in LV_EVENT_SCROLL_BEGIN  the animation that will scroll the object. (can be modified as required)  */
	lv_event_get_scroll_anim :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_anim_t ---
	/* Set the new extra draw size. Can be used in LV_EVENT_REFR_EXT_DRAW_SIZE  */
	lv_event_set_ext_draw_size :: proc(/* pointer to an event  */e: ^lv_event_t, /* The new extra draw size  */size: i32) ---
	/* Get a pointer to an :ref:`lv_point_t` variable in which the self size should be saved (width in point->x and height point->y ). Can be used in LV_EVENT_GET_SELF_SIZE  pointer to :ref:`lv_point_t` or NULL if called on an unrelated event  */
	lv_event_get_self_size_info :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_point_t ---
	/* Get a pointer to an lv_hit_test_info_t variable in which the hit test result should be saved. Can be used in LV_EVENT_HIT_TEST  pointer to lv_hit_test_info_t or NULL if called on an unrelated event  */
	lv_event_get_hit_test_info :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_hit_test_info_t ---
	/* Get a pointer to an area which should be examined whether the object fully covers it or not. Can be used in LV_EVENT_HIT_TEST  an area with absolute coordinates to check  */
	lv_event_get_cover_area :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_area_t ---
	/* Set the result of cover checking. Can be used in LV_EVENT_COVER_CHECK  */
	lv_event_set_cover_res :: proc(/* pointer to an event  */e: ^lv_event_t, /* an element of lv_cover_check_info_t  */res: lv_cover_res_t) ---
	/* Get the draw task which was just added. Can be used in LV_EVENT_DRAW_TASK_ADDED event  the added draw task  */
	lv_event_get_draw_task :: proc(/* pointer to an event  */e: ^lv_event_t) -> ^lv_draw_task_t ---
	/* Get the previous state before the state change. Can be used in LV_EVENT_STATE_CHANGED event the previous state  */
	lv_event_get_prev_state :: proc(/* pointer to an event  */e: ^lv_event_t) -> lv_state_t ---
	/* Create a base object (a rectangle) pointer to the new object  */
	lv_obj_create :: proc(/* pointer to a parent object. If NULL then a screen will be created.  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set one or more flags  */
	lv_obj_add_flag :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* OR-ed values from lv_obj_flag_t to set.  */f: lv_obj_flag_t) ---
	/* Remove one or more flags  */
	lv_obj_remove_flag :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* OR-ed values from lv_obj_flag_t to clear.  */f: lv_obj_flag_t) ---
	/* Set add or remove one or more flags.  */
	lv_obj_set_flag :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* OR-ed values from lv_obj_flag_t to update.  */f: lv_obj_flag_t, /* true: add the flags; false: remove the flags  */v: bool) ---
	/* Add one or more states to the object. The other state bits will remain unchanged. If specified in the styles, transition animation will be started from the previous state to the current.  */
	lv_obj_add_state :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the states to add. E.g LV_STATE_PRESSED | LV_STATE_FOCUSED  */state: lv_state_t) ---
	/* Remove one or more states to the object. The other state bits will remain unchanged. If specified in the styles, transition animation will be started from the previous state to the current.  */
	lv_obj_remove_state :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the states to add. E.g LV_STATE_PRESSED | LV_STATE_FOCUSED  */state: lv_state_t) ---
	/* Add or remove one or more states to the object. The other state bits will remain unchanged.  */
	lv_obj_set_state :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the states to add. E.g LV_STATE_PRESSED | LV_STATE_FOCUSED  */state: lv_state_t, /* true: add the states; false: remove the states  */v: bool) ---
	/* Set the user_data field of the object  */
	lv_obj_set_user_data :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* pointer to the new user_data.  */user_data: rawptr) ---
	/* Check if a given flag or all the given flags are set on an object. true: all flags are set; false: not all flags are set  */
	lv_obj_has_flag :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the flag(s) to check (OR-ed values can be used)  */f: lv_obj_flag_t) -> bool ---
	/* Check if a given flag or any of the flags are set on an object. true: at least one flag is set; false: none of the flags are set  */
	lv_obj_has_flag_any :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the flag(s) to check (OR-ed values can be used)  */f: lv_obj_flag_t) -> bool ---
	/* Get the state of an object the state (OR-ed values from lv_state_t )  */
	lv_obj_get_state :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> lv_state_t ---
	/* Check if the object is in a given state or not. true: obj is in state ; false: obj is not in state  */
	lv_obj_has_state :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* a state or combination of states to check  */state: lv_state_t) -> bool ---
	/* Get the group of the object the pointer to group of the object  */
	lv_obj_get_group :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_group_t ---
	/* Get the user_data field of the object the pointer to the user_data of the object  */
	lv_obj_get_user_data :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> rawptr ---
	/* Allocate special data for an object if not allocated yet.  */
	lv_obj_allocate_spec_attr :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Check the type of obj. true: class_p is the obj class.  */
	lv_obj_check_type :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* a class to check (e.g. lv_slider_class )  */class_p: ^lv_obj_class_t) -> bool ---
	/* Check if any object has a given class (type). It checks the ancestor classes too. true: obj has the given class  */
	lv_obj_has_class :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* a class to check (e.g. lv_slider_class )  */class_p: ^lv_obj_class_t) -> bool ---
	/* Get the class (type) of the object the class (type) of the object  */
	lv_obj_get_class :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_obj_class_t ---
	/* Check if any object is still "alive". true: valid  */
	lv_obj_is_valid :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> bool ---
	/* Utility to set an object reference to NULL when it gets deleted. The reference should be in a location that will not become invalid during the object's lifetime, i.e. static or allocated.  */
	lv_obj_null_on_delete :: proc(/* a pointer to a pointer to an object  */obj_ptr: ^^lv_obj_t) ---
	/* Add an event handler to a widget that will load a screen on a trigger.  */
	lv_obj_add_screen_load_event :: proc(/* pointer to widget which should load the screen  */obj: ^lv_obj_t, /* an event code, e.g. LV_EVENT_CLICKED  */trigger: lv_event_code_t, /* the screen to load (must be a valid widget)  */screen: ^lv_obj_t, /* element of lv_screen_load_anim_t the screen load animation  */anim_type: lv_screen_load_anim_t, /* duration of the animation in milliseconds  */duration: u32, /* delay before the screen load in milliseconds  */delay: u32) ---
	/* Add an event handler to a widget that will create a screen on a trigger. The created screen will be deleted when it's unloaded  */
	lv_obj_add_screen_create_event :: proc(/* pointer to widget which should load the screen  */obj: ^lv_obj_t, /* an event code, e.g. LV_EVENT_CLICKED  */trigger: lv_event_code_t, /* a callback to create the screen, e.g. lv_obj_t * myscreen_create(void)  */screen_create_cb: lv_screen_create_cb_t, /* element of lv_screen_load_anim_t the screen load animation  */anim_type: lv_screen_load_anim_t, /* duration of the animation in milliseconds  */duration: u32, /* delay before the screen load in milliseconds  */delay: u32) ---
	/* Play a timeline animation on a trigger  */
	lv_obj_add_play_timeline_event :: proc(/* pointer to widget which should trigger playing the animation  */obj: ^lv_obj_t, /* an event code, e.g. LV_EVENT_CLICKED  */trigger: lv_event_code_t, /* pointer to an animation timeline  */at: ^lv_anim_timeline_t, /* wait time before starting the animation  */delay: u32, /* true: play in reverse  */reverse: bool) ---
	/* Set an id for an object.  */
	lv_obj_set_id :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the id of the object  */id: rawptr) ---
	/* Get the id of an object. the id of the object  */
	lv_obj_get_id :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> rawptr ---
	/* DEPRECATED IDs are used only to print the widget trees. To find a widget use lv_obj_find_by_name 

Get the child object by its id. It will check children and grandchildren recursively. Function lv_obj_id_compare is used to matched obj id with given id.  

pointer to the child object or NULL if not found   */
	lv_obj_find_by_id :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* the id of the child object  */id: rawptr) -> ^lv_obj_t ---
	/* Assign id to object if not previously assigned. This function gets called automatically when LV_OBJ_ID_AUTO_ASSIGN is enabled. 

Set LV_USE_OBJ_ID_BUILTIN to use the builtin method to generate object ID. Otherwise, these functions including lv_obj_[set|assign|free|stringify]_id and lv_obj_id_compare should be implemented externally.   */
	lv_obj_assign_id :: proc(/* the class this obj belongs to. Note obj->class_p is the class currently being constructed.  */class_p: ^lv_obj_class_t, /* pointer to an object  */obj: ^lv_obj_t) ---
	/* Free resources allocated by lv_obj_assign_id or lv_obj_set_id . This function is also called automatically when object is deleted.  */
	lv_obj_free_id :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Compare two obj id, return 0 if they are equal. 

Set LV_USE_OBJ_ID_BUILTIN to use the builtin method for compare. Otherwise, it must be implemented externally.  

0 if they are equal, non-zero otherwise.   */
	lv_obj_id_compare :: proc(/* the first id  */id1: rawptr, /* the second id  */id2: rawptr) -> i32 ---
	/* Format an object's id into a string.  */
	lv_obj_stringify_id :: proc(/* pointer to an object  */obj: ^lv_obj_t, /* buffer to write the string into  */buf: ^u8, /* length of the buffer  */len: u32) -> ^u8 ---
	/* Free resources used by builtin ID generator.  */
	lv_objid_builtin_destroy :: proc() ---
	/* Redraw the invalidated areas now. Normally the redrawing is periodically executed in lv_timer_handler but a long blocking process can prevent the call of lv_timer_handler . In this case if the GUI is updated in the process (e.g. progress bar) this function can be called when the screen should be updated.  */
	lv_refr_now :: proc(/* pointer to display to refresh. NULL to refresh all displays.  */disp: ^lv_display_t) ---
	/* Redrawn on object and all its children using the passed draw context  */
	lv_obj_redraw :: proc(/* pointer to a layer where to draw.  */layer: ^lv_layer_t, /* the start object from the redraw should start  */obj: ^lv_obj_t) ---
	/* Called periodically to handle the refreshing  */
	lv_display_refr_timer :: proc(/* pointer to the timer itself, or NULL  */timer: ^lv_timer_t) ---
	/* Initialize an integer-type Subject.  */
	lv_subject_init_int :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* initial value  */value: i32) ---
	/* Set value of an integer Subject and notify Observers.  */
	lv_subject_set_int :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* new value  */value: i32) ---
	/* Get current value of an integer Subject. current value  */
	lv_subject_get_int :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> i32 ---
	/* Get previous value of an integer Subject. current value  */
	lv_subject_get_previous_int :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> i32 ---
	/* Set a minimum value for an integer subject  */
	lv_subject_set_min_value_int :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* the minimum value  */min_value: i32) ---
	/* Set a maximum value for an integer subject  */
	lv_subject_set_max_value_int :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* the maximum value  */max_value: i32) ---
	/* Initialize an float-type Subject.  */
	lv_subject_init_float :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* initial value  */value: f32) ---
	/* Set value of an float Subject and notify Observers.  */
	lv_subject_set_float :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* new value  */value: f32) ---
	/* Get current value of an float Subject. current value  */
	lv_subject_get_float :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> f32 ---
	/* Get previous value of an float Subject. current value  */
	lv_subject_get_previous_float :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> f32 ---
	/* Set a minimum value for a float subject  */
	lv_subject_set_min_value_float :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* the minimum value  */min_value: f32) ---
	/* Set a maximum value for a float subject  */
	lv_subject_set_max_value_float :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* the maximum value  */max_value: f32) ---
	/* Initialize a string-type Subject. A string Subject stores its own copy of the string, not just the pointer.  */
	lv_subject_init_string :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* pointer to buffer to store string  */buf: ^u8, /* pointer to buffer to store previous string; can be NULL if not used  */prev_buf: ^u8, /* size of buffer(s)  */size: uint, /* initial value of string, e.g. "hello"  */value: ^u8) ---
	/* Copy a string to a Subject and notify Observers if it changed.  */
	lv_subject_copy_string :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* new string  */buf: ^u8) ---
	/* Format a new string, updating Subject, and notify Observers if it changed.  */
	lv_subject_snprintf :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* format string  */format: ^u8, #c_vararg args: ..any) ---
	/* Get current value of a string Subject. pointer to buffer containing current value  */
	lv_subject_get_string :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> ^u8 ---
	/* Get previous value of a string Subject. pointer to buffer containing previous value  NULL will be returned if NULL was passed in :ref:`lv_subject_init_string()` as prev_buf .  */
	lv_subject_get_previous_string :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> ^u8 ---
	/* Initialize a pointer-type Subject.  */
	lv_subject_init_pointer :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* initial value  */value: rawptr) ---
	/* Set value of a pointer Subject and notify Observers (regardless of whether it changed).  */
	lv_subject_set_pointer :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* new value  */ptr: rawptr) ---
	/* Get current value of a pointer Subject. current value  */
	lv_subject_get_pointer :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> rawptr ---
	/* Get previous value of a pointer Subject. previous value  */
	lv_subject_get_previous_pointer :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> rawptr ---
	/* Initialize a color-type Subject.  */
	lv_subject_init_color :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* initial value  */color: lv_color_t) ---
	/* Set value of a color Subject and notify Observers if it changed.  */
	lv_subject_set_color :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* new value  */color: lv_color_t) ---
	/* Get current value of a color Subject. current value  */
	lv_subject_get_color :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> lv_color_t ---
	/* Get previous value of a color Subject. previous value  */
	lv_subject_get_previous_color :: proc(/* pointer to Subject  */subject: ^lv_subject_t) -> lv_color_t ---
	/* Initialize a Group-type Subject.  */
	lv_subject_init_group :: proc(/* pointer to Group-type Subject  */group_subject: ^lv_subject_t, /* list of other Subject addresses; when any of these have values updated, Observers of group_subject will be notified.  */list: []^lv_subject_t, /* number of elements in list[]  */list_len: u32) ---
	/* Remove all Observers from a Subject and free allocated memory, and delete any associated Widget-Binding events. This leaves subject "disconnected" from all Observers and all associated Widget events established through Widget Binding. This can safely be called regardless of whether any Observers added with :ref:`lv_subject_add_observer_obj()` or bound to a Widget Property with one of the ..._bind_...() functions.  */
	lv_subject_deinit :: proc(/* pointer to Subject  */subject: ^lv_subject_t) ---
	/* Get an element from Subject Group's list. pointer to indexed Subject from list, or NULL if index is out of bounds  */
	lv_subject_get_group_element :: proc(/* pointer to Group-type Subject  */subject: ^lv_subject_t, /* index of element to get  */index: i32) -> ^lv_subject_t ---
	/* Add Observer to Subject. When Subject's value changes observer_cb will be called. pointer to newly-created Observer  */
	lv_subject_add_observer :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* notification callback  */observer_cb: lv_observer_cb_t, /* optional user data  */user_data: rawptr) -> ^lv_observer_t ---
	/* Add Observer to Subject for a Widget. When the Widget is deleted, Observer will be unsubscribed from Subject automatically. pointer to newly-created Observer  Do not call :ref:`lv_observer_remove()` on Observers created this way. Only clean up such Observers by either: deleting the Widget, or calling :ref:`lv_subject_deinit()` to gracefully de-couple and remove all Observers.  */
	lv_subject_add_observer_obj :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* notification callback  */observer_cb: lv_observer_cb_t, /* pointer to Widget  */obj: ^lv_obj_t, /* optional user data  */user_data: rawptr) -> ^lv_observer_t ---
	/* Add an Observer to a Subject and also save a target pointer. pointer to newly-created Observer  */
	lv_subject_add_observer_with_target :: proc(/* pointer to Subject  */subject: ^lv_subject_t, /* notification callback  */observer_cb: lv_observer_cb_t, /* any pointer (NULL is okay)  */target: rawptr, /* optional user data  */user_data: rawptr) -> ^lv_observer_t ---
	/* Remove Observer from its Subject.  */
	lv_observer_remove :: proc(/* pointer to Observer  */observer: ^lv_observer_t) ---
	/* Remove Observers associated with Widget obj from specified subject or all Subjects. This function can be used e.g. when a Widget's Subject(s) needs to be replaced by other Subject(s)  */
	lv_obj_remove_from_subject :: proc(/* pointer to Widget whose Observers should be removed  */obj: ^lv_obj_t, /* Subject to remove Widget from, or NULL to remove from all Subjects  */subject: ^lv_subject_t) ---
	/* Get target of an Observer. pointer to saved target  */
	lv_observer_get_target :: proc(/* pointer to Observer  */observer: ^lv_observer_t) -> rawptr ---
	/* Get target Widget of Observer. This is the same as :ref:`lv_observer_get_target()` , except it returns target as an lv_obj_t * . pointer to saved Widget target  */
	lv_observer_get_target_obj :: proc(/* pointer to Observer  */observer: ^lv_observer_t) -> ^lv_obj_t ---
	/* Get Observer's user data. void pointer to saved user data  */
	lv_observer_get_user_data :: proc(/* pointer to Observer  */observer: ^lv_observer_t) -> rawptr ---
	/* Notify all Observers of Subject.  */
	lv_subject_notify :: proc(/* pointer to Subject  */subject: ^lv_subject_t) ---
	/* Add an event handler to increment (or decrement) the value of a subject on a trigger.  */
	lv_obj_add_subject_increment_event :: proc(/* pointer to a widget  */obj: ^lv_obj_t, /* pointer to a subject to change  */subject: ^lv_subject_t, /* the trigger on which the subject should be changed  */trigger: lv_event_code_t, /* value to add on trigger if the minimum value is reached, the maximum value will be set on rollover.  */step: i32) -> ^lv_subject_increment_dsc_t ---
	/* Set the minimum subject value to set by the event  */
	lv_obj_set_subject_increment_event_min_value :: proc(/* pointer to the Widget to which the event is attached  */obj: ^lv_obj_t, /* pointer to the descriptor returned by :ref:`lv_obj_add_subject_increment_event()`  */dsc: ^lv_subject_increment_dsc_t, /* the minimum value to set  */min_value: i32) ---
	/* Set the maximum subject value to set by the event  */
	lv_obj_set_subject_increment_event_max_value :: proc(/* pointer to the Widget to which the event is attached  */obj: ^lv_obj_t, /* pointer to the descriptor returned by :ref:`lv_obj_add_subject_increment_event()`  */dsc: ^lv_subject_increment_dsc_t, /* the maximum value to set  */max_value: i32) ---
	/* Set what to do when the min/max value is crossed. the subject also can have min/max values and always the smaller range will be considered  */
	lv_obj_set_subject_increment_event_rollover :: proc(/* pointer to the Widget to which the event is attached  */obj: ^lv_obj_t, /* pointer to the descriptor returned by :ref:`lv_obj_add_subject_increment_event()`  */dsc: ^lv_subject_increment_dsc_t, /* false: stop at the min/max value; true: jump to the other end  */rollover: bool) ---
	/* Toggle the value of an integer subject on an event. If it was != 0 it will be 0. If it was 0, it will be 1.  */
	lv_obj_add_subject_toggle_event :: proc(/* pointer to a widget  */obj: ^lv_obj_t, /* pointer to a subject to toggle  */subject: ^lv_subject_t, /* the trigger on which the subject should be changed  */trigger: lv_event_code_t) ---
	/* Set the value of an integer subject.  */
	lv_obj_add_subject_set_int_event :: proc(/* pointer to a widget  */obj: ^lv_obj_t, /* pointer to a subject to change  */subject: ^lv_subject_t, /* the trigger on which the subject should be changed  */trigger: lv_event_code_t, /* the value to set  */value: i32) ---
	/* Set the value of a float subject.  */
	lv_obj_add_subject_set_float_event :: proc(/* pointer to a widget  */obj: ^lv_obj_t, /* pointer to a subject to change  */subject: ^lv_subject_t, /* the trigger on which the subject should be changed  */trigger: lv_event_code_t, /* the value to set  */value: f32) ---
	/* Set the value of a string subject.  */
	lv_obj_add_subject_set_string_event :: proc(/* pointer to a widget  */obj: ^lv_obj_t, /* pointer to a subject to change  */subject: ^lv_subject_t, /* the trigger on which the subject should be changed  */trigger: lv_event_code_t, /* the value to set  */value: ^u8) ---
	/* Set Widget's flag(s) if an integer Subject's value is equal to a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_flag_if_eq :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* flag(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_OBJ_FLAG_HIDDEN )  */flag: lv_obj_flag_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's flag(s) if an integer Subject's value is not equal to a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_flag_if_not_eq :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* flag(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_OBJ_FLAG_HIDDEN )  */flag: lv_obj_flag_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's flag(s) if an integer Subject's value is greater than a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_flag_if_gt :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* flag(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_OBJ_FLAG_HIDDEN )  */flag: lv_obj_flag_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's flag(s) if an integer Subject's value is greater than or equal to a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_flag_if_ge :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* flag(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_OBJ_FLAG_HIDDEN )  */flag: lv_obj_flag_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's flag(s) if an integer Subject's value is less than a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_flag_if_lt :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* flag(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_OBJ_FLAG_HIDDEN )  */flag: lv_obj_flag_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's flag(s) if an integer Subject's value is less than or equal to a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_flag_if_le :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* flag(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_OBJ_FLAG_HIDDEN )  */flag: lv_obj_flag_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's state(s) if an integer Subject's value is equal to a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_state_if_eq :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* state(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_STATE_CHECKED )  */state: lv_state_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set a Widget's state(s) if an integer Subject's value is not equal to a reference value, clear flag otherwise pointer to newly-created Observer  */
	lv_obj_bind_state_if_not_eq :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* state(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_STATE_CHECKED )  */state: lv_state_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's state(s) if an integer Subject's value is greater than a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_state_if_gt :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* state(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_STATE_CHECKED )  */state: lv_state_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's state(s) if an integer Subject's value is greater than or equal to a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_state_if_ge :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* state(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_STATE_CHECKED )  */state: lv_state_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's state(s) if an integer Subject's value is less than a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_state_if_lt :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* state(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_STATE_CHECKED )  */state: lv_state_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set Widget's state(s) if an integer Subject's value is less than or equal to a reference value, clear flag otherwise. pointer to newly-created Observer  */
	lv_obj_bind_state_if_le :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* state(s) (can be bit-wise OR-ed) to set or clear (e.g. LV_STATE_CHECKED )  */state: lv_state_t, /* reference value to compare Subject's value with  */ref_value: i32) -> ^lv_observer_t ---
	/* Set an integer Subject to 1 when a Widget is checked and set it 0 when unchecked, and clear Widget's checked state when Subject's value changes to 0 and set it when non-zero. pointer to newly-created Observer  Ensure Widget's LV_OBJ_FLAG_CHECKABLE flag is set.  */
	lv_obj_bind_checked :: proc(/* pointer to Widget  */obj: ^lv_obj_t, /* pointer to a Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Add grid navigation feature to an object. It expects the children to be arranged into a grid-like layout. Although it's not required to have pixel perfect alignment. This feature makes possible to use keys to navigate among the children and focus them. The keys other than arrows and press/release related events are forwarded to the focused child.  */
	lv_gridnav_add :: proc(/* pointer to an object on which navigation should be applied.  */obj: ^lv_obj_t, /* control flags from lv_gridnav_ctrl_t .  */ctrl: lv_gridnav_ctrl_t) ---
	/* Remove the grid navigation support from an object  */
	lv_gridnav_remove :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Manually focus an object on gridnav container  */
	lv_gridnav_set_focused :: proc(/* pointer to a gridnav container  */cont: ^lv_obj_t, /* pointer to an object to focus  */to_focus: ^lv_obj_t, /* LV_ANIM_ON/OFF  */anim_en: lv_anim_enable_t) ---
	/* Loads a lv_font_t object from a binary font file pointer to font where to load  */
	lv_binfont_create :: proc(/* path to font file  */path: ^u8) -> ^lv_font_t ---
	/* Frees the memory allocated by the :ref:`lv_binfont_create()` function  */
	lv_binfont_destroy :: proc(/* lv_font_t object created by the lv_binfont_create function  */font: ^lv_font_t) ---
	/* Used as get_glyph_bitmap callback in lvgl's native font format if the font is uncompressed. pointer to an A8 bitmap (not necessarily bitmap_out) or NULL if unicode_letter not found  */
	lv_font_get_bitmap_fmt_txt :: proc(/* the glyph descriptor including which font to use, which supply the glyph_index and format.  */g_dsc: ^lv_font_glyph_dsc_t, /* a draw buffer that can be used to store the bitmap of the glyph, it's OK not to use it.  */draw_buf: ^lv_draw_buf_t) -> rawptr ---
	/* Used as get_glyph_dsc callback in lvgl's native font format if the font is uncompressed. true: descriptor is successfully loaded into dsc_out . false: the letter was not found, no data is loaded to dsc_out  */
	lv_font_get_glyph_dsc_fmt_txt :: proc(/* pointer to font  */font: ^lv_font_t, /* store the result descriptor here  */dsc_out: ^lv_font_glyph_dsc_t, /* a UNICODE letter code  */unicode_letter: u32, /* the unicode letter succeeding the letter under test  */unicode_letter_next: u32) -> bool ---
	/* Creates a image font with info parameter specified. pointer to the new imgfont or NULL if create error.  */
	lv_imgfont_create :: proc(/* font size  */height: u16, /* a function to get the image path name of character.  */path_cb: lv_imgfont_get_path_cb_t, /* pointer to user data  */user_data: rawptr) -> ^lv_font_t ---
	/* Destroy a image font that has been created.  */
	lv_imgfont_destroy :: proc(/* pointer to image font handle.  */font: ^lv_font_t) ---
	/* Create an image object pointer to the created image  */
	lv_image_create :: proc(/* pointer to an object, it will be the parent of the new image  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the image data to display on the object  */
	lv_image_set_src :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* 1) pointer to an :ref:`lv_img_dsc_t` descriptor (converted by LVGL's image converter) (e.g. &my_img) or 2) path to an image file (e.g. "S:/dir/img.bin")or 3) a SYMBOL (e.g. LV_SYMBOL_OK)  */src: rawptr) ---
	/* Set an offset for the source of an image so the image will be displayed from the new origin.  */
	lv_image_set_offset_x :: proc(/* pointer to an image  */obj: ^lv_obj_t, /* the new offset along x axis.  */x: i32) ---
	/* Set an offset for the source of an image. so the image will be displayed from the new origin.  */
	lv_image_set_offset_y :: proc(/* pointer to an image  */obj: ^lv_obj_t, /* the new offset along y axis.  */y: i32) ---
	/* Set the rotation angle of the image. The image will be rotated around the set pivot set by :ref:`lv_image_set_pivot()` Note that indexed and alpha only images can't be transformed. if image_align is LV_IMAGE_ALIGN_STRETCH or LV_IMAGE_ALIGN_FIT rotation will be set to 0 automatically.  */
	lv_image_set_rotation :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* rotation in degree with 0.1 degree resolution (0..3600: clock wise)  */angle: i32) ---
	/* Set the rotation center of the image. The image will be rotated around this point. x, y can be set with value of LV_PCT, lv_image_get_pivot will return the true pixel coordinate of pivot in this case.  */
	lv_image_set_pivot :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* rotation center x of the image  */x: i32, /* rotation center y of the image  */y: i32) ---
	/* Set the rotation horizontal center of the image.  */
	lv_image_set_pivot_x :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* rotation center x of the image, or :ref:`lv_pct()`  */x: i32) ---
	/* Set the rotation vertical center of the image.  */
	lv_image_set_pivot_y :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* rotation center y of the image, or :ref:`lv_pct()`  */y: i32) ---
	/* Set the zoom factor of the image. Note that indexed and alpha only images can't be transformed.  */
	lv_image_set_scale :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* the zoom factor. Example values: 256 or LV_SCALE_NONE: no zoom <256: scale down >256: scale up 128: half size 512: double size  */zoom: u32) ---
	/* Set the horizontal zoom factor of the image. Note that indexed and alpha only images can't be transformed.  */
	lv_image_set_scale_x :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* the zoom factor. Example values: 256 or LV_SCALE_NONE: no zoom <256: scale down >256: scale up 128: half size 512: double size  */zoom: u32) ---
	/* Set the vertical zoom factor of the image. Note that indexed and alpha only images can't be transformed.  */
	lv_image_set_scale_y :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* the zoom factor. Example values: 256 or LV_SCALE_NONE: no zoom <256: scale down >256: scale up 128: half size 512: double size  */zoom: u32) ---
	/* Set the blend mode of an image.  */
	lv_image_set_blend_mode :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* the new blend mode  */blend_mode: lv_blend_mode_t) ---
	/* Enable/disable anti-aliasing for the transformations (rotate, zoom) or not. The quality is better with anti-aliasing looks better but slower.  */
	lv_image_set_antialias :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* true: anti-aliased; false: not anti-aliased  */antialias: bool) ---
	/* Set the image object size mode. if image_align is LV_IMAGE_ALIGN_STRETCH or LV_IMAGE_ALIGN_FIT rotation, scale and pivot will be overwritten and controlled internally.  */
	lv_image_set_inner_align :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* the new align mode.  */align: lv_image_align_t) ---
	/* Set an A8 bitmap mask for the image.  */
	lv_image_set_bitmap_map_src :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* an :ref:`lv_img_dsc_t` bitmap mask source.  */src: ^lv_img_dsc_t) ---
	/* Get the source of the image the image source (symbol, file name or ::lv-img_dsc_t for C arrays)  */
	lv_image_get_src :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> rawptr ---
	/* Get the offset's x attribute of the image object. offset X value.  */
	lv_image_get_offset_x :: proc(/* pointer to an image  */obj: ^lv_obj_t) -> i32 ---
	/* Get the offset's y attribute of the image object. offset Y value.  */
	lv_image_get_offset_y :: proc(/* pointer to an image  */obj: ^lv_obj_t) -> i32 ---
	/* Get the rotation of the image. rotation in 0.1 degrees (0..3600)  if image_align is LV_IMAGE_ALIGN_STRETCH or LV_IMAGE_ALIGN_FIT rotation will be set to 0 automatically.  */
	lv_image_get_rotation :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the pivot (rotation center) of the image. If pivot is set with LV_PCT, convert it to px before return.  */
	lv_image_get_pivot :: proc(/* pointer to an image object  */obj: ^lv_obj_t, /* store the rotation center here  */pivot: ^lv_point_t) ---
	/* Get the zoom factor of the image. zoom factor (256: no zoom)  */
	lv_image_get_scale :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the horizontal zoom factor of the image. zoom factor (256: no zoom)  */
	lv_image_get_scale_x :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the vertical zoom factor of the image. zoom factor (256: no zoom)  */
	lv_image_get_scale_y :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the width of an image before any transformations. The width of the image.  */
	lv_image_get_src_width :: proc(/* Pointer to an image object.  */obj: ^lv_obj_t) -> i32 ---
	/* Get the height of an image before any transformations. The height of the image.  */
	lv_image_get_src_height :: proc(/* Pointer to an image object.  */obj: ^lv_obj_t) -> i32 ---
	/* Get the transformed width of an image object. The transformed width of the image.  */
	lv_image_get_transformed_width :: proc(/* Pointer to an image object.  */obj: ^lv_obj_t) -> i32 ---
	/* Get the transformed height of an image object. The transformed height of the image.  */
	lv_image_get_transformed_height :: proc(/* Pointer to an image object.  */obj: ^lv_obj_t) -> i32 ---
	/* Get the current blend mode of the image the current blend mode  */
	lv_image_get_blend_mode :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> lv_blend_mode_t ---
	/* Get whether the transformations (rotate, zoom) are anti-aliased or not true: anti-aliased; false: not anti-aliased  */
	lv_image_get_antialias :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> bool ---
	/* Get the size mode of the image element of lv_image_align_t  */
	lv_image_get_inner_align :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> lv_image_align_t ---
	/* Get the bitmap mask source. an :ref:`lv_img_dsc_t` bitmap mask source.  */
	lv_image_get_bitmap_map_src :: proc(/* pointer to an image object  */obj: ^lv_obj_t) -> ^lv_img_dsc_t ---
	/* Bind a pointer Subject to an Image's source. pointer to newly-created Observer  */
	lv_image_bind_src :: proc(/* pointer to Image  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Create an animation image objects pointer to the created animation image object  */
	lv_animimg_create :: proc(/* pointer to an object, it will be the parent of the new button  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the image animation images source.  */
	lv_animimg_set_src :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t, /* pointer to a series images  */dsc: []rawptr, /* images' number  */num: uint) ---
	/* Set the images source for flip playback of animation image.  */
	lv_animimg_set_src_reverse :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t, /* pointer to a series images  */dsc: []rawptr, /* images' number  */num: uint) ---
	/* Startup the image animation.  */
	lv_animimg_start :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t) ---
	/* Delete the image animation.  */
	lv_animimg_delete :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t) -> bool ---
	/* Set the image animation duration time. unit:ms  */
	lv_animimg_set_duration :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t, /* the duration in milliseconds  */duration: u32) ---
	/* Set the image animation repeatedly play times.  */
	lv_animimg_set_repeat_count :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t, /* the number of times to repeat the animation  */count: u32) ---
	/* Make the image animation to play back to when the forward direction is ready.  */
	lv_animimg_set_reverse_duration :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t, /* the duration of the playback image animation in milliseconds. 0: disable playback  */duration: u32) ---
	/* Make the image animation to play back to when the forward direction is ready.  */
	lv_animimg_set_reverse_delay :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t, /* delay in milliseconds before starting the playback image animation.  */duration: u32) ---
	/* Set a function call when the animation image really starts (considering delay )  */
	lv_animimg_set_start_cb :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t, /* a function call when the animation is start  */start_cb: lv_anim_start_cb_t) ---
	/* Set a function call when the animation is completed  */
	lv_animimg_set_completed_cb :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t, /* a function call when the animation is completed  */completed_cb: lv_anim_completed_cb_t) ---
	/* Get the image animation images source. a pointer that will point to a series images  */
	lv_animimg_get_src :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t) -> ^rawptr ---
	/* Get the image animation images source. the number of source images  */
	lv_animimg_get_src_count :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t) -> u8 ---
	/* Get the image animation duration time. unit:ms the animation duration time  */
	lv_animimg_get_duration :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the image animation repeat play times. the repeat count  */
	lv_animimg_get_repeat_count :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the image animation underlying animation. the animation reference  */
	lv_animimg_get_anim :: proc(/* pointer to an animation image object  */obj: ^lv_obj_t) -> ^lv_anim_t ---
	/* Create an arc object pointer to the created arc  */
	lv_arc_create :: proc(/* pointer to an object, it will be the parent of the new arc  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the start angle of an arc. 0 deg: right, 90 bottom, etc.  */
	lv_arc_set_start_angle :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* the start angle. (if LV_USE_FLOAT is enabled it can be fractional too.)  */start: lv_value_precise_t) ---
	/* Set the end angle of an arc. 0 deg: right, 90 bottom, etc.  */
	lv_arc_set_end_angle :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* the end angle (if LV_USE_FLOAT is enabled it can be fractional too.)  */end: lv_value_precise_t) ---
	/* Set the start and end angles  */
	lv_arc_set_angles :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* the start angle (if LV_USE_FLOAT is enabled it can be fractional too.)  */start: lv_value_precise_t, /* the end angle (if LV_USE_FLOAT is enabled it can be fractional too.)  */end: lv_value_precise_t) ---
	/* Set the start angle of an arc background. 0 deg: right, 90 bottom, etc.  */
	lv_arc_set_bg_start_angle :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* the start angle (if LV_USE_FLOAT is enabled it can be fractional too.)  */start: lv_value_precise_t) ---
	/* Set the start angle of an arc background. 0 deg: right, 90 bottom etc.  */
	lv_arc_set_bg_end_angle :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* the end angle (if LV_USE_FLOAT is enabled it can be fractional too.)  */end: lv_value_precise_t) ---
	/* Set the start and end angles of the arc background  */
	lv_arc_set_bg_angles :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* the start angle (if LV_USE_FLOAT is enabled it can be fractional too.)  */start: lv_value_precise_t, /* the end angle (if LV_USE_FLOAT is enabled it can be fractional too.)  */end: lv_value_precise_t) ---
	/* Set the rotation for the whole arc  */
	lv_arc_set_rotation :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* rotation angle  */rotation: i32) ---
	/* Set in which direction the indicator should grow.  */
	lv_arc_set_mode :: proc(/* pointer to arc object  */obj: ^lv_obj_t, /* arc's mode  */type: lv_arc_mode_t) ---
	/* Set a new value on the arc  */
	lv_arc_set_value :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* new value  */value: i32) ---
	/* Set minimum and the maximum values of an arc  */
	lv_arc_set_range :: proc(/* pointer to the arc object  */obj: ^lv_obj_t, /* minimum value  */min: i32, /* maximum value  */max: i32) ---
	/* Set the minimum values of an arc  */
	lv_arc_set_min_value :: proc(/* pointer to the arc object  */obj: ^lv_obj_t, /* minimum value  */min: i32) ---
	/* Set the maximum values of an arc  */
	lv_arc_set_max_value :: proc(/* pointer to the arc object  */obj: ^lv_obj_t, /* maximum value  */max: i32) ---
	/* Set a change rate to limit the speed how fast the arc should reach the pressed point.  */
	lv_arc_set_change_rate :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* the change rate  */rate: u32) ---
	/* Set an offset angle for the knob  */
	lv_arc_set_knob_offset :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* knob offset from main arc in degrees  */offset: i32) ---
	/* Get the start angle of an arc. the start angle [0..360] (if LV_USE_FLOAT is enabled it can be fractional too.)  */
	lv_arc_get_angle_start :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> lv_value_precise_t ---
	/* Get the end angle of an arc. the end angle [0..360] (if LV_USE_FLOAT is enabled it can be fractional too.)  */
	lv_arc_get_angle_end :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> lv_value_precise_t ---
	/* Get the start angle of an arc background. the start angle [0..360] (if LV_USE_FLOAT is enabled it can be fractional too.)  */
	lv_arc_get_bg_angle_start :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> lv_value_precise_t ---
	/* Get the end angle of an arc background. the end angle [0..360] (if LV_USE_FLOAT is enabled it can be fractional too.)  */
	lv_arc_get_bg_angle_end :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> lv_value_precise_t ---
	/* Get the value of an arc the value of the arc  */
	lv_arc_get_value :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the minimum value of an arc the minimum value of the arc  */
	lv_arc_get_min_value :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the maximum value of an arc the maximum value of the arc  */
	lv_arc_get_max_value :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> i32 ---
	/* Get whether the arc is type or not. arc's mode  */
	lv_arc_get_mode :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> lv_arc_mode_t ---
	/* Get the rotation for the whole arc arc's current rotation  */
	lv_arc_get_rotation :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the current knob angle offset arc's current knob offset  */
	lv_arc_get_knob_offset :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the change rate of an arc the change rate  */
	lv_arc_get_change_rate :: proc(/* pointer to an arc object  */obj: ^lv_obj_t) -> u32 ---
	/* Bind an integer subject to an Arc's value. pointer to newly-created Observer  */
	lv_arc_bind_value :: proc(/* pointer to Arc  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Align an object to the current position of the arc (knob)  */
	lv_arc_align_obj_to_angle :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* pointer to an object to align  */obj_to_align: ^lv_obj_t, /* consider the radius larger with this value (< 0: for smaller radius)  */r_offset: i32) ---
	/* Rotate an object to the current position of the arc (knob)  */
	lv_arc_rotate_obj_to_angle :: proc(/* pointer to an arc object  */obj: ^lv_obj_t, /* pointer to an object to rotate  */obj_to_rotate: ^lv_obj_t, /* consider the radius larger with this value (< 0: for smaller radius)  */r_offset: i32) ---
	/* Create an arc label object pointer to the created arc label  */
	lv_arclabel_create :: proc(/* pointer to an object, it will be the parent of the new arc label  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the text of the arc label. 

This function sets the text displayed by an arc label object.   */
	lv_arclabel_set_text :: proc(/* Pointer to the arc label object.  */obj: ^lv_obj_t, /* Pointer to a null-terminated string containing the new text for the label.  */text: ^u8) ---
	/* Set the formatted text of an arc label object. 

This function sets the text of an arc label object with support for variable arguments formatting, similar to printf .   */
	lv_arclabel_set_text_fmt :: proc(/* The arc label object to set the text for.  */obj: ^lv_obj_t, /* A format string that specifies how subsequent arguments are converted to text.  */fmt: ^u8, #c_vararg args: ..any) ---
	/* Sets a new static text for the arc label or refreshes it with the current text. The 'text' must remain valid in memory; the arc label does not manage its lifecycle.  */
	lv_arclabel_set_text_static :: proc(/* Pointer to the arc label object.  */obj: ^lv_obj_t, /* Pointer to the new text. If NULL, the label is refreshed with its current text.  */text: ^u8) ---
	/* Set the start angle of an arc. 0 deg: right, 90 bottom, etc.  */
	lv_arclabel_set_angle_start :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t, /* the start angle. (if LV_USE_FLOAT is enabled it can be fractional too.)  */start: lv_value_precise_t) ---
	/* Set the end angle of an arc. 0 deg: right, 90 bottom, etc.  */
	lv_arclabel_set_angle_size :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t, /* the angle size (if LV_USE_FLOAT is enabled it can be fractional too.)  */size: lv_value_precise_t) ---
	/* Set the rotation for the whole arc  */
	lv_arclabel_set_offset :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t, /* rotation angle  */offset: i32) ---
	/* Set the type of arc.  */
	lv_arclabel_set_dir :: proc(/* pointer to and arc label object  */obj: ^lv_obj_t, /* arc label's direction  */dir: lv_arclabel_dir_t) ---
	/* Enable the recoloring by in-line commands  */
	lv_arclabel_set_recolor :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t, /* true: enable recoloring, false: disable Example: "This is a #ff0000 red# word"  */en: bool) ---
	/* Set the radius for an arc label object.  */
	lv_arclabel_set_radius :: proc(/* pointer to the arc label object.  */obj: ^lv_obj_t, /* The radius value to set for the label's curvature, in pixels.  */radius: u32) ---
	/* Set the center offset x for an arc label object.  */
	lv_arclabel_set_center_offset_x :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t, /* the x offset  */x: u32) ---
	/* Set the center offset y for an arc label object.  */
	lv_arclabel_set_center_offset_y :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t, /* the y offset  */y: u32) ---
	/* Set the text vertical alignment for an arc label object.  */
	lv_arclabel_set_text_vertical_align :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t, /* the vertical alignment  */align: lv_arclabel_text_align_t) ---
	/* Set the text horizontal alignment for an arc label object.  */
	lv_arclabel_set_text_horizontal_align :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t, /* the horizontal alignment  */align: lv_arclabel_text_align_t) ---
	/* Get the start angle of an arc label. the start angle [0..360] (if LV_USE_FLOAT is enabled it can be fractional too.)  */
	lv_arclabel_get_angle_start :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t) -> lv_value_precise_t ---
	/* Get the angle size of an arc label. the end angle [0..360] (if LV_USE_FLOAT is enabled it can be fractional too.)  */
	lv_arclabel_get_angle_size :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t) -> lv_value_precise_t ---
	/* Get whether the arc label is type or not. arc label's direction  */
	lv_arclabel_get_dir :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t) -> lv_arclabel_dir_t ---
	/* Enable the recoloring by in-line commands 

:ref:`lv_arclabel_set_recolor` true: enable recoloring, false: disable    */
	lv_arclabel_get_recolor :: proc(/* pointer to a label object  */obj: ^lv_obj_t) -> bool ---
	/* Get the text of the arc label. the radius of the arc label  */
	lv_arclabel_get_radius :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the center offset x for an arc label object. the x offset  */
	lv_arclabel_get_center_offset_x :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the center offset y for an arc label object. the y offset  */
	lv_arclabel_get_center_offset_y :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the text vertical alignment for an arc label object. the vertical alignment  */
	lv_arclabel_get_text_vertical_align :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t) -> lv_arclabel_text_align_t ---
	/* Get the text horizontal alignment for an arc label object. the horizontal alignment  */
	lv_arclabel_get_text_horizontal_align :: proc(/* pointer to an arc label object  */obj: ^lv_obj_t) -> lv_arclabel_text_align_t ---
	/* Create a label object pointer to the created button  */
	lv_label_create :: proc(/* pointer to an object, it will be the parent of the new label.  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set a new text for a label. Memory will be allocated to store the text by the label. If LV_USE_ARABIC_PERSIAN_CHARS is enabled the text will be modified to have the correct Arabic characters in it.  */
	lv_label_set_text :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* '\0' terminated character string. NULL to refresh with the current text.  */text: ^u8) ---
	/* Set a new formatted text for a label. Memory will be allocated to store the text by the label. If LV_USE_ARABIC_PERSIAN_CHARS is enabled the text will be modified to have the correct Arabic characters in it.  */
	lv_label_set_text_fmt :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* printf -like format string Example: lv_label_set_text_fmt(label1, "%d user", user_num);  */fmt: ^u8, #c_vararg args: ..any) ---
	/* Set a new formatted text for a label. Memory will be allocated to store the text by the label. va_list args; va_start(args, fmt);  lv_label_set_text_vfmt(label1, fmt, args);  va_end(args);   It ignores LV_USE_ARABIC_PERSIAN_CHARS  */
	lv_label_set_text_vfmt :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* printf -like format string  */fmt: ^u8, /* variadic arguments list  */args: c.va_list) ---
	/* Set a static text. It will not be saved by the label so the 'text' variable has to be 'alive' while the label exists. It ignores LV_USE_ARABIC_PERSIAN_CHARS  */
	lv_label_set_text_static :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* pointer to a text. NULL to refresh with the current text.  */text: ^u8) ---
	/* Set the behavior of the label with text longer than the object size  */
	lv_label_set_long_mode :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* the new mode from 'lv_label_long_mode' enum. In LV_LONG_WRAP/DOT/SCROLL/SCROLL_CIRC the size of the label should be set AFTER this function  */long_mode: lv_label_long_mode_t) ---
	/* Set where text selection should start  */
	lv_label_set_text_selection_start :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* character index from where selection should start. LV_LABEL_TEXT_SELECTION_OFF for no selection  */index: u32) ---
	/* Set where text selection should end  */
	lv_label_set_text_selection_end :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* character index where selection should end. LV_LABEL_TEXT_SELECTION_OFF for no selection  */index: u32) ---
	/* Enable the recoloring by in-line commands  */
	lv_label_set_recolor :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* true: enable recoloring, false: disable Example: "This is a #ff0000 red# word"  */en: bool) ---
	/* Get the text of a label the text of the label  */
	lv_label_get_text :: proc(/* pointer to a label object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get the long mode of a label the current long mode  */
	lv_label_get_long_mode :: proc(/* pointer to a label object  */obj: ^lv_obj_t) -> lv_label_long_mode_t ---
	/* Get the relative x and y coordinates of a letter  */
	lv_label_get_letter_pos :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* index of the character [0 ... text length - 1]. Expressed in character index, not byte index (different in UTF-8)  */char_id: u32, /* store the result here (E.g. index = 0 gives 0;0 coordinates if the text if aligned to the left)  */pos: ^lv_point_t) ---
	/* Get the index of letter on a relative point of a label. The index of the letter on the 'pos_p' point (E.g. on 0;0 is the 0. letter if aligned to the left) Expressed in character index and not byte index (different in UTF-8)  */
	lv_label_get_letter_on :: proc(/* pointer to label object  */obj: ^lv_obj_t, /* pointer to point with coordinates on a the label  */pos_in: ^lv_point_t, /* whether to use bidi processed  */bidi: bool) -> u32 ---
	/* Check if a character is drawn under a point. whether a character is drawn under the point  */
	lv_label_is_char_under_pos :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* Point to check for character under  */pos: ^lv_point_t) -> bool ---
	/* selection start index. LV_LABEL_TEXT_SELECTION_OFF if nothing is selected.  */
	lv_label_get_text_selection_start :: proc(/* pointer to a label object.  */obj: ^lv_obj_t) -> u32 ---
	/* selection end index. LV_LABEL_TXT_SEL_OFF if nothing is selected.  */
	lv_label_get_text_selection_end :: proc(/* pointer to a label object.  */obj: ^lv_obj_t) -> u32 ---
	/* true: recoloring is enabled, false: recoloring is disabled  */
	lv_label_get_recolor :: proc(/* pointer to a label object.  */obj: ^lv_obj_t) -> bool ---
	/* Bind an integer, string, or pointer Subject to a Label. pointer to newly-created Observer  If fmt == NULL strings and pointers ( \0 terminated string) will be shown as text as they are, integers as d, floats as %0.1f  */
	lv_label_bind_text :: proc(/* pointer to Label  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t, /* optional printf-like format string with 1 format specifier (e.g. "%d C") or NULL to bind to the value directly.  */fmt: ^u8) -> ^lv_observer_t ---
	/* Insert a text to a label. The label text cannot be static.  */
	lv_label_ins_text :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* character index to insert. Expressed in character index and not byte index. 0: before first char. LV_LABEL_POS_LAST: after last char.  */pos: u32, /* pointer to the text to insert  */txt: ^u8) ---
	/* Delete characters from a label. The label text cannot be static.  */
	lv_label_cut_text :: proc(/* pointer to a label object  */obj: ^lv_obj_t, /* character index from where to cut. Expressed in character index and not byte index. 0: start in front of the first character  */pos: u32, /* number of characters to cut  */cnt: u32) ---
	/* Create a bar object pointer to the created bar  */
	lv_bar_create :: proc(/* pointer to an object, it will be the parent of the new bar  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set a new value on the bar  */
	lv_bar_set_value :: proc(/* pointer to a bar object  */obj: ^lv_obj_t, /* new value  */value: i32, /* LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately  */anim: lv_anim_enable_t) ---
	/* Set a new start value on the bar  */
	lv_bar_set_start_value :: proc(/* pointer to a bar object  */obj: ^lv_obj_t, /* new start value  */start_value: i32, /* LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately  */anim: lv_anim_enable_t) ---
	/* Set minimum and the maximum values of a bar If min is greater than max, the drawing direction becomes to the opposite direction.  */
	lv_bar_set_range :: proc(/* pointer to the bar object  */obj: ^lv_obj_t, /* minimum value  */min: i32, /* maximum value  */max: i32) ---
	/* Set minimum value of a bar  */
	lv_bar_set_min_value :: proc(/* pointer to the bar object  */obj: ^lv_obj_t, /* minimum value  */min: i32) ---
	/* Set maximum value of a bar  */
	lv_bar_set_max_value :: proc(/* pointer to the bar object  */obj: ^lv_obj_t, /* maximum value  */max: i32) ---
	/* Set the type of bar.  */
	lv_bar_set_mode :: proc(/* pointer to bar object  */obj: ^lv_obj_t, /* bar type from lv_bar_mode_t  */mode: lv_bar_mode_t) ---
	/* Set the orientation of bar.  */
	lv_bar_set_orientation :: proc(/* pointer to bar object  */obj: ^lv_obj_t, /* bar orientation from lv_bar_orientation_t  */orientation: lv_bar_orientation_t) ---
	/* Get the value of a bar the value of the bar  */
	lv_bar_get_value :: proc(/* pointer to a bar object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the start value of a bar the start value of the bar  */
	lv_bar_get_start_value :: proc(/* pointer to a bar object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the minimum value of a bar the minimum value of the bar  */
	lv_bar_get_min_value :: proc(/* pointer to a bar object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the maximum value of a bar the maximum value of the bar  */
	lv_bar_get_max_value :: proc(/* pointer to a bar object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the type of bar. bar type from lv_bar_mode_t  */
	lv_bar_get_mode :: proc(/* pointer to bar object  */obj: ^lv_obj_t) -> lv_bar_mode_t ---
	/* Get the orientation of bar. bar orientation from lv_bar_orientation_t  */
	lv_bar_get_orientation :: proc(/* pointer to bar object  */obj: ^lv_obj_t) -> lv_bar_orientation_t ---
	/* Give the bar is in symmetrical mode or not true: in symmetrical mode false : not in  */
	lv_bar_is_symmetrical :: proc(/* pointer to bar object  */obj: ^lv_obj_t) -> bool ---
	/* Bind an integer or float Subject to a Bar's value. pointer to newly-created Observer  */
	lv_bar_bind_value :: proc(/* pointer to Bar  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Create a button object pointer to the created button  */
	lv_button_create :: proc(/* pointer to an object, it will be the parent of the new button  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Create a button matrix object pointer to the created button matrix  */
	lv_buttonmatrix_create :: proc(/* pointer to an object, it will be the parent of the new button matrix  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set a new map. Buttons will be created/deleted according to the map. The button matrix keeps a reference to the map and so the string array must not be deallocated during the life of the matrix.  */
	lv_buttonmatrix_set_map :: proc(/* pointer to a button matrix object  */obj: ^lv_obj_t, /* pointer a string array. The last string has to be: "". Use "\n" to make a line break.  */map_: []^u8) ---
	/* Set the button control map (hidden, disabled etc.) for a button matrix. The control map array will be copied and so may be deallocated after this function returns.  */
	lv_buttonmatrix_set_ctrl_map :: proc(/* pointer to a button matrix object  */obj: ^lv_obj_t, /* pointer to an array of lv_button_ctrl_t control bytes. The length of the array and position of the elements must match the number and order of the individual buttons (i.e. excludes newline entries). An element of the map should look like e.g.: ctrl_map[0] = width | LV_BUTTONMATRIX_CTRL_NO_REPEAT | LV_BUTTONMATRIX_CTRL_TGL_ENABLE  */ctrl_map: []lv_buttonmatrix_ctrl_t) ---
	/* Set the selected buttons  */
	lv_buttonmatrix_set_selected_button :: proc(/* pointer to button matrix object  */obj: ^lv_obj_t, /* 0 based index of the button to modify. (Not counting new lines)  */btn_id: u32) ---
	/* Set the attributes of a button of the button matrix  */
	lv_buttonmatrix_set_button_ctrl :: proc(/* pointer to button matrix object  */obj: ^lv_obj_t, /* 0 based index of the button to modify. (Not counting new lines)  */btn_id: u32, /* OR-ed attributes. E.g. LV_BUTTONMATRIX_CTRL_NO_REPEAT | LV_BUTTONMATRIX_CTRL_CHECKABLE  */ctrl: lv_buttonmatrix_ctrl_t) ---
	/* Clear the attributes of a button of the button matrix  */
	lv_buttonmatrix_clear_button_ctrl :: proc(/* pointer to button matrix object  */obj: ^lv_obj_t, /* 0 based index of the button to modify. (Not counting new lines)  */btn_id: u32, /* OR-ed attributes. E.g. LV_BUTTONMATRIX_CTRL_NO_REPEAT | LV_BUTTONMATRIX_CTRL_CHECKABLE  */ctrl: lv_buttonmatrix_ctrl_t) ---
	/* Set attributes of all buttons of a button matrix  */
	lv_buttonmatrix_set_button_ctrl_all :: proc(/* pointer to a button matrix object  */obj: ^lv_obj_t, /* attribute(s) to set from lv_buttonmatrix_ctrl_t . Values can be ORed.  */ctrl: lv_buttonmatrix_ctrl_t) ---
	/* Clear the attributes of all buttons of a button matrix  */
	lv_buttonmatrix_clear_button_ctrl_all :: proc(/* pointer to a button matrix object  */obj: ^lv_obj_t, /* attribute(s) to set from lv_buttonmatrix_ctrl_t . Values can be ORed.  */ctrl: lv_buttonmatrix_ctrl_t) ---
	/* Set a single button's relative width. This method will cause the matrix be regenerated and is a relatively expensive operation. It is recommended that initial width be specified using lv_buttonmatrix_set_ctrl_map and this method only be used for dynamic changes.  */
	lv_buttonmatrix_set_button_width :: proc(/* pointer to button matrix object  */obj: ^lv_obj_t, /* 0 based index of the button to modify.  */btn_id: u32, /* relative width compared to the buttons in the same row. [1..15]  */width: u32) ---
	/* Make the button matrix like a selector widget (only one button may be checked at a time). LV_BUTTONMATRIX_CTRL_CHECKABLE must be enabled on the buttons to be selected using lv_buttonmatrix_set_ctrl() or :ref:`lv_buttonmatrix_set_button_ctrl_all()` .  */
	lv_buttonmatrix_set_one_checked :: proc(/* pointer to a button matrix object  */obj: ^lv_obj_t, /* whether "one check" mode is enabled  */en: bool) ---
	/* Get the current map of a button matrix the current map  */
	lv_buttonmatrix_get_map :: proc(/* pointer to a button matrix object  */obj: ^lv_obj_t) -> ^^u8 ---
	/* Get the index of the lastly "activated" button by the user (pressed, released, focused etc) Useful in the event_cb to get the text of the button, check if hidden etc. index of the last released button (LV_BUTTONMATRIX_BUTTON_NONE: if unset)  */
	lv_buttonmatrix_get_selected_button :: proc(/* pointer to button matrix object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the button's text text of btn_index` button  */
	lv_buttonmatrix_get_button_text :: proc(/* pointer to button matrix object  */obj: ^lv_obj_t, /* the index a button not counting new line characters.  */btn_id: u32) -> ^u8 ---
	/* Get the whether a control value is enabled or disabled for button of a button matrix true: the control attribute is enabled false: disabled  */
	lv_buttonmatrix_has_button_ctrl :: proc(/* pointer to a button matrix object  */obj: ^lv_obj_t, /* the index of a button not counting new line characters.  */btn_id: u32, /* control values to check (ORed value can be used)  */ctrl: lv_buttonmatrix_ctrl_t) -> bool ---
	/* Tell whether "one check" mode is enabled or not. true: "one check" mode is enabled; false: disabled  */
	lv_buttonmatrix_get_one_checked :: proc(/* Button matrix object  */obj: ^lv_obj_t) -> bool ---
	/* Create a calendar widget pointer the created calendar  */
	lv_calendar_create :: proc(/* pointer to an object, it will be the parent of the new calendar  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the today's year, month and day at once  */
	lv_calendar_set_today_date :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* today's year  */year: u32, /* today's month [1..12]  */month: u32, /* today's day [1..31]  */day: u32) ---
	/* Set the today's year  */
	lv_calendar_set_today_year :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* today's year  */year: u32) ---
	/* Set the today's year  */
	lv_calendar_set_today_month :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* today's month [1..12]  */month: u32) ---
	/* Set the today's year  */
	lv_calendar_set_today_day :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* today's day [1..31]  */day: u32) ---
	/* Set the currently shown year and month at once  */
	lv_calendar_set_month_shown :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* shown year  */year: u32, /* shown month [1..12]  */month: u32) ---
	/* Set the currently shown year  */
	lv_calendar_set_shown_year :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* shown year  */year: u32) ---
	/* Set the currently shown month  */
	lv_calendar_set_shown_month :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* shown month [1..12]  */month: u32) ---
	/* Set the highlighted dates  */
	lv_calendar_set_highlighted_dates :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* pointer to an :ref:`lv_calendar_date_t` array containing the dates. Only the pointer will be saved so this variable can't be local which will be destroyed later.  */highlighted: []lv_calendar_date_t, /* number of dates in the array  */date_num: uint) ---
	/* Set the name of the days  */
	lv_calendar_set_day_names :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t, /* pointer to an array with the names. E.g. const char * days[7] = {"Sun", "Mon", ...} Only the pointer will be saved so this variable can't be local which will be destroyed later.  */day_names: ^^u8) ---
	/* Get the button matrix object of the calendar. It shows the dates and day names. pointer to a the button matrix  */
	lv_calendar_get_btnmatrix :: proc(/* pointer to a calendar object  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the today's date return pointer to an :ref:`lv_calendar_date_t` variable containing the date of today.  */
	lv_calendar_get_today_date :: proc(/* pointer to a calendar object  */calendar: ^lv_obj_t) -> ^lv_calendar_date_t ---
	/* Get the currently showed pointer to an :ref:`lv_calendar_date_t` variable containing the date is being shown.  */
	lv_calendar_get_showed_date :: proc(/* pointer to a calendar object  */calendar: ^lv_obj_t) -> ^lv_calendar_date_t ---
	/* Get the highlighted dates pointer to an :ref:`lv_calendar_date_t` array containing the dates.  */
	lv_calendar_get_highlighted_dates :: proc(/* pointer to a calendar object  */calendar: ^lv_obj_t) -> ^lv_calendar_date_t ---
	/* Get the number of the highlighted dates number of highlighted days  */
	lv_calendar_get_highlighted_dates_num :: proc(/* pointer to a calendar object  */calendar: ^lv_obj_t) -> uint ---
	/* Get the currently pressed day LV_RESULT_OK: there is a valid pressed date LV_RESULT_INVALID: there is no pressed data  */
	lv_calendar_get_pressed_date :: proc(/* pointer to a calendar object  */calendar: ^lv_obj_t, /* store the pressed date here  */date: ^lv_calendar_date_t) -> lv_result_t ---
	/* Create a calendar header with drop-drowns to select the year and month the created header  */
	lv_calendar_add_header_arrow :: proc(/* pointer to a calendar object.  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Create a calendar header with drop-drowns to select the year and month the created header  */
	lv_calendar_add_header_dropdown :: proc(/* pointer to a calendar object.  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Sets a custom calendar year list  */
	lv_calendar_header_dropdown_set_year_list :: proc(/* pointer to a calendar object  */parent: ^lv_obj_t, /* pointer to an const char array with the years list, see lv_dropdown set_options for more information. E.g. `const char * years = "2023\n2022\n2021\n2020\n2019" Only the pointer will be saved so this variable can't be local which will be destroyed later.  */years_list: ^u8) ---
	/* Create a canvas object pointer to the created canvas  */
	lv_canvas_create :: proc(/* pointer to an object, it will be the parent of the new canvas  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set a buffer for the canvas. 

Use :ref:`lv_canvas_set_draw_buf()` instead if you need to set a buffer with alignment requirement.   */
	lv_canvas_set_buffer :: proc(/* pointer to a canvas object  */obj: ^lv_obj_t, /* buffer where content of canvas will be. The required size is (lv_image_color_format_get_px_size(cf) * w) / 8 * h) It can be allocated with :ref:`lv_malloc()` or it can be statically allocated array (e.g. static :ref:`lv_color_t` buf[100*50]) or it can be an address in RAM or external SRAM  */buf: rawptr, /* width of canvas  */w: i32, /* height of canvas  */h: i32, /* color format. LV_COLOR_FORMAT...  */cf: lv_color_format_t) ---
	/* Set a draw buffer for the canvas. A draw buffer either can be allocated by :ref:`lv_draw_buf_create()` or defined statically by LV_DRAW_BUF_DEFINE_STATIC . When buffer start address and stride has alignment requirement, it's recommended to use lv_draw_buf_create .  */
	lv_canvas_set_draw_buf :: proc(/* pointer to a canvas object  */obj: ^lv_obj_t, /* pointer to a draw buffer  */draw_buf: ^lv_draw_buf_t) ---
	/* Set a pixel's color and opacity The following color formats are supported LV_COLOR_FORMAT_I1/2/4/8, LV_COLOR_FORMAT_A8, LV_COLOR_FORMAT_RGB565, LV_COLOR_FORMAT_RGB888, LV_COLOR_FORMAT_XRGB8888, LV_COLOR_FORMAT_ARGB8888  */
	lv_canvas_set_px :: proc(/* pointer to a canvas  */obj: ^lv_obj_t, /* X coordinate of the pixel  */x: i32, /* Y coordinate of the pixel  */y: i32, /* the color  */color: lv_color_t, /* the opacity  */opa: lv_opa_t) ---
	/* Set the palette color of a canvas for index format. Valid only for LV_COLOR_FORMAT_I1/2/4/8  */
	lv_canvas_set_palette :: proc(/* pointer to canvas object  */obj: ^lv_obj_t, /* the palette color to set: for LV_COLOR_FORMAT_I1 : 0..1 for LV_COLOR_FORMAT_I2 : 0..3 for LV_COLOR_FORMAT_I4 : 0..15 for LV_COLOR_FORMAT_I8 : 0..255  */index: u8, /* the color to set  */color: lv_color32_t) ---
	lv_canvas_get_draw_buf :: proc(obj: ^lv_obj_t) -> ^lv_draw_buf_t ---
	/* Get a pixel's color and opacity ARGB8888 color of the pixel  */
	lv_canvas_get_px :: proc(/* pointer to a canvas  */obj: ^lv_obj_t, /* X coordinate of the pixel  */x: i32, /* Y coordinate of the pixel  */y: i32) -> lv_color32_t ---
	/* Get the image of the canvas as a pointer to an :ref:`lv_img_dsc_t` variable. pointer to the image descriptor.  */
	lv_canvas_get_image :: proc(/* pointer to a canvas object  */canvas: ^lv_obj_t) -> ^lv_img_dsc_t ---
	/* Return the pointer for the buffer. It's recommended to use this function instead of the buffer form the return value of :ref:`lv_canvas_get_image()` as is can be aligned pointer to the buffer  */
	lv_canvas_get_buf :: proc(/* pointer to a canvas object  */canvas: ^lv_obj_t) -> rawptr ---
	/* Copy a buffer to the canvas  */
	lv_canvas_copy_buf :: proc(/* pointer to a canvas object  */obj: ^lv_obj_t, /* the area of the canvas to copy  */canvas_area: ^lv_area_t, /* pointer to a buffer to store the copied data  */dest_buf: ^lv_draw_buf_t, /* the area of the destination buffer to copy to. If omitted NULL, copy to the whole dest_buf  */dest_area: ^lv_area_t) ---
	/* Fill the canvas with color  */
	lv_canvas_fill_bg :: proc(/* pointer to a canvas  */obj: ^lv_obj_t, /* the background color  */color: lv_color_t, /* the desired opacity  */opa: lv_opa_t) ---
	/* Initialize a layer to use LVGL's generic draw functions (lv_draw_rect/label/...) on the canvas. Needs to be usd in pair with lv_canvas_finish_layer .  */
	lv_canvas_init_layer :: proc(/* pointer to a canvas  */canvas: ^lv_obj_t, /* pointer to a layer variable to initialize  */layer: ^lv_layer_t) ---
	/* Wait until all the drawings are finished on layer. Needs to be usd in pair with lv_canvas_init_layer .  */
	lv_canvas_finish_layer :: proc(/* pointer to a canvas  */canvas: ^lv_obj_t, /* pointer to a layer to finalize  */layer: ^lv_layer_t) ---
	/* Just a wrapper to LV_CANVAS_BUF_SIZE for bindings.  */
	lv_canvas_buf_size :: proc(w: i32, h: i32, bpp: u8, stride: u8) -> u32 ---
	/* Create a chart object pointer to the created chart  */
	lv_chart_create :: proc(/* pointer to an object, it will be the parent of the new chart  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set a new type for a chart  */
	lv_chart_set_type :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* new type of the chart (from 'lv_chart_type_t' enum)  */type: lv_chart_type_t) ---
	/* Set the number of points on a data line on a chart  */
	lv_chart_set_point_count :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* new number of points on the data lines  */cnt: u32) ---
	/* Set the minimal and maximal y values on an axis  */
	lv_chart_set_axis_range :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* LV_CHART_AXIS_PRIMARY_Y or LV_CHART_AXIS_SECONDARY_Y  */axis: lv_chart_axis_t, /* minimum value of the y axis  */min: i32, /* maximum value of the y axis  */max: i32) ---
	/* Set the minimal values on an axis  */
	lv_chart_set_axis_min_value :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* LV_CHART_AXIS_PRIMARY_Y or LV_CHART_AXIS_SECONDARY_Y  */axis: lv_chart_axis_t, /* minimal value of the y axis  */min: i32) ---
	/* Set the maximal y values on an axis  */
	lv_chart_set_axis_max_value :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* LV_CHART_AXIS_PRIMARY_Y or LV_CHART_AXIS_SECONDARY_Y  */axis: lv_chart_axis_t, /* maximum value of the y axis  */max: i32) ---
	/* Set update mode of the chart object. Affects  */
	lv_chart_set_update_mode :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* the update mode  */update_mode: lv_chart_update_mode_t) ---
	/* Set the number of horizontal and vertical division lines  */
	lv_chart_set_div_line_count :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* number of horizontal division lines  */hdiv: u32, /* number of vertical division lines  */vdiv: u32) ---
	/* Set the number of horizontal division lines  */
	lv_chart_set_hor_div_line_count :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* number of horizontal division lines  */cnt: u32) ---
	/* Set the number of vertical division lines  */
	lv_chart_set_ver_div_line_count :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* number of vertical division lines  */cnt: u32) ---
	/* Get the type of a chart type of the chart (from 'lv_chart_t' enum)  */
	lv_chart_get_type :: proc(/* pointer to chart object  */obj: ^lv_obj_t) -> lv_chart_type_t ---
	/* Get the data point number per data line on chart point number on each data line  */
	lv_chart_get_point_count :: proc(/* pointer to chart object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the update mode of a chart the update mode  */
	lv_chart_get_update_mode :: proc(/* pointer to a chart object  */obj: ^lv_obj_t) -> lv_chart_update_mode_t ---
	/* Get the number of horizontal division lines the number of horizontal division lines  */
	lv_chart_get_hor_div_line_count :: proc(/* pointer to a chart object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the number of vertical division lines the number of vertical division lines  */
	lv_chart_get_ver_div_line_count :: proc(/* pointer to a chart object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the current index of the x-axis start point in the data array the index of the current x start point in the data array  */
	lv_chart_get_x_start_point :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t) -> u32 ---
	/* Get the position of a point to the chart.  */
	lv_chart_get_point_pos_by_id :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to series  */ser: ^lv_chart_series_t, /* the index.  */id: u32, /* store the result position here  */p_out: ^lv_point_t) ---
	/* Refresh a chart if its data line has changed  */
	lv_chart_refresh :: proc(/* pointer to chart object  */obj: ^lv_obj_t) ---
	/* Allocate and add a data series to the chart pointer to the allocated data series or NULL on failure  */
	lv_chart_add_series :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* color of the data series  */color: lv_color_t, /* the y axis to which the series should be attached (LV_CHART_AXIS_PRIMARY_Y or LV_CHART_AXIS_SECONDARY_Y)  */axis: lv_chart_axis_t) -> ^lv_chart_series_t ---
	/* Deallocate and remove a data series from a chart  */
	lv_chart_remove_series :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */series: ^lv_chart_series_t) ---
	/* Hide/Unhide a single series of a chart.  */
	lv_chart_hide_series :: proc(/* pointer to a chart object.  */chart: ^lv_obj_t, /* pointer to a series object  */series: ^lv_chart_series_t, /* true: hide the series  */hide: bool) ---
	/* Change the color of a series  */
	lv_chart_set_series_color :: proc(/* pointer to a chart object.  */chart: ^lv_obj_t, /* pointer to a series object  */series: ^lv_chart_series_t, /* the new color of the series  */color: lv_color_t) ---
	/* Get the color of a series the color of the series  */
	lv_chart_get_series_color :: proc(/* pointer to a chart object.  */chart: ^lv_obj_t, /* pointer to a series object  */series: ^lv_chart_series_t) -> lv_color_t ---
	/* Set the index of the x-axis start point in the data array. This point will be considers the first (left) point and the other points will be drawn after it.  */
	lv_chart_set_x_start_point :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* the index of the x point in the data array  */id: u32) ---
	/* Get the next series. the next series or NULL if there is no more.  */
	lv_chart_get_series_next :: proc(/* pointer to a chart  */chart: ^lv_obj_t, /* the previous series or NULL to get the first  */ser: ^lv_chart_series_t) -> ^lv_chart_series_t ---
	/* Add a cursor with a given color pointer to the created cursor  */
	lv_chart_add_cursor :: proc(/* pointer to chart object  */obj: ^lv_obj_t, /* color of the cursor  */color: lv_color_t, /* direction of the cursor. LV_DIR_RIGHT/LEFT/TOP/DOWN/HOR/VER/ALL . OR-ed values are possible  */dir: lv_dir_t) -> ^lv_chart_cursor_t ---
	/* Remove a cursor  */
	lv_chart_remove_cursor :: proc(/* pointer to chart object  */obj: ^lv_obj_t, /* pointer to the cursor  */cursor: ^lv_chart_cursor_t) ---
	/* Set the coordinate of the cursor with respect to the paddings  */
	lv_chart_set_cursor_pos :: proc(/* pointer to a chart object  */chart: ^lv_obj_t, /* pointer to the cursor  */cursor: ^lv_chart_cursor_t, /* the new coordinate of cursor relative to the chart  */pos: ^lv_point_t) ---
	/* Set the X coordinate of the cursor with respect to the paddings  */
	lv_chart_set_cursor_pos_x :: proc(/* pointer to a chart object  */chart: ^lv_obj_t, /* pointer to the cursor  */cursor: ^lv_chart_cursor_t, /* the new X coordinate of cursor relative to the chart  */x: i32) ---
	/* Set the coordinate of the cursor with respect to the paddings  */
	lv_chart_set_cursor_pos_y :: proc(/* pointer to a chart object  */chart: ^lv_obj_t, /* pointer to the cursor  */cursor: ^lv_chart_cursor_t, /* the new Y coordinate of cursor relative to the chart  */y: i32) ---
	/* Stick the cursor to a point  */
	lv_chart_set_cursor_point :: proc(/* pointer to a chart object  */chart: ^lv_obj_t, /* pointer to the cursor  */cursor: ^lv_chart_cursor_t, /* pointer to a series  */ser: ^lv_chart_series_t, /* the point's index or LV_CHART_POINT_NONE to not assign to any points.  */point_id: u32) ---
	/* Get the coordinate of the cursor with respect to the paddings coordinate of the cursor as :ref:`lv_point_t`  */
	lv_chart_get_cursor_point :: proc(/* pointer to a chart object  */chart: ^lv_obj_t, /* pointer to cursor  */cursor: ^lv_chart_cursor_t) -> lv_point_t ---
	/* Initialize all data points of a series with a value  */
	lv_chart_set_all_values :: proc(/* pointer to chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* the new value for all points. LV_CHART_POINT_NONE can be used to hide the points.  */value: i32) ---
	/* Set the next point's Y value according to the update mode policy.  */
	lv_chart_set_next_value :: proc(/* pointer to chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* the new value of the next data  */value: i32) ---
	/* Set the next point's X and Y value according to the update mode policy.  */
	lv_chart_set_next_value2 :: proc(/* pointer to chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* the new X value of the next data  */x_value: i32, /* the new Y value of the next data  */y_value: i32) ---
	/* Same as lv_chart_set_next_value but set the values from an array  */
	lv_chart_set_series_values :: proc(/* pointer to chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* the new values to set  */values: []i32, /* number of items in values  */values_cnt: uint) ---
	/* Same as lv_chart_set_next_value2 but set the values from an array  */
	lv_chart_set_series_values2 :: proc(/* pointer to chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* the new values to set on the X axis  */x_values: []i32, /* the new values to set o nthe Y axis  */y_values: []i32, /* number of items in x_values and y_values  */values_cnt: uint) ---
	/* Set an individual point's y value of a chart's series directly based on its index  */
	lv_chart_set_series_value_by_id :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* the index of the x point in the array  */id: u32, /* value to assign to array point  */value: i32) ---
	/* Set an individual point's x and y value of a chart's series directly based on its index Can be used only with LV_CHART_TYPE_SCATTER .  */
	lv_chart_set_series_value_by_id2 :: proc(/* pointer to chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* the index of the x point in the array  */id: u32, /* the new X value of the next data  */x_value: i32, /* the new Y value of the next data  */y_value: i32) ---
	/* Set an external array for the y data points to use for the chart NOTE: It is the users responsibility to make sure the point_cnt matches the external array size.  */
	lv_chart_set_series_ext_y_array :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* external array of points for chart  */array: []i32) ---
	/* Set an external array for the x data points to use for the chart NOTE: It is the users responsibility to make sure the point_cnt matches the external array size.  */
	lv_chart_set_series_ext_x_array :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t, /* external array of points for chart  */array: []i32) ---
	/* Get the array of y values of a series the array of values with 'point_count' elements  */
	lv_chart_get_series_y_array :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t) -> ^i32 ---
	/* Get the array of x values of a series the array of values with 'point_count' elements  */
	lv_chart_get_series_x_array :: proc(/* pointer to a chart object  */obj: ^lv_obj_t, /* pointer to a data series on 'chart'  */ser: ^lv_chart_series_t) -> ^i32 ---
	/* Get the index of the currently pressed point. It's the same for every series. the index of the point [0 .. point count] or LV_CHART_POINT_ID_NONE if no point is being pressed  */
	lv_chart_get_pressed_point :: proc(/* pointer to a chart object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the overall offset from the chart's side to the center of the first point. In case of a bar chart it will be the center of the first column group the offset of the center  */
	lv_chart_get_first_point_center_offset :: proc(/* pointer to a chart object  */obj: ^lv_obj_t) -> i32 ---
	/* Create a check box object pointer to the created check box  */
	lv_checkbox_create :: proc(/* pointer to an object, it will be the parent of the new button  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the text of a check box. txt will be copied and may be deallocated after this function returns.  */
	lv_checkbox_set_text :: proc(/* pointer to a check box  */obj: ^lv_obj_t, /* the text of the check box. NULL to refresh with the current text.  */txt: ^u8) ---
	/* Set the text of a check box. txt must not be deallocated during the life of this checkbox.  */
	lv_checkbox_set_text_static :: proc(/* pointer to a check box  */obj: ^lv_obj_t, /* the text of the check box.  */txt: ^u8) ---
	/* Get the text of a check box pointer to the text of the check box  */
	lv_checkbox_get_text :: proc(/* pointer to check box object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Create a drop-down list object pointer to the created drop-down list  */
	lv_dropdown_create :: proc(/* pointer to an object, it will be the parent of the new drop-down list  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set text of the drop-down list's button. If set to NULL the selected option's text will be displayed on the button. If set to a specific text then that text will be shown regardless of the selected option.  */
	lv_dropdown_set_text :: proc(/* pointer to a drop-down list object  */obj: ^lv_obj_t, /* the text as a string (Only its pointer is saved)  */txt: ^u8) ---
	/* Set the options in a drop-down list from a string. The options will be copied and saved in the object so the options can be destroyed after calling this function  */
	lv_dropdown_set_options :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t, /* a string with ' ' separated options. E.g. "One\nTwo\nThree"  */options: ^u8) ---
	/* Set the options in a drop-down list from a static string (global, static or dynamically allocated). Only the pointer of the option string will be saved.  */
	lv_dropdown_set_options_static :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t, /* a static string with ' ' separated options. E.g. "One\nTwo\nThree"  */options: ^u8) ---
	/* Add an options to a drop-down list from a string. Only works for non-static options.  */
	lv_dropdown_add_option :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t, /* a string without ' '. E.g. "Four"  */option: ^u8, /* the insert position, indexed from 0, LV_DROPDOWN_POS_LAST = end of string  */pos: u32) ---
	/* Clear all options in a drop-down list. Works with both static and dynamic options.  */
	lv_dropdown_clear_options :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t) ---
	/* Set the selected option  */
	lv_dropdown_set_selected :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t, /* id of the selected option (0 ... number of option - 1);  */sel_opt: u32) ---
	/* Set the direction of the a drop-down list  */
	lv_dropdown_set_dir :: proc(/* pointer to a drop-down list object  */obj: ^lv_obj_t, /* LV_DIR_LEFT/RIGHT/TOP/BOTTOM  */dir: lv_dir_t) ---
	/* Set an arrow or other symbol to display when on drop-down list's button. Typically a down caret or arrow. angle and zoom transformation can be applied if the symbol is an image. E.g. when drop down is checked (opened) rotate the symbol by 180 degree  */
	lv_dropdown_set_symbol :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t, /* a text like LV_SYMBOL_DOWN , an image (pointer or path) or NULL to not draw symbol icon  */symbol: rawptr) ---
	/* Set whether the selected option in the list should be highlighted or not  */
	lv_dropdown_set_selected_highlight :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t, /* true: highlight enabled; false: disabled  */en: bool) ---
	/* Get the list of a drop-down to allow styling or other modifications pointer to the list of the drop-down  */
	lv_dropdown_get_list :: proc(/* pointer to a drop-down list object  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get text of the drop-down list's button. the text as string, NULL if no text  */
	lv_dropdown_get_text :: proc(/* pointer to a drop-down list object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get the options of a drop-down list the options separated by ' '-s (E.g. "Option1\nOption2\nOption3")  */
	lv_dropdown_get_options :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get the index of the selected option index of the selected option (0 ... number of option - 1);  */
	lv_dropdown_get_selected :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the total number of options the total number of options in the list  */
	lv_dropdown_get_option_count :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the current selected option as a string  */
	lv_dropdown_get_selected_str :: proc(/* pointer to drop-down object  */obj: ^lv_obj_t, /* pointer to an array to store the string  */buf: ^u8, /* size of buf in bytes. 0: to ignore it.  */buf_size: u32) ---
	/* Get the index of an option. index of option in the list of all options. -1 if not found.  */
	lv_dropdown_get_option_index :: proc(/* pointer to drop-down object  */obj: ^lv_obj_t, /* an option as string  */option: ^u8) -> i32 ---
	/* Get the symbol on the drop-down list. Typically a down caret or arrow. the symbol or NULL if not enabled  */
	lv_dropdown_get_symbol :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get whether the selected option in the list should be highlighted or not true: highlight enabled; false: disabled  */
	lv_dropdown_get_selected_highlight :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t) -> bool ---
	/* Get the direction of the drop-down list LV_DIR_LEF/RIGHT/TOP/BOTTOM  */
	lv_dropdown_get_dir :: proc(/* pointer to a drop-down list object  */obj: ^lv_obj_t) -> lv_dir_t ---
	/* Open the drop.down list  */
	lv_dropdown_open :: proc(/* pointer to drop-down list object  */dropdown_obj: ^lv_obj_t) ---
	/* Close (Collapse) the drop-down list  */
	lv_dropdown_close :: proc(/* pointer to drop-down list object  */obj: ^lv_obj_t) ---
	/* Tells whether the list is opened or not true if the list os opened  */
	lv_dropdown_is_open :: proc(/* pointer to a drop-down list object  */obj: ^lv_obj_t) -> bool ---
	/* Bind an integer Subject to a Dropdown's value. pointer to newly-created Observer  */
	lv_dropdown_bind_value :: proc(/* pointer to Dropdown  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Create an image button object pointer to the created image button  */
	lv_imagebutton_create :: proc(/* pointer to an object, it will be the parent of the new image button  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set images for a state of the image button  */
	lv_imagebutton_set_src :: proc(/* pointer to an image button object  */obj: ^lv_obj_t, /* for which state set the new image  */state: lv_imagebutton_state_t, /* pointer to an image source for the left side of the button (a C array or path to a file)  */src_left: rawptr, /* pointer to an image source for the middle of the button (ideally 1px wide) (a C array or path to a file)  */src_mid: rawptr, /* pointer to an image source for the right side of the button (a C array or path to a file)  */src_right: rawptr) ---
	/* Set the left image for a state of the image button  */
	lv_imagebutton_set_src_left :: proc(/* pointer to an image button object  */obj: ^lv_obj_t, /* for which state set the new image  */state: lv_imagebutton_state_t, /* pointer to an image source for the left side of the button (a C array or path to a file)  */src_left: rawptr) ---
	/* Set the right image for a state of the image button  */
	lv_imagebutton_set_src_right :: proc(/* pointer to an image button object  */obj: ^lv_obj_t, /* for which state set the new image  */state: lv_imagebutton_state_t, /* pointer to an image source for the right side of the button (a C array or path to a file)  */src_right: rawptr) ---
	/* Set the middle image for a state of the image button  */
	lv_imagebutton_set_src_mid :: proc(/* pointer to an image button object  */obj: ^lv_obj_t, /* for which state set the new image  */state: lv_imagebutton_state_t, /* pointer to an image source for the middle of the button (a C array or path to a file)  */src_mid: rawptr) ---
	/* Use this function instead of lv_obj_add/remove_state to set a state manually  */
	lv_imagebutton_set_state :: proc(/* pointer to an image button object  */obj: ^lv_obj_t, /* the new state  */state: lv_imagebutton_state_t) ---
	/* Get the left image in a given state pointer to the left image source (a C array or path to a file)  */
	lv_imagebutton_get_src_left :: proc(/* pointer to an image button object  */obj: ^lv_obj_t, /* the state where to get the image (from lv_button_state_t ) `  */state: lv_imagebutton_state_t) -> rawptr ---
	/* Get the middle image in a given state pointer to the middle image source (a C array or path to a file)  */
	lv_imagebutton_get_src_middle :: proc(/* pointer to an image button object  */obj: ^lv_obj_t, /* the state where to get the image (from lv_button_state_t ) `  */state: lv_imagebutton_state_t) -> rawptr ---
	/* Get the right image in a given state pointer to the left image source (a C array or path to a file)  */
	lv_imagebutton_get_src_right :: proc(/* pointer to an image button object  */obj: ^lv_obj_t, /* the state where to get the image (from lv_button_state_t ) `  */state: lv_imagebutton_state_t) -> rawptr ---
	/* Create a Keyboard object pointer to the created keyboard object  */
	lv_keyboard_create :: proc(/* pointer to an object, it will be the parent of the new keyboard  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Assign a text area to the keyboard. Pressed characters will be inserted there.  */
	lv_keyboard_set_textarea :: proc(/* pointer to a keyboard object  */kb: ^lv_obj_t, /* pointer to a text area object to write into  */ta: ^lv_obj_t) ---
	/* Set a new mode (e.g., text, number, special characters).  */
	lv_keyboard_set_mode :: proc(/* pointer to a keyboard object  */kb: ^lv_obj_t, /* the desired mode (see 'lv_keyboard_mode_t')  */mode: lv_keyboard_mode_t) ---
	/* Enable or disable popovers showing button titles on press.  */
	lv_keyboard_set_popovers :: proc(/* pointer to a keyboard object  */kb: ^lv_obj_t, /* true to enable popovers; false to disable  */en: bool) ---
	/* Set a custom button map for the keyboard.  */
	lv_keyboard_set_map :: proc(/* pointer to a keyboard object  */kb: ^lv_obj_t, /* the mode to assign the new map to (see 'lv_keyboard_mode_t')  */mode: lv_keyboard_mode_t, /* pointer to a string array describing the button map see ' :ref:`lv_buttonmatrix_set_map()` ' for more details  */map_: []^u8, /* pointer to the control map. See ' :ref:`lv_buttonmatrix_set_ctrl_map()` '  */ctrl_map: []lv_buttonmatrix_ctrl_t) ---
	/* Get the text area currently assigned to the keyboard. pointer to the assigned text area object  */
	lv_keyboard_get_textarea :: proc(/* pointer to a keyboard object  */kb: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the current mode of the keyboard. the current mode (see 'lv_keyboard_mode_t')  */
	lv_keyboard_get_mode :: proc(/* pointer to a keyboard object  */kb: ^lv_obj_t) -> lv_keyboard_mode_t ---
	/* Check whether popovers are enabled on the keyboard. true if popovers are enabled; false otherwise  */
	lv_keyboard_get_popovers :: proc(/* pointer to a keyboard object  */obj: ^lv_obj_t) -> bool ---
	/* Get the current button map of the keyboard. pointer to the map array  */
	lv_keyboard_get_map_array :: proc(/* pointer to a keyboard object  */kb: ^lv_obj_t) -> ^^u8 ---
	/* Get the index of the last selected button (pressed, released, focused, etc.). Useful in the event_cb to retrieve button text or properties. index of the last interacted button returns LV_BUTTONMATRIX_BUTTON_NONE if not set  */
	lv_keyboard_get_selected_button :: proc(/* pointer to a keyboard object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the text of a button by index. pointer to the text of the button  */
	lv_keyboard_get_button_text :: proc(/* pointer to a keyboard object  */obj: ^lv_obj_t, /* index of the button (excluding newline characters)  */btn_id: u32) -> ^u8 ---
	/* Default keyboard event callback to handle button presses. Adds characters to the text area and switches map if needed. If a custom event_cb is used, this function can be called within it.  */
	lv_keyboard_def_event_cb :: proc(/* the triggering event  */e: ^lv_event_t) ---
	/* Create a led object pointer to the created led  */
	lv_led_create :: proc(/* pointer to an object, it will be the parent of the new led  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the color of the LED  */
	lv_led_set_color :: proc(/* pointer to a LED object  */led: ^lv_obj_t, /* the color of the LED  */color: lv_color_t) ---
	/* Set the brightness of a LED object  */
	lv_led_set_brightness :: proc(/* pointer to a LED object  */led: ^lv_obj_t, /* LV_LED_BRIGHT_MIN (max. dark) ... LV_LED_BRIGHT_MAX (max. light)  */bright: u8) ---
	/* Light on a LED  */
	lv_led_on :: proc(/* pointer to a LED object  */led: ^lv_obj_t) ---
	/* Light off a LED  */
	lv_led_off :: proc(/* pointer to a LED object  */led: ^lv_obj_t) ---
	/* Toggle the state of a LED  */
	lv_led_toggle :: proc(/* pointer to a LED object  */led: ^lv_obj_t) ---
	/* Get the brightness of a LED object bright 0 (max. dark) ... 255 (max. light)  */
	lv_led_get_brightness :: proc(/* pointer to LED object  */obj: ^lv_obj_t) -> u8 ---
	/* Get the color of a LED object color color of the LED  */
	lv_led_get_color :: proc(/* pointer to LED object  */obj: ^lv_obj_t) -> lv_color_t ---
	/* Create a line object pointer to the created line  */
	lv_line_create :: proc(/* pointer to an object, it will be the parent of the new line  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set an array of points. The line object will connect these points.  */
	lv_line_set_points :: proc(/* pointer to a line object  */obj: ^lv_obj_t, /* an array of points. Only the address is saved, so the array needs to be alive while the line exists  */points: []lv_point_precise_t, /* number of points in 'point_a'  */point_num: u32) ---
	/* Set a non-const array of points. Identical to lv_line_set_points except the array may be retrieved by lv_line_get_points_mutable .  */
	lv_line_set_points_mutable :: proc(/* pointer to a line object  */obj: ^lv_obj_t, /* a non-const array of points. Only the address is saved, so the array needs to be alive while the line exists.  */points: []lv_point_precise_t, /* number of points in 'point_a'  */point_num: u32) ---
	/* Enable (or disable) the y coordinate inversion. If enabled then y will be subtracted from the height of the object, therefore the y = 0 coordinate will be on the bottom.  */
	lv_line_set_y_invert :: proc(/* pointer to a line object  */obj: ^lv_obj_t, /* true: enable the y inversion, false:disable the y inversion  */en: bool) ---
	/* Get the pointer to the array of points. const pointer to the array of points  */
	lv_line_get_points :: proc(/* pointer to a line object  */obj: ^lv_obj_t) -> ^lv_point_precise_t ---
	/* Get the number of points in the array of points. number of points in array of points  */
	lv_line_get_point_count :: proc(/* pointer to a line object  */obj: ^lv_obj_t) -> u32 ---
	/* Check the mutability of the stored point array pointer. true: the point array pointer is mutable, false: constant  */
	lv_line_is_point_array_mutable :: proc(/* pointer to a line object  */obj: ^lv_obj_t) -> bool ---
	/* Get a pointer to the mutable array of points or NULL if it is not mutable pointer to the array of points. NULL if not mutable.  */
	lv_line_get_points_mutable :: proc(/* pointer to a line object  */obj: ^lv_obj_t) -> ^lv_point_precise_t ---
	/* Get the y inversion attribute true: y inversion is enabled, false: disabled  */
	lv_line_get_y_invert :: proc(/* pointer to a line object  */obj: ^lv_obj_t) -> bool ---
	/* Create a list object pointer to the created list  */
	lv_list_create :: proc(/* pointer to an object, it will be the parent of the new list  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Add text to a list pointer to the created label  */
	lv_list_add_text :: proc(/* pointer to a list, it will be the parent of the new label  */list: ^lv_obj_t, /* text of the new label  */txt: ^u8) -> ^lv_obj_t ---
	/* Add button to a list pointer to the created button  */
	lv_list_add_button :: proc(/* pointer to a list, it will be the parent of the new button  */list: ^lv_obj_t, /* icon for the button, when NULL it will have no icon  */icon: rawptr, /* text of the new button, when NULL no text will be added  */txt: ^u8) -> ^lv_obj_t ---
	/* Get text of a given list button text of btn, if btn doesn't have text "" will be returned  */
	lv_list_get_button_text :: proc(/* pointer to a list  */list: ^lv_obj_t, /* pointer to the button  */btn: ^lv_obj_t) -> ^u8 ---
	/* Set text of a given list button  */
	lv_list_set_button_text :: proc(/* pointer to a list  */list: ^lv_obj_t, /* pointer to the button  */btn: ^lv_obj_t, /* pointer to the text  */txt: ^u8) ---
	/* Create a menu object pointer to the created menu  */
	lv_menu_create :: proc(/* pointer to an object, it will be the parent of the new menu  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Create a menu page object. 

This call inserts the new page under menu->storage as its parent, which is itself a child of the menu, so the resulting object hierarchy is: menu => storage => new_page where storage is a Base Widget. pointer to the created menu page    */
	lv_menu_page_create :: proc(/* pointer to menu object.  */menu: ^lv_obj_t, /* pointer to text for title in header (NULL to not display title)  */title: ^u8) -> ^lv_obj_t ---
	/* Create a menu cont object pointer to the created menu cont  */
	lv_menu_cont_create :: proc(/* pointer to a menu page or menu section object, it will be the parent of the new menu cont object  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Create a menu section object pointer to the created menu section  */
	lv_menu_section_create :: proc(/* pointer to a menu page object, it will be the parent of the new menu section object  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Create a menu separator object pointer to the created menu separator  */
	lv_menu_separator_create :: proc(/* pointer to a menu page object, it will be the parent of the new menu separator object  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set menu page to display in main  */
	lv_menu_set_page :: proc(/* pointer to the menu  */obj: ^lv_obj_t, /* pointer to the menu page to set (NULL to clear main and clear menu history)  */page: ^lv_obj_t) ---
	/* Set menu page title  */
	lv_menu_set_page_title :: proc(/* pointer to the menu page  */page: ^lv_obj_t, /* pointer to text for title in header (NULL to not display title)  */title: ^u8) ---
	/* Set menu page title with a static text. It will not be saved by the label so the 'text' variable has to be 'alive' while the page exists.  */
	lv_menu_set_page_title_static :: proc(/* pointer to the menu page  */page: ^lv_obj_t, /* pointer to text for title in header (NULL to not display title)  */title: ^u8) ---
	/* Set menu page to display in sidebar  */
	lv_menu_set_sidebar_page :: proc(/* pointer to the menu  */obj: ^lv_obj_t, /* pointer to the menu page to set (NULL to clear sidebar)  */page: ^lv_obj_t) ---
	/* Set the how the header should behave and its position  */
	lv_menu_set_mode_header :: proc(/* pointer to a menu  */obj: ^lv_obj_t, /* LV_MENU_HEADER_TOP_FIXED/TOP_UNFIXED/BOTTOM_FIXED  */mode: lv_menu_mode_header_t) ---
	/* Set whether back button should appear at root  */
	lv_menu_set_mode_root_back_button :: proc(/* pointer to a menu  */obj: ^lv_obj_t, /* LV_MENU_ROOT_BACK_BUTTON_DISABLED/ENABLED  */mode: lv_menu_mode_root_back_button_t) ---
	/* Add menu to the menu item  */
	lv_menu_set_load_page_event :: proc(/* pointer to the menu  */menu: ^lv_obj_t, /* pointer to the obj  */obj: ^lv_obj_t, /* pointer to the page to load when obj is clicked  */page: ^lv_obj_t) ---
	/* Get a pointer to menu page that is currently displayed in main pointer to current page  */
	lv_menu_get_cur_main_page :: proc(/* pointer to the menu  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get a pointer to menu page that is currently displayed in sidebar pointer to current page  */
	lv_menu_get_cur_sidebar_page :: proc(/* pointer to the menu  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get a pointer to main header obj pointer to main header obj  */
	lv_menu_get_main_header :: proc(/* pointer to the menu  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get a pointer to main header back btn obj pointer to main header back btn obj  */
	lv_menu_get_main_header_back_button :: proc(/* pointer to the menu  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get a pointer to sidebar header obj pointer to sidebar header obj  */
	lv_menu_get_sidebar_header :: proc(/* pointer to the menu  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get a pointer to sidebar header obj pointer to sidebar header back btn obj  */
	lv_menu_get_sidebar_header_back_button :: proc(/* pointer to the menu  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Check if an obj is a root back btn true if it is a root back btn  */
	lv_menu_back_button_is_root :: proc(/* pointer to the menu  */menu: ^lv_obj_t, /* pointer to the back button  */obj: ^lv_obj_t) -> bool ---
	/* Get the header mode of the menu LV_MENU_HEADER_TOP_FIXED/TOP_UNFIXED/BOTTOM_FIXED  */
	lv_menu_get_mode_header :: proc(/* pointer to a menu  */obj: ^lv_obj_t) -> lv_menu_mode_header_t ---
	/* Get the root back button mode of the menu LV_MENU_ROOT_BACK_BUTTON_DISABLED/ENABLED  */
	lv_menu_get_mode_root_back_button :: proc(/* pointer to a menu  */obj: ^lv_obj_t) -> lv_menu_mode_root_back_button_t ---
	/* Clear menu history  */
	lv_menu_clear_history :: proc(/* pointer to the menu  */obj: ^lv_obj_t) ---
	/* Create an empty message box the created message box  */
	lv_msgbox_create :: proc(/* the parent or NULL to create a modal msgbox  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Add title to the message box. It also creates a header for the title. the created title label  */
	lv_msgbox_add_title :: proc(/* pointer to a message box  */obj: ^lv_obj_t, /* the text of the tile  */title: ^u8) -> ^lv_obj_t ---
	/* Add a button to the header of to the message box. It also creates a header. the created button  */
	lv_msgbox_add_header_button :: proc(/* pointer to a message box  */obj: ^lv_obj_t, /* the icon of the button  */icon: rawptr) -> ^lv_obj_t ---
	/* Add a text to the content area of message box. Multiple texts will be created below each other. the created button  */
	lv_msgbox_add_text :: proc(/* pointer to a message box  */obj: ^lv_obj_t, /* text to add  */text: ^u8) -> ^lv_obj_t ---
	/* Add a button to the footer of to the message box. It also creates a footer. the created button  */
	lv_msgbox_add_footer_button :: proc(/* pointer to a message box  */obj: ^lv_obj_t, /* the text of the button  */text: ^u8) -> ^lv_obj_t ---
	/* Add a close button to the message box. It also creates a header. the created close button  */
	lv_msgbox_add_close_button :: proc(/* pointer to a message box  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the header widget the header, or NULL if not exists  */
	lv_msgbox_get_header :: proc(/* pointer to a message box  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the footer widget the footer, or NULL if not exists  */
	lv_msgbox_get_footer :: proc(/* pointer to a message box  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the content widget the content  */
	lv_msgbox_get_content :: proc(/* pointer to a message box  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the title label the title, or NULL if it does not exist  */
	lv_msgbox_get_title :: proc(/* pointer to a message box  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Close a message box  */
	lv_msgbox_close :: proc(/* pointer to a message box  */mbox: ^lv_obj_t) ---
	/* Close a message box in the next call of the message box  */
	lv_msgbox_close_async :: proc(/* pointer to a message box  */mbox: ^lv_obj_t) ---
	/* Create a roller object pointer to the created roller  */
	lv_roller_create :: proc(/* pointer to an object, it will be the parent of the new roller.  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the options on a roller  */
	lv_roller_set_options :: proc(/* pointer to roller object  */obj: ^lv_obj_t, /* a string with ' ' separated options. E.g. "One\nTwo\nThree"  */options: ^u8, /* LV_ROLLER_MODE_NORMAL or LV_ROLLER_MODE_INFINITE  */mode: lv_roller_mode_t) ---
	/* Set the selected option  */
	lv_roller_set_selected :: proc(/* pointer to a roller object  */obj: ^lv_obj_t, /* index of the selected option (0 ... number of option - 1);  */sel_opt: u32, /* LV_ANIM_ON: set with animation; LV_ANIM_OFF set immediately  */anim: lv_anim_enable_t) ---
	/* Sets the given string as the selection on the roller. Does not alter the current selection on failure. true if set successfully and false if the given string does not exist as an option in the roller  */
	lv_roller_set_selected_str :: proc(/* pointer to roller object  */obj: ^lv_obj_t, /* pointer to the string you want to set as an option  */sel_opt: ^u8, /* LV_ANIM_ON: set with animation; LV_ANIM_OFF set immediately  */anim: lv_anim_enable_t) -> bool ---
	/* Set the height to show the given number of rows (options)  */
	lv_roller_set_visible_row_count :: proc(/* pointer to a roller object  */obj: ^lv_obj_t, /* number of desired visible rows  */row_cnt: u32) ---
	/* Get the index of the selected option index of the selected option (0 ... number of option - 1);  */
	lv_roller_get_selected :: proc(/* pointer to a roller object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the current selected option as a string.  */
	lv_roller_get_selected_str :: proc(/* pointer to roller object  */obj: ^lv_obj_t, /* pointer to an array to store the string  */buf: ^u8, /* size of buf in bytes. 0: to ignore it.  */buf_size: u32) ---
	/* Get the options of a roller the options separated by ' '-s (E.g. "Option1\nOption2\nOption3")  */
	lv_roller_get_options :: proc(/* pointer to roller object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get the total number of options the total number of options  */
	lv_roller_get_option_count :: proc(/* pointer to a roller object  */obj: ^lv_obj_t) -> u32 ---
	/* Get an option as a string. LV_RESULT_OK if option found  */
	lv_roller_get_option_str :: proc(/* pointer to roller object  */obj: ^lv_obj_t, /* index of chosen option  */option: u32, /* pointer to an array to store the string  */buf: ^u8, /* size of buf in bytes. 0: to ignore it.  */buf_size: u32) -> lv_result_t ---
	/* Bind an integer Subject to a Roller's value. pointer to newly-created Observer  */
	lv_roller_bind_value :: proc(/* pointer to Roller  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Create an scale object pointer to created Scale Widget  */
	lv_scale_create :: proc(/* pointer to an object, it will be the parent of the new scale  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set scale mode. See lv_scale_mode_t.  */
	lv_scale_set_mode :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* the new scale mode  */mode: lv_scale_mode_t) ---
	/* Set scale total tick count (including minor and major ticks).  */
	lv_scale_set_total_tick_count :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* New total tick count  */total_tick_count: u32) ---
	/* Sets how often major ticks are drawn.  */
	lv_scale_set_major_tick_every :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* the new count for major tick drawing  */major_tick_every: u32) ---
	/* Sets label visibility.  */
	lv_scale_set_label_show :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* true/false to enable tick label  */show_label: bool) ---
	/* Set minimum and maximum values on Scale.  */
	lv_scale_set_range :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* minimum value of Scale  */min: i32, /* maximum value of Scale  */max: i32) ---
	/* Set minimum values on Scale.  */
	lv_scale_set_min_value :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* minimum value of Scale  */min: i32) ---
	/* Set maximum values on Scale.  */
	lv_scale_set_max_value :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, max: i32) ---
	/* Set angle between the low end and the high end of the Scale. (Applies only to round Scales.)  */
	lv_scale_set_angle_range :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, angle_range: u32) ---
	/* Set angular offset from the 3-o'clock position of the low end of the Scale. (Applies only to round Scales.)  */
	lv_scale_set_rotation :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* clockwise angular offset (in degrees) from the 3-o'clock position of the low end of the scale; negative and >360 values are first normalized to range [0..360]. Examples: 0 = 3 o'clock (right side) 30 = 4 o'clock 60 = 5 o'clock 90 = 6 o'clock 135 = midway between 7 and 8 o'clock (default) 180 = 9 o'clock 270 = 12 o'clock 300 = 1 o'clock 330 = 2 o'clock -30 = 2 o'clock 390 = 4 o'clock  */rotation: i32) ---
	/* Point line needle to specified value.  */
	lv_scale_set_line_needle_value :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* needle_line of the Scale. The line points will be allocated and managed by the Scale unless the line point array was previously set using lv_line_set_points_mutable .  */needle_line: ^lv_obj_t, /* length of the needle needle_length>0: needle_length=needle_length; needle_length<0: needle_length=radius-|needle_length|;  */needle_length: i32, /* Scale value needle will point to  */value: i32) ---
	/* Point image needle to specified value; image must point to the right. E.g. -O--- >  */
	lv_scale_set_image_needle_value :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* pointer to needle's Image  */needle_img: ^lv_obj_t, /* Scale value needle will point to  */value: i32) ---
	/* Set custom text source for major ticks labels.  */
	lv_scale_set_text_src :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* pointer to an array of strings which will be display at major ticks; last element must be a NULL pointer.  */txt_src: []^u8) ---
	/* Draw Scale after all its children are drawn.  */
	lv_scale_set_post_draw :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* true: enable post draw  */en: bool) ---
	/* Draw Scale ticks on top of all other parts.  */
	lv_scale_set_draw_ticks_on_top :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t, /* true: enable draw ticks on top of all parts  */en: bool) ---
	/* Add a Section to specified Scale. Section will not be drawn until a valid range is set for it using :ref:`lv_scale_set_section_range()` . pointer to new Section  */
	lv_scale_add_section :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> ^lv_scale_section_t ---
	/* DEPRECATED, use lv_scale_set_section_range instead. Set range for specified Scale Section  */
	lv_scale_section_set_range :: proc(/* pointer to Section  */section: ^lv_scale_section_t, min: i32, max: i32) ---
	/* Set the range of a scale section  */
	lv_scale_set_section_range :: proc(/* pointer to scale  */scale: ^lv_obj_t, /* pointer to section  */section: ^lv_scale_section_t, min: i32, max: i32) ---
	/* Set the minimum value of a scale section  */
	lv_scale_set_section_min_value :: proc(/* pointer to scale  */scale: ^lv_obj_t, /* pointer to section  */section: ^lv_scale_section_t, /* the section's new minimum value  */min: i32) ---
	/* Set the maximum value of a scale section  */
	lv_scale_set_section_max_value :: proc(/* pointer to scale  */scale: ^lv_obj_t, /* pointer to section  */section: ^lv_scale_section_t, /* the section's new maximum value  */max: i32) ---
	/* DEPRECATED, use lv_scale_set_section_style_main/indicator/items instead. Set style for specified part of Section.  */
	lv_scale_section_set_style :: proc(/* pointer to Section  */section: ^lv_scale_section_t, /* the part of the Scale the style will apply to, e.g. LV_PART_INDICATOR  */part: lv_part_t, /* pointer to style to apply  */section_part_style: ^lv_style_t) ---
	/* Set the style of the line on a section.  */
	lv_scale_set_section_style_main :: proc(/* pointer to scale  */scale: ^lv_obj_t, /* pointer to section  */section: ^lv_scale_section_t, /* point to a style  */style: ^lv_style_t) ---
	/* Set the style of the major ticks and label on a section.  */
	lv_scale_set_section_style_indicator :: proc(/* pointer to scale  */scale: ^lv_obj_t, /* pointer to section  */section: ^lv_scale_section_t, /* point to a style  */style: ^lv_style_t) ---
	/* Set the style of the minor ticks on a section.  */
	lv_scale_set_section_style_items :: proc(/* pointer to scale  */scale: ^lv_obj_t, /* pointer to section  */section: ^lv_scale_section_t, /* point to a style  */style: ^lv_style_t) ---
	/* Get scale mode. See lv_scale_mode_t Scale mode  */
	lv_scale_get_mode :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> lv_scale_mode_t ---
	/* Get scale total tick count (including minor and major ticks) Scale total tick count  */
	lv_scale_get_total_tick_count :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Get how often the major tick will be drawn Scale major tick every count  */
	lv_scale_get_major_tick_every :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Get angular location of low end of Scale. Scale low end angular location  */
	lv_scale_get_rotation :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Gets label visibility true if tick label is enabled, false otherwise  */
	lv_scale_get_label_show :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> bool ---
	/* Get Scale's range in degrees Scale's angle_range  */
	lv_scale_get_angle_range :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> u32 ---
	/* Get minimum value for Scale Scale's minimum value  */
	lv_scale_get_range_min_value :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Get maximum value for Scale Scale's maximum value  */
	lv_scale_get_range_max_value :: proc(/* pointer to Scale Widget  */obj: ^lv_obj_t) -> i32 ---
	/* Bind an integer subject to a scales section minimum value pointer to newly-created Observer  */
	lv_scale_bind_section_min_value :: proc(/* pointer to a Scale  */obj: ^lv_obj_t, /* pointer to a Scale section  */section: ^lv_scale_section_t, /* pointer to a Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Bind an integer subject to a scales section maximum value pointer to newly-created Observer  */
	lv_scale_bind_section_max_value :: proc(/* pointer to an Scale  */obj: ^lv_obj_t, /* pointer to a Scale section  */section: ^lv_scale_section_t, /* pointer to a Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Create a slider object pointer to the created slider  */
	lv_slider_create :: proc(/* pointer to an object, it will be the parent of the new slider.  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set a new value on the slider  */
	lv_slider_set_value :: proc(/* pointer to a slider object  */obj: ^lv_obj_t, /* the new value  */value: i32, /* LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately  */anim: lv_anim_enable_t) ---
	/* Set a new value for the left knob of a slider  */
	lv_slider_set_start_value :: proc(/* pointer to a slider object  */obj: ^lv_obj_t, /* new value  */value: i32, /* LV_ANIM_ON: set the value with an animation; LV_ANIM_OFF: change the value immediately  */anim: lv_anim_enable_t) ---
	/* Set the minimum and the maximum values of a bar  */
	lv_slider_set_range :: proc(/* pointer to the slider object  */obj: ^lv_obj_t, /* minimum value  */min: i32, /* maximum value  */max: i32) ---
	/* Set the minimum values of a bar  */
	lv_slider_set_min_value :: proc(/* pointer to the slider object  */obj: ^lv_obj_t, /* minimum value  */min: i32) ---
	/* Set the maximum values of a bar  */
	lv_slider_set_max_value :: proc(/* pointer to the slider object  */obj: ^lv_obj_t, /* maximum value  */max: i32) ---
	/* Set the mode of slider.  */
	lv_slider_set_mode :: proc(/* pointer to a slider object  */obj: ^lv_obj_t, /* the mode of the slider. See lv_slider_mode_t  */mode: lv_slider_mode_t) ---
	/* Set the orientation of slider.  */
	lv_slider_set_orientation :: proc(/* pointer to a slider object  */obj: ^lv_obj_t, /* slider orientation from lv_slider_orientation_t  */orientation: lv_slider_orientation_t) ---
	/* Get the value of the main knob of a slider the value of the main knob of the slider  */
	lv_slider_get_value :: proc(/* pointer to a slider object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the value of the left knob of a slider the value of the left knob of the slider  */
	lv_slider_get_left_value :: proc(/* pointer to a slider object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the minimum value of a slider the minimum value of the slider  */
	lv_slider_get_min_value :: proc(/* pointer to a slider object  */obj: ^lv_obj_t) -> i32 ---
	/* Get the maximum value of a slider the maximum value of the slider  */
	lv_slider_get_max_value :: proc(/* pointer to a slider object  */obj: ^lv_obj_t) -> i32 ---
	/* Give the slider is being dragged or not true: drag in progress false: not dragged  */
	lv_slider_is_dragged :: proc(/* pointer to a slider object  */obj: ^lv_obj_t) -> bool ---
	/* Get the mode of the slider. see lv_slider_mode_t  */
	lv_slider_get_mode :: proc(/* pointer to a slider object  */slider: ^lv_obj_t) -> lv_slider_mode_t ---
	/* Get the orientation of slider. slider orientation from lv_slider_orientation_t  */
	lv_slider_get_orientation :: proc(slider: ^lv_obj_t) -> lv_slider_orientation_t ---
	/* Give the slider is in symmetrical mode or not true: in symmetrical mode false : not in  */
	lv_slider_is_symmetrical :: proc(/* pointer to slider object  */obj: ^lv_obj_t) -> bool ---
	/* Bind an integer or float Subject to a Slider's value. pointer to newly-created Observer  */
	lv_slider_bind_value :: proc(/* pointer to Slider  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	lv_span_stack_init :: proc() ---
	lv_span_stack_deinit :: proc() ---
	/* Create a spangroup object pointer to the created spangroup  */
	lv_spangroup_create :: proc(/* pointer to an object, it will be the parent of the new spangroup  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Create a span string descriptor and add to spangroup. pointer to the created span.  */
	lv_spangroup_add_span :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t) -> ^lv_span_t ---
	/* Remove the span from the spangroup and free memory. Note that before calling lv_spangroup_delete_span  lv_observer_remove needs to be called manually as LVGL can't remove the binding automatically.  */
	lv_spangroup_delete_span :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* pointer to a span.  */span: ^lv_span_t) ---
	/* Set a new text for a span. Memory will be allocated to store the text by the span. As the spangroup is not passed a redraw (invalidation) can't be triggered automatically. Therefore lv_spangroup_refresh(spangroup) needs to be called manually,  */
	lv_span_set_text :: proc(/* pointer to a span.  */span: ^lv_span_t, /* pointer to a text.  */text: ^u8) ---
	/* Set a new text for a span using a printf-like formatting string. Memory will be allocated to store the text by the span. As the spangroup is not passed a redraw (invalidation) can't be triggered automatically. Therefore lv_spangroup_refresh(spangroup) needs to be called manually,  */
	lv_span_set_text_fmt :: proc(/* pointer to a span.  */span: ^lv_span_t, /* printf -like format string  */fmt: ^u8, #c_vararg args: ..any) ---
	/* Set a static text. It will not be saved by the span so the 'text' variable has to be 'alive' while the span exist. As the spangroup is not passed a redraw (invalidation) can't be triggered automatically. Therefore lv_spangroup_refresh(spangroup) needs to be called manually,  */
	lv_span_set_text_static :: proc(/* pointer to a span.  */span: ^lv_span_t, /* pointer to a text.  */text: ^u8) ---
	/* Set a new text for a span. Memory will be allocated to store the text by the span.  */
	lv_spangroup_set_span_text :: proc(/* pointer to a spangroup widget.  */obj: ^lv_obj_t, /* pointer to a span.  */span: ^lv_span_t, /* pointer to a text.  */text: ^u8) ---
	/* Set a new text for a span. Memory will be allocated to store the text by the span.  */
	lv_spangroup_set_span_text_static :: proc(/* pointer to a spangroup widget.  */obj: ^lv_obj_t, /* pointer to a span.  */span: ^lv_span_t, /* pointer to a text.  */text: ^u8) ---
	/* Set a new text for a span using a printf-like formatting string. Memory will be allocated to store the text by the span.  */
	lv_spangroup_set_span_text_fmt :: proc(/* pointer to a spangroup widget.  */obj: ^lv_obj_t, /* pointer to a span.  */span: ^lv_span_t, /* printf -like format string  */fmt: ^u8, #c_vararg args: ..any) ---
	/* Copy all style properties of style to the bbuilt-in static style of the span.  */
	lv_spangroup_set_span_style :: proc(/* pointer_to a spangroup  */obj: ^lv_obj_t, /* pointer to a span.  */span: ^lv_span_t, /* pointer to a style to copy into the span's built-in style  */style: ^lv_style_t) ---
	/* DEPRECATED. Use the text_align style property instead Set the align of the spangroup.  */
	lv_spangroup_set_align :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* see lv_text_align_t for details.  */align: lv_text_align_t) ---
	/* Set the overflow of the spangroup.  */
	lv_spangroup_set_overflow :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* see lv_span_overflow_t for details.  */overflow: lv_span_overflow_t) ---
	/* Set the indent of the spangroup.  */
	lv_spangroup_set_indent :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* the first line indentation  */indent: i32) ---
	/* DEPRECATED, set the width to LV_SIZE_CONTENT or fixed value to control expanding/wrapping" Set the mode of the spangroup.  */
	lv_spangroup_set_mode :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* see lv_span_mode_t for details.  */mode: lv_span_mode_t) ---
	/* Set maximum lines of the spangroup.  */
	lv_spangroup_set_max_lines :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* max lines that can be displayed in LV_SPAN_MODE_BREAK mode. < 0 means no limit.  */lines: i32) ---
	/* Get a pointer to the style of a span's built-in style. Any lv_style_set_... functions can be applied on the returned style. pointer to the style. (valid as long as the span is valid)  */
	lv_span_get_style :: proc(/* pointer to the span  */span: ^lv_span_t) -> ^lv_style_t ---
	/* Get a pointer to the text of a span pointer to the text  */
	lv_span_get_text :: proc(/* pointer to the span  */span: ^lv_span_t) -> ^u8 ---
	/* Get a spangroup child by its index. 

The child span at index id , or NULL if the ID does not exist   */
	lv_spangroup_get_child :: proc(/* The spangroup object  */obj: ^lv_obj_t, /* the index of the child. 0: the oldest (firstly created) child 1: the second oldest child count-1: the youngest -1: the youngest -2: the second youngest  */id: i32) -> ^lv_span_t ---
	/* Get number of spans the span count of the spangroup.  */
	lv_spangroup_get_span_count :: proc(/* the spangroup object to get the child count of.  */obj: ^lv_obj_t) -> u32 ---
	/* Get the align of the spangroup. the align value.  */
	lv_spangroup_get_align :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t) -> lv_text_align_t ---
	/* Get the overflow of the spangroup. the overflow value.  */
	lv_spangroup_get_overflow :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t) -> lv_span_overflow_t ---
	/* Get the indent of the spangroup. the indent value.  */
	lv_spangroup_get_indent :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t) -> i32 ---
	/* Get the mode of the spangroup.  */
	lv_spangroup_get_mode :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t) -> lv_span_mode_t ---
	/* Get maximum lines of the spangroup. the max lines value.  */
	lv_spangroup_get_max_lines :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t) -> i32 ---
	/* Get max line height of all span in the spangroup.  */
	lv_spangroup_get_max_line_height :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t) -> i32 ---
	/* Get the text content width when all span of spangroup on a line. text content width or max_width.  */
	lv_spangroup_get_expand_width :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* if text content width >= max_width, return max_width to reduce computation, if max_width == 0, returns the text content width.  */max_width: u32) -> u32 ---
	/* Get the text content height with width fixed.  */
	lv_spangroup_get_expand_height :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* the width of the span group.  */width: i32) -> i32 ---
	/* Get the span's coords in the spangroup. Before calling this function, please make sure that the layout of span group has been updated. Like calling :ref:`lv_obj_update_layout()` like function. +--------+
|Heading +--->------------------+
|  Pos   |   |     Heading      |
+--------+---+------------------+
|                               |
|                               |
|                               |
|            Middle   +--------+|
|                     |Trailing||
|                   +-|  Pos   ||
|                   | +--------+|
+-------------------v-----------+
|     Trailing      |
+-------------------+  the span's coords in the spangroup.  */
	lv_spangroup_get_span_coords :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* pointer to a span.  */span: ^lv_span_t) -> lv_span_coords_t ---
	/* Get the span object by point. pointer to the span under the point or NULL if not found.  */
	lv_spangroup_get_span_by_point :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t, /* pointer to point containing absolute coordinates  */point: ^lv_point_t) -> ^lv_span_t ---
	/* Update the mode of the spangroup.  */
	lv_spangroup_refresh :: proc(/* pointer to a spangroup object.  */obj: ^lv_obj_t) ---
	/* Bind an integer, string, or pointer Subject to a Spangroup's Span. pointer to newly-created Observer  If fmt == NULL strings and pointers ( \0 terminated string) will be shown as text as they are, integers as d, floats as %0.1f  */
	lv_spangroup_bind_span_text :: proc(/* pointer to Spangroup  */obj: ^lv_obj_t, /* pointer to Span  */span: ^lv_span_t, /* pointer to Subject  */subject: ^lv_subject_t, /* optional printf-like format string with 1 format specifier (e.g. "%d C") or NULL to bind to the value directly.  */fmt: ^u8) -> ^lv_observer_t ---
	/* Create a text area object pointer to the created text area  */
	lv_textarea_create :: proc(/* pointer to an object, it will be the parent of the new text area  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Insert a character to the current cursor position. To add a wide char, e.g. '' use lv_text_encoded_conv_wc(' )  */
	lv_textarea_add_char :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* a character (e.g. 'a )  */c: u32) ---
	/* Insert a text to the current cursor position  */
	lv_textarea_add_text :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* a '\0' terminated string to insert  */txt: ^u8) ---
	/* Delete a the left character from the current cursor position  */
	lv_textarea_delete_char :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) ---
	/* Delete the right character from the current cursor position  */
	lv_textarea_delete_char_forward :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) ---
	/* Set the text of a text area  */
	lv_textarea_set_text :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* pointer to the text  */txt: ^u8) ---
	/* Set the placeholder text of a text area  */
	lv_textarea_set_placeholder_text :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* pointer to the text  */txt: ^u8) ---
	/* Set the cursor position  */
	lv_textarea_set_cursor_pos :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* the new cursor position in character index < 0 : index from the end of the text LV_TEXTAREA_CURSOR_LAST: go after the last character  */pos: i32) ---
	/* Enable/Disable the positioning of the cursor by clicking the text on the text area.  */
	lv_textarea_set_cursor_click_pos :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* true: enable click positions; false: disable  */en: bool) ---
	/* Enable/Disable password mode  */
	lv_textarea_set_password_mode :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* true: enable, false: disable  */en: bool) ---
	/* Set the replacement characters to show in password mode  */
	lv_textarea_set_password_bullet :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* pointer to the replacement text  */bullet: ^u8) ---
	/* Configure the text area to one line or back to normal  */
	lv_textarea_set_one_line :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* true: one line, false: normal  */en: bool) ---
	/* Set a list of characters. Only these characters will be accepted by the text area  */
	lv_textarea_set_accepted_chars :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* list of characters. Only the pointer is saved. E.g. "+-.,0123456789"  */list: ^u8) ---
	/* Set max length of a Text Area.  */
	lv_textarea_set_max_length :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* the maximal number of characters can be added ( lv_textarea_set_text ignores it)  */num: u32) ---
	/* In LV_EVENT_INSERT the text which planned to be inserted can be replaced by another text. It can be used to add automatic formatting to the text area.  */
	lv_textarea_set_insert_replace :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* pointer to a new string to insert. If "" no text will be added. The variable must be live after the event_cb exists. (Should be global or static )  */txt: ^u8) ---
	/* Enable/disable selection mode.  */
	lv_textarea_set_text_selection :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* true or false to enable/disable selection mode  */en: bool) ---
	/* Set how long show the password before changing it to '*'  */
	lv_textarea_set_password_show_time :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* show time in milliseconds. 0: hide immediately.  */time: u32) ---
	/* Deprecated Use the normal text_align style property instead Set the label's alignment. It sets where the label is aligned (in one line mode it can be smaller than the text area) and how the lines of the area align in case of multiline text area  */
	lv_textarea_set_align :: proc(/* pointer to a text area object  */obj: ^lv_obj_t, /* the align mode from :ref:`lv_text_align_t`  */align: lv_text_align_t) ---
	/* Get the text of a text area. In password mode it gives the real text (not '*'s). pointer to the text  */
	lv_textarea_get_text :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get the placeholder text of a text area pointer to the text  */
	lv_textarea_get_placeholder_text :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get the label of a text area pointer to the label object  */
	lv_textarea_get_label :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the current cursor position in character index the cursor position  */
	lv_textarea_get_cursor_pos :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> u32 ---
	/* Get whether the cursor click positioning is enabled or not. true: enable click positions; false: disable  */
	lv_textarea_get_cursor_click_pos :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> bool ---
	/* Get the password mode attribute true: password mode is enabled, false: disabled  */
	lv_textarea_get_password_mode :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> bool ---
	/* Get the replacement characters to show in password mode pointer to the replacement text  */
	lv_textarea_get_password_bullet :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get the one line configuration attribute true: one line configuration is enabled, false: disabled  */
	lv_textarea_get_one_line :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> bool ---
	/* Get a list of accepted characters. list of accented characters.  */
	lv_textarea_get_accepted_chars :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> ^u8 ---
	/* Get max length of a Text Area. the maximal number of characters to be add  */
	lv_textarea_get_max_length :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> u32 ---
	/* Find whether text is selected or not. whether text is selected or not  */
	lv_textarea_text_is_selected :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> bool ---
	/* Find whether selection mode is enabled. true: selection mode is enabled, false: disabled  */
	lv_textarea_get_text_selection :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> bool ---
	/* Set how long show the password before changing it to '*' show time in milliseconds. 0: hide immediately.  */
	lv_textarea_get_password_show_time :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> u32 ---
	/* Get a the character from the current cursor position a the character or 0  */
	lv_textarea_get_current_char :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) -> u32 ---
	/* Clear the selection on the text area.  */
	lv_textarea_clear_selection :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) ---
	/* Move the cursor one character right  */
	lv_textarea_cursor_right :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) ---
	/* Move the cursor one character left  */
	lv_textarea_cursor_left :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) ---
	/* Move the cursor one line down  */
	lv_textarea_cursor_down :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) ---
	/* Move the cursor one line up  */
	lv_textarea_cursor_up :: proc(/* pointer to a text area object  */obj: ^lv_obj_t) ---
	/* Create a spinbox object pointer to the created spinbox  */
	lv_spinbox_create :: proc(/* pointer to an object, it will be the parent of the new spinbox  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set spinbox value  */
	lv_spinbox_set_value :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* value to be set  */v: i32) ---
	/* Set spinbox rollover function  */
	lv_spinbox_set_rollover :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* true or false to enable or disable (default)  */rollover: bool) ---
	/* Set spinbox digit format (digit count and decimal format)  */
	lv_spinbox_set_digit_format :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* number of digit excluding the decimal separator and the sign  */digit_count: u32, /* number of digit before the decimal point. If 0, decimal point is not shown  */sep_pos: u32) ---
	/* Set the number of digits  */
	lv_spinbox_set_digit_count :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* number of digits  */digit_count: u32) ---
	/* Set the position of the decimal point  */
	lv_spinbox_set_dec_point_pos :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* 0: there is no separator, 2: two integer digits  */dec_point_pos: u32) ---
	/* Set spinbox step  */
	lv_spinbox_set_step :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* steps on increment/decrement. Can be 1, 10, 100, 1000, etc the digit that will change.  */step: u32) ---
	/* Set spinbox value range  */
	lv_spinbox_set_range :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* minimum value, inclusive  */min_value: i32, /* maximum value, inclusive  */max_value: i32) ---
	/* Set the minimum value  */
	lv_spinbox_set_min_value :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* the minimum value  */min_value: i32) ---
	/* Set the maximum value  */
	lv_spinbox_set_max_value :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* the maximum value  */max_value: i32) ---
	/* Set cursor position to a specific digit for edition  */
	lv_spinbox_set_cursor_pos :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* selected position in spinbox  */pos: u32) ---
	/* Set direction of digit step when clicking an encoder button while in editing mode  */
	lv_spinbox_set_digit_step_direction :: proc(/* pointer to spinbox  */obj: ^lv_obj_t, /* the direction (LV_DIR_RIGHT or LV_DIR_LEFT)  */direction: lv_dir_t) ---
	/* Get spinbox rollover function status  */
	lv_spinbox_get_rollover :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) -> bool ---
	/* Get the spinbox numeral value (user has to convert to float according to its digit format) value integer value of the spinbox  */
	lv_spinbox_get_value :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) -> i32 ---
	/* Get the spinbox step value (user has to convert to float according to its digit format) value integer step value of the spinbox  */
	lv_spinbox_get_step :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) -> i32 ---
	/* Get the spinbox digit count number of digits  */
	lv_spinbox_get_digit_count :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) -> u32 ---
	/* Get the decimal point position decimal point position  */
	lv_spinbox_get_dec_point_pos :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) -> u32 ---
	/* Get the spinbox minimum value minimum value  */
	lv_spinbox_get_min_value :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) -> i32 ---
	/* Get the spinbox maximum value maximum value  */
	lv_spinbox_get_max_value :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) -> i32 ---
	/* Get the digit step direction direction (LV_DIR_RIGHT or LV_DIR_LEFT)  */
	lv_spinbox_get_digit_step_direction :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) -> lv_dir_t ---
	/* Select next lower digit for edition by dividing the step by 10  */
	lv_spinbox_step_next :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) ---
	/* Select next higher digit for edition by multiplying the step by 10  */
	lv_spinbox_step_prev :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) ---
	/* Increment spinbox value by one step  */
	lv_spinbox_increment :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) ---
	/* Decrement spinbox value by one step  */
	lv_spinbox_decrement :: proc(/* pointer to spinbox  */obj: ^lv_obj_t) ---
	/* Bind an integer subject to a Spinbox's value. pointer to newly-created Observer  */
	lv_spinbox_bind_value :: proc(/* pointer to Spinbox  */obj: ^lv_obj_t, /* pointer to Subject  */subject: ^lv_subject_t) -> ^lv_observer_t ---
	/* Create a spinner widget the created spinner  */
	lv_spinner_create :: proc(/* pointer to an object, it will be the parent of the new spinner.  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the animation time and arc length of the spinner The animation is suited for angle values between 180 and 360.  */
	lv_spinner_set_anim_params :: proc(/* pointer to a spinner  */obj: ^lv_obj_t, /* the animation time in milliseconds  */t: u32, /* the angle of the arc in degrees  */angle: u32) ---
	/* Set the animation time of the spinner  */
	lv_spinner_set_anim_duration :: proc(/* pointer to a spinner  */obj: ^lv_obj_t, /* the animation time in milliseconds  */t: u32) ---
	/* Set the animation arc length of the spinner. The animation is suited to values between 180 and 360.  */
	lv_spinner_set_arc_sweep :: proc(/* pointer to a spinner  */obj: ^lv_obj_t, /* the angle of the arc in degrees  */angle: u32) ---
	/* Get the animation duration of the spinner the animation time in milliseconds  */
	lv_spinner_get_anim_duration :: proc(/* pointer to a spinner  */obj: ^lv_obj_t) -> u32 ---
	/* Get the animation arc length of the spinner the angle of the arc in degrees  */
	lv_spinner_get_arc_sweep :: proc(/* pointer to a spinner  */obj: ^lv_obj_t) -> u32 ---
	/* Create a switch object pointer to the created switch  */
	lv_switch_create :: proc(/* pointer to an object, it will be the parent of the new switch  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the orientation of switch.  */
	lv_switch_set_orientation :: proc(/* pointer to switch object  */obj: ^lv_obj_t, /* switch orientation from lv_switch_orientation_t  */orientation: lv_switch_orientation_t) ---
	/* Get the orientation of switch. switch orientation from lv_switch_orientation_t  */
	lv_switch_get_orientation :: proc(/* pointer to switch object  */obj: ^lv_obj_t) -> lv_switch_orientation_t ---
	/* Create a table object pointer to the created table  */
	lv_table_create :: proc(/* pointer to an object, it will be the parent of the new table  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the value of a cell. New roes/columns are added automatically if required  */
	lv_table_set_cell_value :: proc(/* pointer to a Table object  */obj: ^lv_obj_t, /* id of the row [0 .. row_cnt -1]  */row: u32, /* id of the column [0 .. col_cnt -1]  */col: u32, /* text to display in the cell. It will be copied and saved so this variable is not required after this function call.  */txt: ^u8) ---
	/* Set the value of a cell. Memory will be allocated to store the text by the table. New roes/columns are added automatically if required  */
	lv_table_set_cell_value_fmt :: proc(/* pointer to a Table object  */obj: ^lv_obj_t, /* id of the row [0 .. row_cnt -1]  */row: u32, /* id of the column [0 .. col_cnt -1]  */col: u32, /* printf -like format  */fmt: ^u8, #c_vararg args: ..any) ---
	/* Set the number of rows  */
	lv_table_set_row_count :: proc(/* table pointer to a Table object  */obj: ^lv_obj_t, /* number of rows  */row_cnt: u32) ---
	/* Set the number of columns  */
	lv_table_set_column_count :: proc(/* table pointer to a Table object  */obj: ^lv_obj_t, /* number of columns.  */col_cnt: u32) ---
	/* Set the width of a column  */
	lv_table_set_column_width :: proc(/* table pointer to a Table object  */obj: ^lv_obj_t, /* id of the column [0 .. LV_TABLE_COL_MAX -1]  */col_id: u32, /* width of the column  */w: i32) ---
	/* Add control bits to the cell.  */
	lv_table_set_cell_ctrl :: proc(/* pointer to a Table object  */obj: ^lv_obj_t, /* id of the row [0 .. row_cnt -1]  */row: u32, /* id of the column [0 .. col_cnt -1]  */col: u32, /* OR-ed values from lv_table_cell_ctrl_t  */ctrl: lv_table_cell_ctrl_t) ---
	/* Clear control bits of the cell.  */
	lv_table_clear_cell_ctrl :: proc(/* pointer to a Table object  */obj: ^lv_obj_t, /* id of the row [0 .. row_cnt -1]  */row: u32, /* id of the column [0 .. col_cnt -1]  */col: u32, /* OR-ed values from lv_table_cell_ctrl_t  */ctrl: lv_table_cell_ctrl_t) ---
	/* Add custom user data to the cell.  */
	lv_table_set_cell_user_data :: proc(/* pointer to a Table object  */obj: ^lv_obj_t, /* id of the row [0 .. row_cnt -1]  */row: u16, /* id of the column [0 .. col_cnt -1]  */col: u16, /* pointer to the new user_data. Should be allocated by lv_malloc , and it will be freed automatically when the table is deleted or when the cell is dropped due to lower row or column count.  */user_data: rawptr) ---
	/* Set the selected cell  */
	lv_table_set_selected_cell :: proc(/* pointer to a table object  */obj: ^lv_obj_t, /* id of the cell row to select  */row: u16, /* id of the cell column to select  */col: u16) ---
	/* Get the value of a cell. text in the cell  */
	lv_table_get_cell_value :: proc(/* pointer to a Table object  */obj: ^lv_obj_t, /* id of the row [0 .. row_cnt -1]  */row: u32, /* id of the column [0 .. col_cnt -1]  */col: u32) -> ^u8 ---
	/* Get the number of rows. number of rows.  */
	lv_table_get_row_count :: proc(/* table pointer to a Table object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the number of columns. number of columns.  */
	lv_table_get_column_count :: proc(/* table pointer to a Table object  */obj: ^lv_obj_t) -> u32 ---
	/* Get the width of a column width of the column  */
	lv_table_get_column_width :: proc(/* table pointer to a Table object  */obj: ^lv_obj_t, /* id of the column [0 .. LV_TABLE_COL_MAX -1]  */col: u32) -> i32 ---
	/* Get whether a cell has the control bits true: all control bits are set; false: not all control bits are set  */
	lv_table_has_cell_ctrl :: proc(/* pointer to a Table object  */obj: ^lv_obj_t, /* id of the row [0 .. row_cnt -1]  */row: u32, /* id of the column [0 .. col_cnt -1]  */col: u32, /* OR-ed values from lv_table_cell_ctrl_t  */ctrl: lv_table_cell_ctrl_t) -> bool ---
	/* Get the selected cell (pressed and or focused)  */
	lv_table_get_selected_cell :: proc(/* pointer to a table object  */obj: ^lv_obj_t, /* pointer to variable to store the selected row (LV_TABLE_CELL_NONE: if no cell selected)  */row: ^u32, /* pointer to variable to store the selected column (LV_TABLE_CELL_NONE: if no cell selected)  */col: ^u32) ---
	/* Get custom user data to the cell.  */
	lv_table_get_cell_user_data :: proc(/* pointer to a Table object  */obj: ^lv_obj_t, /* id of the row [0 .. row_cnt -1]  */row: u16, /* id of the column [0 .. col_cnt -1]  */col: u16) -> rawptr ---
	/* Create a tabview widget the created tabview  */
	lv_tabview_create :: proc(/* pointer to a parent widget  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Add a tab to the tabview the widget where the content of the tab can be created  */
	lv_tabview_add_tab :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t, /* the name of the tab, it will be displayed on the tab bar  */name: ^u8) -> ^lv_obj_t ---
	/* Change the name of the tab  */
	lv_tabview_set_tab_text :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t, /* the index of the tab to rename  */idx: u32, /* the new name as a string  */new_name: ^u8) ---
	/* Show a tab  */
	lv_tabview_set_active :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t, /* the index of the tab to show  */idx: u32, /* LV_ANIM_ON/OFF  */anim_en: lv_anim_enable_t) ---
	/* Set the position of the tab bar  */
	lv_tabview_set_tab_bar_position :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t, /* LV_DIR_TOP/BOTTOM/LEFT/RIGHT  */dir: lv_dir_t) ---
	/* Set the width or height of the tab bar  */
	lv_tabview_set_tab_bar_size :: proc(/* pointer to tabview widget  */obj: ^lv_obj_t, /* size of the tab bar in pixels or percentage. will be used as width or height based on the position of the tab bar)  */size: i32) ---
	/* Get the number of tabs the number of tabs  */
	lv_tabview_get_tab_count :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t) -> u32 ---
	/* Get the current tab's index the zero based index of the current tab  */
	lv_tabview_get_tab_active :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t) -> u32 ---
	/* Get a given tab button by index pointer to the tab button, or NULL if the index was out of range  */
	lv_tabview_get_tab_button :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t, /* zero based index of the tab button to get. < 0 means start counting tab button from the back (-1 is the last tab button)  */idx: i32) -> ^lv_obj_t ---
	/* Get the widget where the container of each tab is created the main container widget  */
	lv_tabview_get_content :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the tab bar where the buttons are created the tab bar  */
	lv_tabview_get_tab_bar :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the position of the tab bar LV_DIR_TOP/BOTTOM/LEFT/RIGHT  */
	lv_tabview_get_tab_bar_position :: proc(/* pointer to a tabview widget  */obj: ^lv_obj_t) -> lv_dir_t ---
	/* Create a tileview object pointer to the created tileview  */
	lv_tileview_create :: proc(/* pointer to an object, it will be the parent of the new tileview  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Add a tile to the tileview pointer to the added tile object  */
	lv_tileview_add_tile :: proc(/* pointer to the tileview object  */tv: ^lv_obj_t, /* column id of the tile  */col_id: u8, /* row id of the tile  */row_id: u8, /* direction to move to the next tile  */dir: lv_dir_t) -> ^lv_obj_t ---
	/* Set the active tile in the tileview.  */
	lv_tileview_set_tile :: proc(tv: ^lv_obj_t, /* pointer to the tile object to be set as active  */tile_obj: ^lv_obj_t, /* animation enable flag (LV_ANIM_ON or LV_ANIM_OFF)  */anim_en: lv_anim_enable_t) ---
	/* Set the active tile by index in the tileview  */
	lv_tileview_set_tile_by_index :: proc(/* pointer to the tileview object  */tv: ^lv_obj_t, /* column id of the tile to be set as active  */col_id: u32, /* row id of the tile to be set as active  */row_id: u32, /* animation enable flag (LV_ANIM_ON or LV_ANIM_OFF)  */anim_en: lv_anim_enable_t) ---
	/* Get the currently active tile in the tileview pointer to the currently active tile object  */
	lv_tileview_get_tile_active :: proc(/* pointer to the tileview object  */obj: ^lv_obj_t) -> ^lv_obj_t ---
	/* Create a window widget the created window  */
	lv_win_create :: proc(/* pointer to a parent widget  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Add a title to the window the widget where the content of the title can be created  */
	lv_win_add_title :: proc(win: ^lv_obj_t, /* the text of the title  */txt: ^u8) -> ^lv_obj_t ---
	/* Add a button to the window the widget where the content of the button can be created  */
	lv_win_add_button :: proc(win: ^lv_obj_t, /* an icon to be displayed on the button  */icon: rawptr, /* width of the button  */btn_w: i32) -> ^lv_obj_t ---
	/* Get the header of the window the header of the window  */
	lv_win_get_header :: proc(/* pointer to a window widget  */win: ^lv_obj_t) -> ^lv_obj_t ---
	/* Get the content of the window the content of the window  */
	lv_win_get_content :: proc(/* pointer to a window widget  */win: ^lv_obj_t) -> ^lv_obj_t ---
	/* Create fragment manager instance Fragment manager instance  */
	lv_fragment_manager_create :: proc(/* Parent fragment if this manager is placed inside another fragment, can be null.  */parent: ^lv_fragment_t) -> ^lv_fragment_manager_t ---
	/* Destroy fragment manager instance  */
	lv_fragment_manager_delete :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t) ---
	/* Create object of all fragments managed by this manager.  */
	lv_fragment_manager_create_obj :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t) ---
	/* Delete object created by all fragments managed by this manager. Instance of fragments will not be deleted.  */
	lv_fragment_manager_delete_obj :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t) ---
	/* Attach fragment to manager, and add to container.  */
	lv_fragment_manager_add :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t, /* Fragment instance  */fragment: ^lv_fragment_t, /* Pointer to container object for manager to add objects to  */container: ^^lv_obj_t) ---
	/* Detach and destroy fragment. If fragment is in navigation stack, remove from it.  */
	lv_fragment_manager_remove :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t, /* Fragment instance  */fragment: ^lv_fragment_t) ---
	/* Attach fragment to manager and add to navigation stack.  */
	lv_fragment_manager_push :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t, /* Fragment instance  */fragment: ^lv_fragment_t, /* Pointer to container object for manager to add objects to  */container: ^^lv_obj_t) ---
	/* Remove the top-most fragment for stack true if there is fragment to pop  */
	lv_fragment_manager_pop :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t) -> bool ---
	/* Replace fragment. Old item in the stack will be removed.  */
	lv_fragment_manager_replace :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t, /* Fragment instance  */fragment: ^lv_fragment_t, /* Pointer to container object for manager to add objects to  */container: ^^lv_obj_t) ---
	/* Send event to top-most fragment true if fragment returned true  */
	lv_fragment_manager_send_event :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t, /* User-defined ID of event  */code: i32, /* User-defined data  */userdata: rawptr) -> bool ---
	/* Get stack size of this fragment manager Stack size of this fragment manager  */
	lv_fragment_manager_get_stack_size :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t) -> uint ---
	/* Get top most fragment instance Top most fragment instance  */
	lv_fragment_manager_get_top :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t) -> ^lv_fragment_t ---
	/* Find first fragment instance in the container First fragment instance in the container  */
	lv_fragment_manager_find_by_container :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t, /* Container which target fragment added to  */container: ^lv_obj_t) -> ^lv_fragment_t ---
	/* Get parent fragment Parent fragment instance  */
	lv_fragment_manager_get_parent_fragment :: proc(/* Fragment manager instance  */manager: ^lv_fragment_manager_t) -> ^lv_fragment_t ---
	/* Create a fragment instance. 

Fragment instance   */
	lv_fragment_create :: proc(/* Fragment class. This fragment must return non null object.  */cls: ^lv_fragment_class_t, /* Arguments assigned by fragment manager  */args: rawptr) -> ^lv_fragment_t ---
	/* Destroy a fragment.  */
	lv_fragment_delete :: proc(/* Fragment instance.  */fragment: ^lv_fragment_t) ---
	/* Get associated manager of this fragment Fragment manager instance  */
	lv_fragment_get_manager :: proc(/* Fragment instance  */fragment: ^lv_fragment_t) -> ^lv_fragment_manager_t ---
	/* Get container object of this fragment Reference to container object  */
	lv_fragment_get_container :: proc(/* Fragment instance  */fragment: ^lv_fragment_t) -> ^^lv_obj_t ---
	/* Get parent fragment of this fragment Parent fragment  */
	lv_fragment_get_parent :: proc(/* Fragment instance  */fragment: ^lv_fragment_t) -> ^lv_fragment_t ---
	/* Create object by fragment. 

Created object   */
	lv_fragment_create_obj :: proc(/* Fragment instance.  */fragment: ^lv_fragment_t, /* Container of the objects should be created upon.  */container: ^lv_obj_t) -> ^lv_obj_t ---
	/* Delete created object of a fragment  */
	lv_fragment_delete_obj :: proc(/* Fragment instance.  */fragment: ^lv_fragment_t) ---
	/* Destroy obj in fragment, and recreate them.  */
	lv_fragment_recreate_obj :: proc(/* Fragment instance  */fragment: ^lv_fragment_t) ---
	/* Create an empty barcode (an lv_canvas ) object. pointer to the created barcode object  */
	lv_barcode_create :: proc(/* point to an object where to create the barcode  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the dark color of a barcode object  */
	lv_barcode_set_dark_color :: proc(/* pointer to barcode object  */obj: ^lv_obj_t, /* dark color of the barcode  */color: lv_color_t) ---
	/* Set the light color of a barcode object  */
	lv_barcode_set_light_color :: proc(/* pointer to barcode object  */obj: ^lv_obj_t, /* light color of the barcode  */color: lv_color_t) ---
	/* Set the scale of a barcode object  */
	lv_barcode_set_scale :: proc(/* pointer to barcode object  */obj: ^lv_obj_t, /* scale factor  */scale: u16) ---
	/* Set the direction of a barcode object  */
	lv_barcode_set_direction :: proc(/* pointer to barcode object  */obj: ^lv_obj_t, /* draw direction ( LV_DIR_HOR or LB_DIR_VER )  */direction: lv_dir_t) ---
	/* Set the tiled mode of a barcode object  */
	lv_barcode_set_tiled :: proc(/* pointer to barcode object  */obj: ^lv_obj_t, /* true: tiled mode, false: normal mode (default)  */tiled: bool) ---
	/* Set the encoding of a barcode object  */
	lv_barcode_set_encoding :: proc(/* pointer to barcode object  */obj: ^lv_obj_t, /* encoding (default is LV_BARCODE_CODE128_GS1 )  */encoding: lv_barcode_encoding_t) ---
	/* Set the data of a barcode object LV_RESULT_OK: if no error; LV_RESULT_INVALID: on error  */
	lv_barcode_update :: proc(/* pointer to barcode object  */obj: ^lv_obj_t, /* data to display  */data: ^u8) -> lv_result_t ---
	/* Get the dark color of a barcode object dark color of the barcode  */
	lv_barcode_get_dark_color :: proc(/* pointer to barcode object  */obj: ^lv_obj_t) -> lv_color_t ---
	/* Get the light color of a barcode object light color of the barcode  */
	lv_barcode_get_light_color :: proc(/* pointer to barcode object  */obj: ^lv_obj_t) -> lv_color_t ---
	/* Get the scale of a barcode object scale factor  */
	lv_barcode_get_scale :: proc(/* pointer to barcode object  */obj: ^lv_obj_t) -> u16 ---
	/* Get the encoding of a barcode object encoding  */
	lv_barcode_get_encoding :: proc(/* pointer to barcode object  */obj: ^lv_obj_t) -> lv_barcode_encoding_t ---
	/* Initialize the binary image decoder module  */
	lv_bin_decoder_init :: proc() ---
	/* Get info about a lvgl binary image LV_RESULT_OK: the info is successfully stored in header ; LV_RESULT_INVALID: unknown format or other error.  */
	lv_bin_decoder_info :: proc(/* the decoder where this function belongs  */decoder: ^lv_image_decoder_t, /* image descriptor containing the source and type of the image and other info.  */dsc: ^lv_image_decoder_dsc_t, /* store the image data here  */header: ^lv_image_header_t) -> lv_result_t ---
	lv_bin_decoder_get_area :: proc(decoder: ^lv_image_decoder_t, dsc: ^lv_image_decoder_dsc_t, full_area: ^lv_area_t, decoded_area: ^lv_area_t) -> lv_result_t ---
	/* Open a lvgl binary image LV_RESULT_OK: the info is successfully stored in header ; LV_RESULT_INVALID: unknown format or other error.  */
	lv_bin_decoder_open :: proc(/* the decoder where this function belongs  */decoder: ^lv_image_decoder_t, /* pointer to decoder descriptor. src , style are already initialized in it.  */dsc: ^lv_image_decoder_dsc_t) -> lv_result_t ---
	/* Close the pending decoding. Free resources etc.  */
	lv_bin_decoder_close :: proc(/* pointer to the decoder the function associated with  */decoder: ^lv_image_decoder_t, /* pointer to decoder descriptor  */dsc: ^lv_image_decoder_dsc_t) ---
	lv_bmp_init :: proc() ---
	lv_bmp_deinit :: proc() ---
	lv_rle_decompress :: proc(input: ^u8, input_buff_len: u32, output: ^u8, output_buff_len: u32, blk_size: u8) -> u32 ---
	/* Register the PNG decoder functions in LVGL  */
	lv_lodepng_init :: proc() ---
	lv_lodepng_deinit :: proc() ---
	/* Register the PNG decoder functions in LVGL  */
	lv_libpng_init :: proc() ---
	lv_libpng_deinit :: proc() ---
	/* Register the WEBP decoder functions in LVGL  */
	lv_libwebp_init :: proc() ---
	lv_libwebp_deinit :: proc() ---
	/* Create a gif object pointer to the gif obj  */
	lv_gif_create :: proc(/* pointer to an object, it will be the parent of the new gif.  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set the color format of the internally allocated framebuffer that the gif will be decoded to. The default is LV_COLOR_FORMAT_ARGB8888. Call this before lv_gif_set_src to avoid reallocating the framebuffer.  */
	lv_gif_set_color_format :: proc(/* pointer to a gif object  */obj: ^lv_obj_t, /* the color format of the gif framebuffer  */color_format: lv_color_format_t) ---
	/* Set the gif data to display on the object  */
	lv_gif_set_src :: proc(/* pointer to a gif object  */obj: ^lv_obj_t, /* 1) pointer to an :ref:`lv_img_dsc_t` descriptor (which contains gif raw data) or 2) path to a gif file (e.g. "S:/dir/anim.gif")  */src: rawptr) ---
	/* Restart a gif animation.  */
	lv_gif_restart :: proc(/* pointer to a gif obj  */obj: ^lv_obj_t) ---
	/* Pause a gif animation.  */
	lv_gif_pause :: proc(/* pointer to a gif obj  */obj: ^lv_obj_t) ---
	/* Resume a gif animation.  */
	lv_gif_resume :: proc(/* pointer to a gif obj  */obj: ^lv_obj_t) ---
	/* Checks if the GIF was loaded correctly.  */
	lv_gif_is_loaded :: proc(/* pointer to a gif obj  */obj: ^lv_obj_t) -> bool ---
	/* Get the loop count for the GIF.  */
	lv_gif_get_loop_count :: proc(/* pointer to a gif obj  */obj: ^lv_obj_t) -> i32 ---
	/* Set the loop count for the GIF.  */
	lv_gif_set_loop_count :: proc(/* pointer to a gif obj  */obj: ^lv_obj_t, /* the loop count to set  */count: i32) ---
	/* Create an empty QR code (an lv_canvas ) object. pointer to the created QR code object  */
	lv_qrcode_create :: proc(/* point to an object where to create the QR code  */parent: ^lv_obj_t) -> ^lv_obj_t ---
	/* Set QR code size.  */
	lv_qrcode_set_size :: proc(/* pointer to a QR code object  */obj: ^lv_obj_t, /* width and height of the QR code  */size: i32) ---
	/* Set QR code dark color.  */
	lv_qrcode_set_dark_color :: proc(/* pointer to a QR code object  */obj: ^lv_obj_t, /* dark color of the QR code  */color: lv_color_t) ---
	/* Set QR code light color.  */
	lv_qrcode_set_light_color :: proc(/* pointer to a QR code object  */obj: ^lv_obj_t, /* light color of the QR code  */color: lv_color_t) ---
	/* Set the data of a QR code object LV_RESULT_OK: if no error; LV_RESULT_INVALID: on error  */
	lv_qrcode_update :: proc(/* pointer to a QR code object  */obj: ^lv_obj_t, /* data to display  */data: rawptr, /* length of data in bytes  */data_len: u32) -> lv_result_t ---
	/* Helper function to set the data of a QR code object  */
	lv_qrcode_set_data :: proc(/* pointer to a QR code object  */obj: ^lv_obj_t, /* data to display as a string  */data: ^u8) ---
	/* Enable or disable quiet zone. Quiet zone is the area around the QR code where no data is encoded.  */
	lv_qrcode_set_quiet_zone :: proc(/* pointer to a QR code object  */obj: ^lv_obj_t, /* true: enable quiet zone; false: disable quiet zone  */enable: bool) ---
	lv_tjpgd_init :: proc() ---
	lv_tjpgd_deinit :: proc() ---
	/* Register the JPEG-Turbo decoder functions in LVGL  */
	lv_libjpeg_turbo_init :: proc() ---
	lv_libjpeg_turbo_deinit :: proc() ---
	/* Initialize the freetype library. LV_RESULT_OK on success, otherwise LV_RESULT_INVALID.  */
	lv_freetype_init :: proc(max_glyph_cnt: u32) -> lv_result_t ---
	/* Uninitialize the freetype library  */
	lv_freetype_uninit :: proc() ---
	/* Initialize a font info structure.  */
	lv_freetype_init_font_info :: proc(/* font info structure to be initialized.  */font_info: ^lv_font_info_t) ---
	/* Create a freetype font with a font info structure. Created font, or NULL on failure.  */
	lv_freetype_font_create_with_info :: proc(/* font info structure.  */font_info: ^lv_font_info_t) -> ^lv_font_t ---
	/* Create a freetype font. Created font, or NULL on failure.  */
	lv_freetype_font_create :: proc(/* font file path.  */pathname: ^u8, /* font render mode(see @lv_freetype_font_render_mode_t for details).  */render_mode: lv_freetype_font_render_mode_t, /* font size.  */size: u32, /* font style(see lv_freetype_font_style_t for details).  */style: lv_freetype_font_style_t) -> ^lv_font_t ---
	/* Delete a freetype font.  */
	lv_freetype_font_delete :: proc(/* freetype font to be deleted.  */font: ^lv_font_t) ---
	/* Register a callback function to generate outlines for FreeType fonts. 

The ID of the registered callback function, or a negative value on failure.   */
	lv_freetype_outline_add_event :: proc(event_cb: lv_event_cb_t, filter: lv_event_code_t, /* User data to be passed to the callback function.  */user_data: rawptr) ---
	/* Get the scale of a FreeType font. 

The scale of the FreeType font.   */
	lv_freetype_outline_get_scale :: proc(/* The FreeType font to get the scale of.  */font: ^lv_font_t) -> u32 ---
	/* Check if the font is an outline font. 

Is outline font on success, otherwise false.   */
	lv_freetype_is_outline_font :: proc(/* The FreeType font.  */font: ^lv_font_t) -> bool ---
	/* Create a font from the specified data pointer with the specified line height. a font object  */
	lv_tiny_ttf_create_data :: proc(/* the data pointer  */data: rawptr, /* the data size  */data_size: uint, /* the font size in pixel  */font_size: i32) -> ^lv_font_t ---
	/* Create a font from the specified data pointer with the specified line height and the specified cache size.  */
	lv_tiny_ttf_create_data_ex :: proc(/* the data pointer  */data: rawptr, /* the data size  */data_size: uint, /* the font size in pixel  */font_size: i32, /* kerning value in pixel  */kerning: lv_font_kerning_t, /* the cache size in count  */cache_size: uint) -> ^lv_font_t ---
	/* Set the size of the font to a new font_size the font bitmap cache and glyph cache will be flushed.  */
	lv_tiny_ttf_set_size :: proc(/* the font object  */font: ^lv_font_t, /* the font size in pixel  */font_size: i32) ---
	/* Destroy a font previously created with lv_tiny_ttf_create_xxxx()  */
	lv_tiny_ttf_destroy :: proc(/* the font object  */font: ^lv_font_t) ---
	/* Converts an I1 buffer to ARGB8888 format.  */
	lv_draw_sw_i1_to_argb8888 :: proc(/* pointer to buffer with I1 formatted render  */buf_i1: rawptr, /* pointer to buffer for ARGB8888 render  */buf_argb8888: rawptr, /* width in pixels of the area. must be a multiple of 8.  */width: u32, /* height in pixels of the area  */height: u32, /* stride of i1 buffer in bytes  */buf_i1_stride: u32, /* stride of argb8888 buffer in bytes  */buf_argb8888_stride: u32, /* color of the 0 bits of i1 buf  */index0_color: u32, /* color of the 1 bits of i1 buf  */index1_color: u32) ---
	/* Swap the upper and lower byte of an RGB565 buffer. Might be required if a 8bit parallel port or an SPI port send the bytes in the wrong order. The bytes will be swapped in place.  */
	lv_draw_sw_rgb565_swap :: proc(/* pointer to buffer  */buf: rawptr, /* number of pixels in the buffer  */buf_size_px: u32) ---
	/* Invert a draw buffer in the I1 color format. Conventionally, a bit is set to 1 during blending if the luminance is greater than 127. Depending on the display controller used, you might want to have different behavior. The inversion will be performed in place.  */
	lv_draw_sw_i1_invert :: proc(/* pointer to the buffer to be inverted  */buf: rawptr, /* size of the buffer in bytes  */buf_size: u32) ---
	/* Convert a draw buffer in I1 color format from htiled (row-wise) to vtiled (column-wise) buffer layout. The conversion assumes that the buffer width and height is rounded to a multiple of 8.  */
	lv_draw_sw_i1_convert_to_vtiled :: proc(/* pointer to the buffer to be converted  */buf: rawptr, /* size of the buffer in bytes  */buf_size: u32, /* width of the buffer  */width: u32, /* height of the buffer  */height: u32, /* pointer to the output buffer  */out_buf: rawptr, /* size of the output buffer in bytes  */out_buf_size: u32, /* bit order of the resulting vtiled buffer  */bit_order_lsb: bool) ---
	/* Rotate a buffer into another buffer  */
	lv_draw_sw_rotate :: proc(/* the source buffer  */src: rawptr, /* the destination buffer  */dest: rawptr, /* source width in pixels  */src_width: i32, /* source height in pixels  */src_height: i32, /* source stride in bytes (number of bytes in a row)  */src_stride: i32, /* destination stride in bytes (number of bytes in a row)  */dest_stride: i32, /* LV_DISPLAY_ROTATION_0/90/180/270  */rotation: lv_display_rotation_t, /* LV_COLOR_FORMAT_RGB565/RGB888/XRGB8888/ARGB8888  */color_format: lv_color_format_t) ---
	/* Take snapshot for object with its children, create the draw buffer as needed. a pointer to an draw buffer containing snapshot image, or NULL if failed.  */
	lv_snapshot_take :: proc(/* the object to generate snapshot.  */obj: ^lv_obj_t, /* color format for generated image.  */cf: lv_color_format_t) -> ^lv_draw_buf_t ---
	/* Create a draw buffer to store the snapshot image for object. a pointer to an draw buffer ready for taking snapshot, or NULL if failed.  */
	lv_snapshot_create_draw_buf :: proc(/* the object to generate snapshot.  */obj: ^lv_obj_t, /* color format for generated image.  */cf: lv_color_format_t) -> ^lv_draw_buf_t ---
	/* Reshape the draw buffer to prepare for taking snapshot for obj. This is usually used to check if the existing draw buffer is enough for obj snapshot. If return LV_RESULT_INVALID, you should create a new one.  */
	lv_snapshot_reshape_draw_buf :: proc(/* the object to generate snapshot.  */obj: ^lv_obj_t, /* the draw buffer to reshape.  */draw_buf: ^lv_draw_buf_t) -> lv_result_t ---
	/* Take snapshot for object with its children, save image info to provided buffer. LV_RESULT_OK on success, LV_RESULT_INVALID on error.  */
	lv_snapshot_take_to_draw_buf :: proc(/* the object to generate snapshot.  */obj: ^lv_obj_t, /* color format for new snapshot image. It could differ with cf of draw_buf as long as the new cf will fit in.  */cf: lv_color_format_t, /* the draw buffer to store the image result. It's reshaped automatically.  */draw_buf: ^lv_draw_buf_t) -> lv_result_t ---
	/* Deprecated Use lv_draw_buf_destroy instead. 

Free the snapshot image returned by :ref:`lv_snapshot_take`    */
	lv_snapshot_free :: proc(/* the image descriptor generated by lv_snapshot_take.  */dsc: ^lv_img_dsc_t) ---
	/* Take snapshot for object with its children, save image info to provided buffer. LV_RESULT_OK on success, LV_RESULT_INVALID on error.  Deprecated Use lv_snapshot_take_to_draw_buf instead.  */
	lv_snapshot_take_to_buf :: proc(/* the object to generate snapshot.  */obj: ^lv_obj_t, /* color format for generated image.  */cf: lv_color_format_t, /* image descriptor to store the image result.  */dsc: ^lv_img_dsc_t, /* the buffer to store image data. It must meet align requirement.  */buf: rawptr, /* provided buffer size in bytes.  */buf_size: u32) -> lv_result_t ---
	/* Creates a new theme the new theme or NULL if allocation failed  */
	lv_theme_create :: proc() -> ^lv_theme_t ---
	/* Copy 'src' theme into 'dst'  */
	lv_theme_copy :: proc(/* pointer to the destination theme  */dst: ^lv_theme_t, /* pointer to the source theme  */src: ^lv_theme_t) ---
	/* Get the theme assigned to the display of the object the theme of the object's display (can be NULL)  */
	lv_theme_get_from_obj :: proc(/* pointer to a theme object  */obj: ^lv_obj_t) -> ^lv_theme_t ---
	/* Apply the active theme on an object  */
	lv_theme_apply :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Set a base theme for a theme. The styles from the base them will be added before the styles of the current theme. Arbitrary long chain of themes can be created by setting base themes.  */
	lv_theme_set_parent :: proc(/* pointer to theme which base should be set  */theme: ^lv_theme_t, /* pointer to the base theme  */parent: ^lv_theme_t) ---
	/* Set an apply callback for a theme. The apply callback is used to add styles to different objects  */
	lv_theme_set_apply_cb :: proc(/* pointer to theme which callback should be set  */theme: ^lv_theme_t, /* pointer to the callback  */apply_cb: lv_theme_apply_cb_t) ---
	/* Get the small font of the theme pointer to the font  */
	lv_theme_get_font_small :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_font_t ---
	/* Get the normal font of the theme pointer to the font  */
	lv_theme_get_font_normal :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_font_t ---
	/* Get the subtitle font of the theme pointer to the font  */
	lv_theme_get_font_large :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> ^lv_font_t ---
	/* Get the primary color of the theme the color  */
	lv_theme_get_color_primary :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> lv_color_t ---
	/* Get the secondary color of the theme the color  */
	lv_theme_get_color_secondary :: proc(/* pointer to an object  */obj: ^lv_obj_t) -> lv_color_t ---
	/* Delete a theme  */
	lv_theme_delete :: proc(/* the theme to destroy  */theme: ^lv_theme_t) ---
	/* Initialize the theme a pointer to reference this theme later  */
	lv_theme_default_init :: proc(/* pointer to display  */disp: ^lv_display_t, /* the primary color of the theme  */color_primary: lv_color_t, /* the secondary color for the theme  */color_secondary: lv_color_t, dark: bool, /* pointer to a font to use.  */font: ^lv_font_t) -> ^lv_theme_t ---
	/* Check if default theme is initialized true if default theme is initialized, false otherwise  */
	lv_theme_default_is_inited :: proc() -> bool ---
	/* Get default theme a pointer to default theme, or NULL if this is not initialized  */
	lv_theme_default_get :: proc() -> ^lv_theme_t ---
	/* Deinitialize the default theme  */
	lv_theme_default_deinit :: proc() ---
	/* Initialize the theme a pointer to reference this theme later  */
	lv_theme_mono_init :: proc(/* pointer to display  */disp: ^lv_display_t, dark_bg: bool, /* pointer to a font to use.  */font: ^lv_font_t) -> ^lv_theme_t ---
	/* Check if the theme is initialized true if default theme is initialized, false otherwise  */
	lv_theme_mono_is_inited :: proc() -> bool ---
	/* Get mono theme a pointer to mono theme, or NULL if this is not initialized  */
	lv_theme_mono_get :: proc() -> ^lv_theme_t ---
	/* Deinitialize the mono theme  */
	lv_theme_mono_deinit :: proc() ---
	/* Initialize the theme a pointer to reference this theme later  */
	lv_theme_simple_init :: proc(/* pointer to display  */disp: ^lv_display_t) -> ^lv_theme_t ---
	/* Check if the theme is initialized true if default theme is initialized, false otherwise  */
	lv_theme_simple_is_inited :: proc() -> bool ---
	/* Get simple theme a pointer to simple theme, or NULL if this is not initialized  */
	lv_theme_simple_get :: proc() -> ^lv_theme_t ---
	/* Deinitialize the simple theme  */
	lv_theme_simple_deinit :: proc() ---
	lv_task_handler :: proc() -> u32 ---
	/* Move the object to the foreground. It will look like if it was created as the last child of its parent. It also means it can cover any of the siblings.  */
	lv_obj_move_foreground :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	/* Move the object to the background. It will look like if it was created as the first child of its parent. It also means any of the siblings can cover the object.  */
	lv_obj_move_background :: proc(/* pointer to an object  */obj: ^lv_obj_t) ---
	lv_version_major :: proc() -> i32 ---
	lv_version_minor :: proc() -> i32 ---
	lv_version_patch :: proc() -> i32 ---
	lv_version_info :: proc() -> ^u8 ---
}
